<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="format-detection" content="telephone=no">
    <meta name="robots" content="noindex, nofollow">
    <meta name="robots" content="none">
    <meta name="robots" content="noimageindex, nofollow">
    <link rel="icon" type="image/svg+xml" href="./assets/favicon.svg">
    <link rel="stylesheet" type="text/css" href="./assets/style.css">
    <title>qabook</title>
    <script defer type="module" src="./assets/js/main.js"></script>
  </head>
  <body>
    <nav class="dropup"><a href="./process.html">Process</a><a href="./docs.html">Docs</a><a href="./layout.html">Layout</a><a href="./web.html">Web</a><a href="./langs.html">Langs</a><a href="#!">Project</a><a href="./job.html">Job</a>
    </nav>
    <div class="search">
      <form class="search__content">
        <input type="text" placeholder="search...">
        <button class="search-btn" type="submit"><img src="./assets/img/search.svg" alt="" loading="lazy"/>
        </button>
        <button class="search-reset" type="reset"><img src="./assets/img/close.svg" alt="" loading="lazy"/>
        </button>
      </form>
    </div>
    <button class="close"><img src="./assets/img/close.svg" alt="" loading="lazy"/>
    </button>
    <div class="container">
      <header><nav class="breadcrumbs" id="breadcrumbs-container"></nav>
      </header>
      <main>
        <details>
          <summary>Markdown</summary><a></a>
          <p>перенос строки: два пробела</p>
          <table>
            <tbody> 
              <tr>
                <td>Heading</td>
                <td>
                  # H1
                  ## H2
                  ### H3
                  #### H4
                  ##### H5
                  ###### H6
                </td>
              </tr>
              <tr>
                <td>Bold</td>
                <td>
                  **bold text**
                  __bold text__
                </td>
              </tr>
              <tr>
                <td>Italic</td>
                <td>*italicized text*</td>
              </tr>
              <tr>
                <td>Strike through</td>
                <td>~~The world is flat.~~</td>
              </tr>
              <tr>
                <td>Blockquote</td>
                <td>> blockquote</td>
              </tr>
              <tr>
                <td>Ordered List</td>
                <td>
                  1. First item
                  2. Second item
                  3. Third item
                </td>
              </tr>
              <tr>
                <td>Unordered List</td>
                <td>
                  - First item
                  - Second item
                  - Third item
                </td>
              </tr>
              <tr>
                <td>Code</td>
                <td>code</td>
              </tr>
              <tr>
                <td>Link</td>
                <td>
                  [title](https://www.example.com) либо [Текст ссылки](#id)<br />
                  <br />
                  автоматически генерирует ID для заголовков:<br />
                  # Моя новая секция -> #моя-новая-секция<br />
                  [Моя новая секция](#моя-новая-секция)<br />
                  <br />
                  Указать id для целевого элемента:<br />
                  ## Заголовок {#my-section}<br />
                  <br />
                  Внутренняя ссылка на другой файл:<br />
                  [Текст ссылки](путь/к/файлу.md)<br />
                  <br />
                  В тексте:<br />
                  [текст ссылки][id]<br />
                  <br />
                  ниже в файле определить саму ссылку:
                  [id]: адрес_или_путь.
                </td>
              </tr>
              <tr>
                <td>Image</td>
                <td>![alt text](image.jpg)</td>
              </tr>
              <tr>
                <td>Table</td>
                <td>
                  | Item         | Price | # In stock |<br/ >
                  |--------------|:-----:|-----------:|<br/ >
                  | Juicy Apples | 1.99  |        739 |<br/ >
                  | Bananas      | 1.89  |          6 |<br/ >
                  <br/ >
                  : - по какому краю выравнивание<br/ >
                </td>
              </tr>
              <tr>
                <td>Fenced Code Block</td>
                <td>
                  {<br />
                    "firstName": "John",<br />
                    "lastName": "Smith",<br />
                    "age": 25<br />
                  }<br />
                </td>
              </tr>
              <tr>
                <td>Footnote</td>
                <td>
                  Here's a sentence with a footnote. [^1]
                  [^1]: This is the footnote.
                </td>
              </tr>
              <tr>
                <td>Heading ID</td>
                <td>My Great Heading {#custom-id}</td>
              </tr>
              <tr>
                <td>Definition List</td>
                <td>
                  term<br />
                  : definition
                </td>
              </tr>
              <tr>
                <td>Task List</td>
                <td>
                  - [x] Write the press release<br />
                  - [ ] Update the website<br />
                  - [ ] Contact the media<br />
                </td>
              </tr>
              <tr>
                <td>Emoji</td>
                <td>That is so funny! :joy:</td>
              </tr>
              <tr>
                <td>Highlight</td>
                <td>I need to highlight these ==very important words==.</td>
              </tr>
              <tr>
                <td>Subscript</td>
                <td>H~2~O</td>
              </tr>
              <tr>
                <td>Superscript</td>
                <td>X^2^</td>
              </tr>
            </tbody>
          </table>
        </details>
        <details> 
          <summary>HTML</summary>
          <pre><code>< div>
  < p> Привет, мир! </ p>
</ div></code></pre>
          <p>HTML позволяет делать валидацию с помощью атрибутов required, pattern и т.д.</p>
          <table>
            <caption>Структура</caption>
            <thead>
              <tr>
                <th>тэг</th>
                <th>назначение</th>
                <th>блочный</th>
                <th>семантика</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>!DOCTYPE</td>
                <td>тип документа</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>html</td>
                <td>корень HTML-документа</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>head</td>
                <td>содержит метаданные/информацию для документа</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>title</td>
                <td>название сайта, которое отображается во вкладке</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>body</td>
                <td>тело документа</td>
                <td>блочный</td>
                <td> </td>
              </tr>
              <tr>
                <td>header</td>
                <td>заголовок документа или раздела</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>nav</td>
                <td>навигационные ссылки</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>main</td>
                <td>основное содержимое документа</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>section</td>
                <td>раздел в документе</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>aside</td>
                <td>боковая панель сайта, второстепенный контент</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>div</td>
                <td>контейнер</td>
                <td>блочный</td>
                <td> </td>
              </tr>
              <tr>
                <td>footer</td>
                <td>нижний колонтитул документа или раздела</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Текст</caption>
            <thead>
              <tr>
                <th>тэг</th>
                <th>назначение</th>
                <th>блочный</th>
                <th>семантика</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>article</td>
                <td>группировка связанных элементов в независимый объект</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>hgroup</td>
                <td>заголовок и связанный контент</td>
                <td>блочный</td>
                <td> </td>
              </tr>
              <tr>
                <td>abbr</td>
                <td>title="расшифровка" - аббревиатура или акроним</td>
                <td>строчный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>address</td>
                <td>вывод контактной информации</td>
                <td>строчный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>b</td>
                <td>жирный текст</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>strong</td>
                <td>текст большой важности</td>
                <td>строчный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>u</td>
                <td>подчеркнутый текст</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>small</td>
                <td>меньший текст</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>sub</td>
                <td>подстрочный текст</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>sup</td>
                <td>надстрочный текст</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>span</td>
                <td>часть текста в строке</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>bdi</td>
                <td>изолирует часть текста</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>bdo</td>
                <td>dir="rtl" - переопределяет направление текста</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>blockquote</td>
                <td>cite="ссылка на источник"</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>cite</td>
                <td>название произведения, автор цитаты</td>
                <td>строчный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>q</td>
                <td>короткая цитата</td>
                <td>строчный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>time</td>
                <td>вывод даты и времени</td>
                <td>строчный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>br</td>
                <td>разрыв строки</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>code</td>
                <td>часть компьютерного кода</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>data</td>
                <td>value="номер продукта" - связывает номер с названием продукта</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>del</td>
                <td>перечеркнутый текст</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>dfn</td>
                <td>термин, который будет определен</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>em</td>
                <td>текст курсивом с ударением, отдельная мысль или перефразировка</td>
                <td>строчный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>i</td>
                <td>текст курсивом, отдельная мысль или иностранное слово</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>h1 - h6</td>
                <td>заголовок</td>
                <td>блочный</td>
                <td>семантика</td>
              </tr>
              <tr>
                <td>ins</td>
                <td>текст, который был вставлен</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>kbd</td>
                <td>текст, как ввод с клавиатуры</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>mark</td>
                <td>отмеченный/выделенный текст особого внимания</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>s</td>
                <td>неправильный текст </td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>samp</td>
                <td>текст как вывод компьютерной программы</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>var</td>
                <td>текст как переменная</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>wbr</td>
                <td>возможный разрыв строки</td>
                <td>строчный</td>
                <td> </td>
              </tr>
              <tr>
                <td>p</td>
                <td>параграф</td>
                <td>блочный</td>
                <td> </td>
              </tr>
              <tr>
                <td>pre</td>
                <td>предварительно отформатированный текст</td>
                <td>блочный</td>
                <td> </td>
              </tr>
              <tr>
                <td>ruby</td>
                <td>аннотация Ruby (для восточноазиатской типографики)</td>
                <td>блочный</td>
                <td> </td>
              </tr>
              <tr>
                <td>hr</td>
                <td>тематическое изменение содержания (линия)</td>
                <td>блочный</td>
                <td> </td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Вставка</caption>
            <thead>
              <tr>
                <th>тэг</th>
                <th>назначение</th>
                <th>блочный</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>script</td>
                <td>вставка JS</td>
                <td> </td>
              </tr>
              <tr>
                <td>style</td>
                <td>вставка CSS</td>
                <td> </td>
              </tr>
              <tr>
                <td>embed</td>
                <td>контейнер для внешнего приложения</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>object</td>
                <td>контейнер для внешнего приложения</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>template</td>
                <td>контейнер для скрытого при загрузке страницы контента</td>
                <td> </td>
              </tr>
              <tr>
                <td>iframe</td>
                <td>встроенный фрейм (страница в странице)</td>
                <td> </td>
              </tr>
              <tr>
                <td>noscript</td>
                <td>альтернативный контент при не поддержании JS</td>
                <td> </td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Списки</caption>
            <thead>
              <tr>
                <th>тэг</th>
                <th>назначение</th>
                <th>блочный</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>details</td>
                <td>спойлер</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>summary</td>
                <td>название спойлера</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>dl</td>
                <td>список определений</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>dt</td>
                <td>термин</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>dd</td>
                <td>значение термина</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>ol</td>
                <td>упорядоченный список</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>ul</td>
                <td>неупорядоченный список</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>menu</td>
                <td>неупорядоченный список</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>li</td>
                <td>элемент списка</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>optgroup</td>
                <td>label="" - группа связанных параметров в раскрывающемся списке</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>option</td>
                <td>value="" - значение в раскрывающемся списке</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>label</td>
                <td>for="cars" - имя раскрывающегося списка</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>select</td>
                <td>name="cars_list" id="cars"- раскрывающийся список</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>option</td>
                <td>value="" - значение в раскрывающемся списке</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>dialog</td>
                <td>диалоговое окно</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>textarea</td>
                <td>id="" name="" placeholder="" rows="" cols="" - многострочное поле</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>button</td>
                <td>кнопка</td>
                <td>блочный</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Ссылки</caption>
            <thead>
              <tr>
                <th>тэг</th>
                <th>назначение</th>
                <th>блочный</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>link</td>
                <td>связывает с документом другой документ</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>base</td>
                <td>href="..." - базовый URL-адрес для всех относительных URL-адресов в документе</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>a</td>
                <td>href="ссылка" - гиперссылка</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>a</td>
                <td>href="#" target="_blank" title="подсказка" class="" id="" style=""</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>a</td>
                <td>href="tel: phone"</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>a</td>
                <td>href="email: address"</td>
                <td>строчный</td>
              </tr>
            </tbody>
          </table>
          <pre><code>< table>
  < caption>Table name or description</ caption>
  < thead>
    < tr>
      < th>ISBN</ th>
      < th>Title</ th>
      < th>Price</ th>
    </ tr>
  </ thead>
  < colgroup>
    < col span="2" style="background-color:red">
    < col style="background-color:yellow">
  </ colgroup>
  < tbody>
    < tr>
      < td colspan="2">3476896</ td>
      < td rowspan="2">My first HTML</ td>
      < td>$53</ td>
    </ tr>
  </ tbody>
  < tfoot>
    < tr>
      < td>Sum</ td>
      < td>$180</ td>
    </ tr>
  </ tfoot>
</ table>
</code></pre>
          <table>
            <caption>Таблица</caption>
            <thead>
              <tr>
                <th>тэг</th>
                <th>назначение</th>
                <th>блочный</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>table</td>
                <td>таблица</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>caption</td>
                <td>название таблицы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>thead</td>
                <td>шапка таблицы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>tbody</td>
                <td>тело таблицы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>tr</td>
                <td>строка таблицы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>th</td>
                <td>ячейка шапки таблицы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>td</td>
                <td>ячейка тела таблицы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>tfoot</td>
                <td>подвал таблицы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>colgroup</td>
                <td>группа столбцов в таблице</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>col span="2"</td>
                <td>объединение столбцов в таблице</td>
                <td>атрибут</td>
              </tr>
              <tr>
                <td>row span="2"</td>
                <td>объединение строк в таблице</td>
                <td>атрибут</td>
              </tr>
            </tbody>
          </table>
          <pre><code>< form> action="/action_page.php" method="POST"
  < label for="input_id">Название инпута:</ label>
  < input type="text" id="input_id" name="input_name" value="" tabindex="" />
  < input type="submit" id="" name="" value="Надпись на кнопке" />
</ form>
</code></pre>
          <table>
            <caption>Формы</caption>
            <thead>
              <tr>
                <th>тэг</th>
                <th>назначение</th>
                <th>блочный</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>form action="" method=""</td>
                <td>отправка введенных данных, на адрес атрибута action, методом атрибута method</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>fieldset</td>
                <td>группирует элементы формы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>legend</td>
                <td>заголовок формы</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>label</td>
                <td>for="fname" - заголовок поля</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>input</td>
                <td>type="text" id="fname" name="fname" - поле ввода</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>input</td>
                <td>type="submit" value="Submit" - кнопка отправить</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td colspan="3">СПИСОК ВАРИАНТОВ</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>form action="" method=""</td>
                <td>форма с предопределённым списком вариантов для поля ввода</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>label</td>
                <td>for="browser" - заголовок поля</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>input</td>
                <td>list="browsers" name="browser" id="browser" - поле ввода</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>datalist</td>
                <td>id="browsers" - список вариантов</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>option</td>
                <td>value="Edge" - вариант ввода</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>input</td>
                <td>type="submit" - кнопка отправить</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td colspan="3">ПОИСК</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>search</td>
                <td>раздел поиска</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>form</td>
                <td>форма поиска</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>input</td>
                <td>name="" id="" placeholder="" - поле ввода поиска</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td colspan="3">ВЫЧИСЛЕНИЯ</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>form</td>
                <td>oninput="x.value=parseInt(a.value)+parseInt(b.value)" - результат расчета</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>input</td>
                <td>type="range" id="a" value="50" - ввод первого слагаемого</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>- input</td>
                <td>type="number" id="b" value="25" - ввод второго слагаемого</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>= output</td>
                <td>name="x" for="a b" - вывод суммы</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td colspan="3">МАНОМЕТР</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>label</td>
                <td>for="idname" - Заголовок манометра</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>meter</td>
                <td>id="idname" value="" - скалярное измерение в известном диапазоне (манометр)</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td colspan="3">ПРОГРЕСС</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>label</td>
                <td>for="file" - Заголовок прогресса</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td>progress</td>
                <td>id="file" value="32" max="100" - Представляет ход выполнения задачи</td>
                <td>блочный</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Медиа</caption>
            <thead> 
              <tr>
                <th>тэг</th>
                <th>назначение</th>
                <th>блочный</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>canvas</td>
                <td>id="myCanvas" - рисование графики на лету</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>svg</td>
                <td>width="" height="" - контейнер для графики SVG</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>img</td>
                <td>src="" alt="" - изображение</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td colspan="3">КАРТА</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>img</td>
                <td>src="" alt="" usemap="#workmap" - карта-изображения</td>
                <td> </td>
              </tr>
              <tr>
                <td>map</td>
                <td>name="workmap" - карта-изображения</td>
                <td> </td>
              </tr>
              <tr>
                <td>area</td>
                <td>shape="" coords="" alt="" href="" - карта-изображения</td>
                <td> </td>
              </tr>
              <tr>
                <td colspan="3">КОНТЕЙНЕР ИЗОБРАЖЕНИЙ</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>picture</td>
                <td>контейнер для нескольких вариантов ресурсов изображений</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>source</td>
                <td>media="(min-width: 650px)" srcset="img_food.jpg" - адаптив без css, ускоряет загрузку верстки</td>
                <td> </td>
              </tr>
              <tr>
                <td>source</td>
                <td>media="(min-width: 465px)" srcset="img_car.jpg"</td>
                <td> </td>
              </tr>
              <tr>
                <td>img</td>
                <td>src="img_girl.jpg" - Если браузер не поддерживает picture, то выведет img</td>
                <td>строчный</td>
              </tr>
              <tr>
                <td colspan="3">ГРУППА МЕДИА</td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>figure</td>
                <td>группировка медиа-элементов, блочный, изображение с доп.тегами</td>
                <td> </td>
              </tr>
              <tr>
                <td>img</td>
                <td>src="" - медиа-элемент</td>
                <td> </td>
              </tr>
              <tr>
                <td>figcaption</td>
                <td>заголовок медиа-элемента</td>
                <td> </td>
              </tr>
              <tr>
                <td>audio</td>
                <td>controls - встроенный аудио контент</td>
                <td> </td>
              </tr>
              <tr>
                <td>source</td>
                <td>src="horse.ogg" type="audio/ogg" - аудио контент</td>
                <td> </td>
              </tr>
              <tr>
                <td>source</td>
                <td>src="horse.mp3" type="audio/mpeg" - аудио контент</td>
                <td> </td>
              </tr>
              <tr>
                <td>track</td>
                <td>src="" kind="" srclang="" label="" - текстовые дорожки</td>
                <td> </td>
              </tr>
              <tr>
                <td colspan="либо видео"></td>
                <td> </td>
                <td> </td>
              </tr>
              <tr>
                <td>video</td>
                <td>width="" height="" controls - встроенный видео контент</td>
                <td>блочный</td>
              </tr>
              <tr>
                <td>source</td>
                <td>src="" type="" - видео контент</td>
                <td> </td>
              </tr>
              <tr>
                <td>track</td>
                <td>src="" kind="" srclang="" label="" - текстовые дорожки</td>
                <td> </td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Мета</caption>
            <thead> 
              <tr>
                <th>тэг</th>
                <th>назначение</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>< meta charset="UTF-8" /></td>
                <td>Кодировка</td>
              </tr>
              <tr>
                <td>< meta name="viewport" content="width=1170" /></td>
                <td>фиксированная ширина вся помещается в экран</td>
              </tr>
              <tr>
                <td>< meta name="viewport" content="width=device-width" /></td>
                <td>адаптивный</td>
              </tr>
              <tr>
                <td>< meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" /></td>
                <td>параметры адаптивности</td>
              </tr>
              <tr>
                <td>< meta name="format-detection" content="telephone=no" /></td>
                <td>отключает ссылку у номера телефона на iOS</td>
              </tr>
              <tr>
                <td>< meta name="description" content="описание до 140 символов" /></td>
                <td>для SEO</td>
              </tr>
              <tr>
                <td>< meta name="keywords" content="ключевые слова через запятую до 20" /></td>
                <td>ключевые слова для SEO</td>
              </tr>
              <tr>
                <td>< meta name="robots" content="noindex, nofollow" /></td>
                <td>не допуск поисковых роботов к странице</td>
              </tr>
              <tr>
                <td>< meta name="robots" content="none" /></td>
                <td></td>
              </tr>
              <tr>
                <td>< meta name="robots" content="noimageindex, nofollow" /></td>
                <td>запрет индексации картинок и ссылок</td>
              </tr>
              <tr>
                <td>< meta name="Author" content="Дарт Вейдер" /></td>
                <td>Автор страницы</td>
              </tr>
              <tr>
                <td>< meta name="Copyright" content="Люк Скайвокер" /></td>
                <td>Авторские права</td>
              </tr>
              <tr>
                <td>< meta name="Address" content="Татуин, кратер № 97" /></td>
                <td>Адрес автора</td>
              </tr>
              <tr>
                <td>< meta http-equiv="refresh" content="0"; url="" /></td>
                <td>обновляет страницу либо перенаправляет пользователя, указать количество секунд до перенаправления и адрес страницы</td>
              </tr>
              <tr>
                <td>< meta property="og:locale" content="ru_RU" /></td>
                <td>локализация для русскоязычного сайта</td>
              </tr>
              <tr>
                <td>< meta property="og:type" content="article" /></td>
                <td>тип контента статья</td>
              </tr>
              <tr>
                <td>< meta property="og:title" content="META теги" /></td>
                <td>заголовок записи в социальной сети</td>
              </tr>
              <tr>
                <td>< meta property="og:description" content="описание страницы" /></td>
                <td>описание страницы</td>
              </tr>
              <tr>
                <td>< meta property="og:image" content="http://fls.guru/meta/img/bg.jpg" /></td>
                <td>изображение для записи в соцсети</td>
              </tr>
              <tr>
                <td>< meta property="og:url" content="http://fls.guru/meta/ " /></td>
                <td>ссылка на текущую страницу</td>
              </tr>
              <tr>
                <td>< meta property="og:site_name" content="Название сайта" /></td>
                <td>Название сайта</td>
              </tr>
              <tr>
                <td>< meta name="twitter:card" content="" /></td>
                <td>тип карты твитер</td>
              </tr>
              <tr>
                <td>< meta name="twitter:site" content="Автор" /></td>
                <td>имя/логин автора</td>
              </tr>
              <tr>
                <td>< meta name="twitter:title" content="META теги" /></td>
                <td>название страницы</td>
              </tr>
              <tr>
                <td>< meta name="twitter:description" content="описание страницы" /></td>
                <td>описание страницы</td>
              </tr>
              <tr>
                <td>< meta name="twitter:image" content="http://fls.guru/meta/img/bg.jpg" /></td>
                <td>изображение для записи в соцсети</td>
              </tr>
            </tbody>
          </table>
        </details>
        <details> 
          <summary>Pug</summary>
          <pre><code>#!/bin/bash
npm install -g pug pug-cli sass typescript terser

// dev
sass -w --no-source-map ./src/style.scss:./public/style.css & tsc -w & pug -w ./src/*.pug -o ./public -P & cp -r ./src/assets ./public/assets

// build
sass --no-source-map --style=compressed ./src/style.scss:./dist/style.css & terser ./public/*.js -o ./dist/main.js & pug ./src/*.pug -o ./dist
</code></pre>
          <ul>
            <li><a href="https://pugjs.org/">Официальная документация Pug</a>
            </li>
          </ul>
          <p>Pug - это препроцессор HTML и шаблонизатор, который был написан на JavaScript для Node.js.  </p>
          <table>
            <caption>pug -w . -o ./ -P -E php</caption>
            <tbody> 
              <tr>
                <td>pug</td>
                <td>компилировать файлы с расширением .pug</td>
              </tr>
              <tr>
                <td>-w</td>
                <td>watcher - следить за изменениями в файлах</td>
              </tr>
              <tr>
                <td>.</td>
                <td>текущий каталог (каталог слежения)</td>
              </tr>
              <tr>
                <td>-o</td>
                <td>output - вывод скомпилированных файлов</td>
              </tr>
              <tr>
                <td>./</td>
                <td>каталог вывода</td>
              </tr>
              <tr>
                <td>-P</td>
                <td>pretty - удобочитаемый вид</td>
              </tr>
              <tr>
                <td>-E php</td>
                <td>компилировать с расширением php</td>
              </tr>
            </tbody>
          </table>
          <p>В Pug нет закрывающих тегов, вместо этого он использует строгую табуляцию (отступы) для определения вложенности тегов. Для закрытия тегов в конце необходимо добавить символ `/`: `foo(bar='baz')/`</p>
          <pre><code>ul
  li Item A
  li Item B
  li Item C
</code></pre>
          <p>Теги внутри строки</p>
          <pre><code>p This is plain < span>old</ span> text content.</code></pre>
          <table>
            <caption>Комментарии</caption>
            <tbody>
              <tr>
                <td>//-</td>
                <td>не отобразится после компиляции, многострочный комментарий</td>
              </tr>
              <tr>
                <td>//</td>
                <td>отобразится после компиляции, многострочный комментарий</td>
              </tr>
            </tbody>
          </table>
          <p>Перенос текста на несколько строк</p>
          <pre><code>| The
| multiline
| text

// либо
p.
  The
  multiline
  text
</code></pre>
          <p>Синтаксис</p>
          <pre><code>a(class='button' href='google.com') Google

input(type='checkbox' name='agreement' checked)

- var url = 'pug-test.html';
a(href='/' + url) Link

- url = 'https://example.com/'
a(href=url) Another link

- var classes = ['foo', 'bar', 'baz']
a(class=classes)

a.bang(class=classes class=['bing']) - объединение классов
</code></pre>
          <p>Многострочный ассоциативный массив</p>
          <pre><code>-
  var priceItem = [
    {include: filterInc, parameter : "Розовый фильтр"},
    {include: smileInc, parameter : "Смайлики"},
    {include: commentInc, parameter : "Комментарии"}
  ]
</code></pre>
          <p>Условия</p>
          <pre><code>- var user = { description: 'foo bar baz' }
- var authorized = false
            
// user
if user.description
  h2.green Description
  p.description= user.description
else if authorized
  h2.blue Description
  p.description.
  User has no description,
  why not add one...
else
  h2.red Description
  p.description User has no description

- var authenticated = true
body(class=authenticated ? 'authed' : 'anon')
</code></pre>
          <p>Конструкция Switch Case</p>
          <pre><code>- var friends = 10
case friends
  when 0
  p you have no friends
  when 1
  p you have a friend
  default
  p you have # {friends} friends
</code></pre>
          <p>Циклы</p>
          <pre><code>ul                                            
  each val, index in ['zero', 'one', 'two']
  li= index + ': ' + val

- var values = [];
ul
  each val in values
  li= val
  else
  li There are no values

- var n = 0;
ul
  while n < 4
  li= n++
</code></pre>
          <p>Вставка JavaScript</p>
          <pre><code>не буферизированный код начинается с символа `-`
- for (var x = 0; x < 3; x++)
  li item

буферизированный код начинается с символа `=`

- let firstName = "Bob"
p= firstName
- let lastName = "Joe"
.full-name= firstName + " " + lastName
.full-name= `First name: ${firstName} Last name: ${lastName}`

- const names = ['Bob Joe', 'John Doe', 'Billy Bob', 'John Week']
ol
  each name in names
  li= name

-
  const friendsList = [
    {
      "firstName":"Bob",
      "lastName":"Joe",
      "mobile":"123456789"
    },
    {
      "firstName":"John",
      "lastName":"Doe",
      "mobile":"123456789"
    },
    {
      "firstName":"Billy",
      "lastName":"Bob",
      "mobile":"123456789"
    }
  ]

// friendsList
  each friend in friendsList
  .friend
    .first-name= friend.firstName
    .last-name= friend.lastName
    .mobile= friend.mobile

-
  const friendsList2 = []

// friendsList2
  each friend in friendsList
  .friend
    .first-name # {friend.firstName}
    .last-name # {friend.lastName}
    .mobile # {friend.mobile}
  else
  .oh-no You have no friends!

mixin friendCard(friend)
  .friend
  .first-name # {friend.firstName}
  .last-name # {friend.lastName}
  .mobile # {friend.mobile}

// friends
  each friend in friendsList
    +friendCard(friend)
</code></pre>
          <p>PHP, вывод данных полученных из формы, код вместе с html в php файле.</p>
          <pre><code>.friend.
  < ? php
    echo $_POST['username'];
    echo "br";
    echo $_POST['username'];
    echo "br";
    echo $_POST['username'];
  ? >

.friend. - точка вначале обозначает класс (friend), точка в конце означает, что далее многостраничный текст
</code></pre>
          <p>Интерполяция переменных</p>
          <pre><code>- var title = "On Dogs: Man's Best Friend";
- var author = "Elnora";
- var theGreat = "< span>escape!</ span>";
h1= title
p Written with love by # {author}
p This will be safe: ! {theGreat}
</code></pre>
          <p>Инклюды (Includes) - вставки содержимого одного файла в другой файл Pug.</p>
          <pre><code>doctype html - Тип документа
html
  head
  style
    include style.css
  body
  h1 My Site
  p Welcome to my super lame site.
  script
    include script.js
</code></pre>
          <p>Наследование шаблонов - дочерний шаблон наследует extends родительский шаблон: блок дочернего шаблона заменит блок родительского с тем же именем</p>
          <pre><code>// layout.pug
html
  head
  title My Site
  block scripts
    script(src='/jquery.js')
  body
  block content
  block foot
    #footer
    p some footer content

// home.pug
extends templates/layout
- var title = 'Animals'
- var pets = ['cat', 'dog']
block content
  h1= title // or h1 # {title}
  each petName in pets
  p= petName // or p # {petName}
</code></pre>
          <p>Миксины - позволяет создавать переиспользуемые блоки.</p>
          <pre><code>// Declaration
mixin pet(name)
  li.pet= name

// use
ul
  +pet('cat')
  +pet('dog')
  +pet('pig')

mixin article(title)
  .article
  .article-wrapper
    h1= title
    if block
      block
    else
      p No content provided
+article('Hello world')
+article('Hello world')
  p This is my
  p Amazing article

mixin link(href, name)
  attributes == {class: "btn"}
    a(class!=attributes.class href=href)= name

+link('/foo', 'foo')(class="btn")
</code></pre>
        </details>
        <details> 
          <summary>CSS</summary>
          <p>
            Стилем или CSS (Cascading Style Sheets, каскадные таблицы стилей) - называется набор параметров форматирования, который применяется к элементам документа, чтобы изменить их внешний вид.<br />
            
          </p>
          <p>Достоинства:</p>
          <ul>
            <li>Разграничение кода и оформления.</li>
            <li>Разное оформление для разных устройств.</li>
            <li>Расширенные по сравнению с HTML способы оформления элементов.</li>
            <li>Ускорение загрузки сайта.</li>
            <li>Единое стилевое оформление множества документов.</li>
          </ul>
          <pre><code>// внутренние стили, приоритет максимальный
< h1 style="color: red;">

глобальные стили
< style>
  h1 {color: red;}
</ style>

// сбросить css браузера
< link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.css" />

// связанные стили
< link rel="stylesheet" href="путь/к файлу/CSS" />
</code></pre>
          <ul>
            <li><a href="https://ru.bem.info">БЭМ</a>
            </li>
            <li><a href="https://www.w3.org/TR/cssom-1/">CSSOM</a>
            </li>
          </ul>
          <ul>
            <li>Блок - часть кода, которая повторяется или может повторяться самостоятельно.</li>
            <li>Элемент - это часть блока: блок__элемент.</li>
            <li>Модификатор - дополняет или уточняет стиль блока или элемента: блок__элемент_модификатор.</li>
            <li>Микс - позволяет использовать блоки и элементы в одном объекте.</li>
          </ul>
          <p>Шрифты подключаем любо в html тегом link либо в scss через @import</p>
          <h2>Селекторы</h2>
          <pre><code>селектор {
  свойство: значение;
}</code></pre>
          <ul>
            <li>Базовые: #id, .class, tag.</li>
            <li>Иерархические: +, &gt;, ~.</li>
            <li>Атрибутные: [atribute].</li>
            <li>Псевдоклассы: :hover, :visited и т.д. - при действии.</li>
            <li>Псевдоэлементы: ::after, ::before - добавляем элемент до или после выбранного.</li>
          </ul>
          <table> 
            <thead> 
              <tr>
                <th>селектор</th>
                <th>назначение</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>@import "имя файла";</td>
                <td>импорт файлов</td>
              </tr>
              <tr>
                <td>tag</td>
                <td>имя тэга</td>
              </tr>
              <tr>
                <td>.class</td>
                <td>CSS-класс</td>
              </tr>
              <tr>
                <td>#id</td>
                <td>ID тэга</td>
              </tr>
              <tr>
                <td>name = value</td>
                <td>атрибут тэга</td>
              </tr>
              <tr>
                <td>:filter</td>
                <td>фильтр (псевдокласс)</td>
              </tr>
              <tr>
                <td>*</td>
                <td>все элементы на странице</td>
              </tr>
              <tr>
                <td>sel, sel, sel</td>
                <td>выбор элементов по одному из перечисленных селекторов</td>
              </tr>
              <tr>
                <td>sel sel</td>
                <td>всех потомков</td>
              </tr>
              <tr>
                <td>sel > sel</td>
                <td>только прямых потомков</td>
              </tr>
              <tr>
                <td>sel + sel</td>
                <td>следующий сосед этого же уровня</td>
              </tr>
              <tr>
                <td>sel ~ sel</td>
                <td>всех следующих соседей этого же уровня</td>
              </tr>
              <tr>
                <td>div.text {}</td>
                <td>применить css-свойство к тегу div с классом text</td>
              </tr>
              <tr>
                <td>.block.text {}</td>
                <td>применить к тегам, содержащим оба класса</td>
              </tr>
              <tr>
                <td>[title="first"]</td>
                <td>атрибут title равен first</td>
              </tr>
              <tr>
                <td>[title~="first"]</td>
                <td>атрибут title содержит слово first</td>
              </tr>
              <tr>
                <td>[class*="__container"] {}</td>
                <td>применить css-свойство ко всем элементам, у кого атрибут class содержит "__container"</td>
              </tr>
              <tr>
                <td colspan="2">Псевдокласс - это модификатор селектора</td>
                <td> </td>
              </tr>
              <tr>
                <td>.block:hover</td>
                <td>псевдоклассы состояния: hover, active, target, focus, visited</td>
              </tr>
              <tr>
                <td>:hover</td>
                <td>срабатывает при наведении</td>
              </tr>
              <tr>
                <td>:visited</td>
                <td>срабатывает для посещенных ссылок</td>
              </tr>
              <tr>
                <td>:active</td>
                <td>срабатывает при нажатии на элемент</td>
              </tr>
              <tr>
                <td>:focus</td>
                <td>срабатывает при получении элементом фокуса</td>
              </tr>
              <tr>
                <td>.block:first-child</td>
                <td>псевдоклассы навигации: first child, last child, first off type, last off type, not</td>
              </tr>
              <tr>
                <td>:first-child {}</td>
                <td>первый ребенок</td>
              </tr>
              <tr>
                <td>:last-child {}</td>
                <td>последний ребенок</td>
              </tr>
              <tr>
                <td>:nth-child(2) {}</td>
                <td>второй ребенок</td>
              </tr>
              <tr>
                <td>:nth-child(2n) {}</td>
                <td>каждый второй ребенок</td>
              </tr>
              <tr>
                <td>:nth-child(even) {}</td>
                <td>чётные</td>
              </tr>
              <tr>
                <td>:nth-child(add) {}</td>
                <td>нечётные</td>
              </tr>
              <tr>
                <td colspan="2">Псевдоэлемент - модификатор содержимого элемента</td>
                <td> </td>
              </tr>
              <tr>
                <td>.block::after</td>
                <td>псевдоэлементы: before, after</td>
              </tr>
              <tr>
                <td>::first-line{}</td>
                <td>задает стиль первой строки текста</td>
              </tr>
              <tr>
                <td>::first-letter{}</td>
                <td>задает стиль первого символа</td>
              </tr>
              <tr>
                <td>::before</td>
                <td>отобразить content:''; перед элементом, к которому применяется</td>
              </tr>
              <tr>
                <td>::after</td>
                <td>отобразить content:''; после элемента, к которому применяется</td>
              </tr>
            </tbody>
          </table>
          <pre><code>.text:hover::before{} либо .text::first-line{}</code></pre>
          <h2>Единицы измерения</h2>
          <p>px (пиксель) - абсолютная единица измерения, все остальные единицы измерения пересчитываются браузером в пиксели.</p>
          <table> 
            <caption>Относительные единицы измерения</caption>
            <thead> 
              <tr>
                <th>единица</th>
                <th>назначение</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>em</td>
                <td>равен размеру шрифта текущего объекта: для медиа-запросов и привязки к текущему размеру шрифта</td>
              </tr>
              <tr>
                <td>rem</td>
                <td>равен размеру шрифта в теге html, а если там нет, то браузера по умолчанию (16px)</td>
              </tr>
              <tr>
                <td>%</td>
                <td>разные свойства css вычисляют % от разных оснований: для отзывчивых конструкций, позиционирования и скрола</td>
              </tr>
              <tr>
                <td>vw, vh, vmin, vmax</td>
                <td>работают относительно окна браузера (viewport): для полноэкранных блоков и scss вычислений</td>
              </tr>
              <tr>
                <td>fr</td>
                <td>единица измерения в модуле grid</td>
              </tr>
              <tr>
                <td>ex</td>
                <td>единица измерения относительно размера прописной "е"</td>
              </tr>
              <tr>
                <td>ch</td>
                <td>единица измерения относительно размера 0</td>
              </tr>
            </tbody>
          </table>
          <table> 
            <caption>Свойства</caption>
            <thead> 
              <tr>
                <th>свойство</th>
                <th>назначение</th>
              </tr>
              <tr>
                <th colspan="2">Текст</th>
                <th> </th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>font-family</td>
                <td>семейство шрифта</td>
              </tr>
              <tr>
                <td>font-size</td>
                <td>размер шрифта элемента</td>
              </tr>
              <tr>
                <td>font-style</td>
                <td>начертание шрифта (курсив, наклон и нормальный)</td>
              </tr>
              <tr>
                <td>font-weight</td>
                <td>насыщенность (вес) шрифта</td>
              </tr>
              <tr>
                <td>color</td>
                <td>цвет текста</td>
              </tr>
              <tr>
                <td>text-align</td>
                <td>горизонтальное выравнивание текста</td>
              </tr>
              <tr>
                <td>text-decoration</td>
                <td>оформление текста (подчеркивание, перечеркивание и т.д.)</td>
              </tr>
              <tr>
                <td>text-shadow</td>
                <td>добавляет тень к тексту</td>
              </tr>
              <tr>
                <td>text-transform</td>
                <td>преобразование заглавных и прописных символов</td>
              </tr>
              <tr>
                <td>text-ident</td>
                <td>отступ первой строки от края блока</td>
              </tr>
              <tr>
                <td>letter-spacing</td>
                <td>определяет интервал между символами</td>
              </tr>
              <tr>
                <td>word-spacing</td>
                <td>определяет интервал между словами</td>
              </tr>
              <tr>
                <td>white-space</td>
                <td>управляет свойствами пробелов между словами</td>
              </tr>
              <tr>
                <td>line-height</td>
                <td>устанавливает межстрочный интервал текста</td>
              </tr>
              <tr>
                <td colspan="2">Геометрия</td>
                <td> </td>
              </tr>
              <tr>
                <td>padding</td>
                <td>внутренний отступ блочных тегов</td>
              </tr>
              <tr>
                <td>margin</td>
                <td>внешний отступ блочных тегов</td>
              </tr>
              <tr>
                <td>width</td>
                <td>ширина блочных тегов</td>
              </tr>
              <tr>
                <td>max-width</td>
                <td>устанавливает максимальную ширину блочных тегов</td>
              </tr>
              <tr>
                <td>min-width</td>
                <td>устанавливает минимальную ширину блочных тегов</td>
              </tr>
              <tr>
                <td>height</td>
                <td>устанавливает высоту блочных тегов</td>
              </tr>
              <tr>
                <td>max-height</td>
                <td>устанавливает максимальную высоту блочных тегов</td>
              </tr>
              <tr>
                <td>min-height</td>
                <td>устанавливает минимальную высоту блочных тегов</td>
              </tr>
              <tr>
                <td colspan="2">Отображение</td>
                <td> </td>
              </tr>
              <tr>
                <td>overflow</td>
                <td>управляет отображением содержания блочного элемента</td>
              </tr>
              <tr>
                <td>display</td>
                <td>определяет как элемент должен быть показан в документе</td>
              </tr>
              <tr>
                <td>border</td>
                <td>граница блока</td>
              </tr>
              <tr>
                <td>border-radius</td>
                <td>устанавливает радиус скругления уголков блока</td>
              </tr>
              <tr>
                <td>outline</td>
                <td>внешняя граница блока</td>
              </tr>
              <tr>
                <td>box-shadow</td>
                <td>добавляет тень к блоку</td>
              </tr>
              <tr>
                <td>opacity</td>
                <td>определяет уровень прозрачности элемента</td>
              </tr>
              <tr>
                <td>visibility</td>
                <td>отображение или скрытие блока</td>
              </tr>
              <tr>
                <td>background</td>
                <td>управляет фоном элемента</td>
              </tr>
              <tr>
                <td>background-color</td>
                <td>цвет фона элемента</td>
              </tr>
              <tr>
                <td>background-image</td>
                <td>фоновое изображение или градиентная заливка</td>
              </tr>
              <tr>
                <td>background-repeat</td>
                <td>повторение фонового изображения</td>
              </tr>
              <tr>
                <td>background-position</td>
                <td>положение фонового изображения</td>
              </tr>
              <tr>
                <td>background-attachment</td>
                <td>прокручивание фона вместе с содержимым элемента</td>
              </tr>
              <tr>
                <td>background-size</td>
                <td>размеры фонового изображения</td>
              </tr>
              <tr>
                <td>background</td>
                <td>позволяет задать несколько фоновых изображений одному блоку</td>
              </tr>
              <tr>
                <td>background-origin и background-clip</td>
                <td>отвечают за показ фона вместе с границей border</td>
              </tr>
              <tr>
                <td colspan="2">Позиционирование</td>
                <td> </td>
              </tr>
              <tr>
                <td colspan="2">Для расположения друг относительно друга у одного должно быть relative у другого absolute</td>
                <td> </td>
              </tr>
              <tr>
                <td>z-index</td>
                <td>управляет наложением элементов</td>
              </tr>
              <tr>
                <td>position</td>
                <td>позиционирование элемента относительно других элементов или окна браузера</td>
              </tr>
              <tr>
                <td>position: static</td>
                <td>по умолчанию у всех блоков</td>
              </tr>
              <tr>
                <td>position: relative</td>
                <td>положение относительно изначального места в коде: left, top, right, bottom</td>
              </tr>
              <tr>
                <td>position: absolute</td>
                <td>утрачивает связь с местом в коде и свойствами тега: left, top, right, bottom</td>
              </tr>
              <tr>
                <td>position: fixed</td>
                <td>фиксирует элемент относительно окна браузера не завися от relative и прокрутки: left, top, right, bottom</td>
              </tr>
              <tr>
                <td>position: sticky</td>
                <td>переводит элемент из static в fixed при достижении элементом указанной позиции: left, top, right, bottom</td>
              </tr>
              <tr>
                <td colspan="2">Трансформ - применяется только к блочным объектам</td>
                <td> </td>
              </tr>
              <tr>
                <td>transform: translate(0px, 0px)</td>
                <td>translate сдвигает элемент на новое место</td>
              </tr>
              <tr>
                <td>transform: scale(1, 1)</td>
                <td>масштабирует изображения, при отрицательном значении зеркалит</td>
              </tr>
              <tr>
                <td>transform: rotate(0deg)</td>
                <td>поворачивает элемент по часовой, отрицательное - против часовой</td>
              </tr>
              <tr>
                <td>transform: skew(0deg, 0deg)</td>
                <td>деформирует стороны объекта по вертикали и горизонтали</td>
              </tr>
              <tr>
                <td>transform: matrix(a, b, c, d, e)</td>
                <td>позволяет объединить трансформации, без единиц измерения</td>
              </tr>
              <tr>
                <td>transform: translate(0px, 0px) scale(1, 1) rotate(0deg)</td>
                <td></td>
              </tr>
              <tr>
                <td>transform-origin: center</td>
                <td>смещает центр трансформации</td>
              </tr>
              <tr>
                <td>perspective: 0px</td>
                <td>установка глубины перспективы</td>
              </tr>
              <tr>
                <td>perspective-origin: center</td>
                <td>смена точки начала координат</td>
              </tr>
              <tr>
                <td>transform: translate3d(0px, 0px, 0px)</td>
                <td></td>
              </tr>
              <tr>
                <td>transform: scale3d(1, 1, 1)</td>
                <td></td>
              </tr>
              <tr>
                <td>transform: rotate3d(x, y, z, deg)</td>
                <td></td>
              </tr>
              <tr>
                <td>transform: matrix3d(n, n, n, n, n, n, n, n, n, n, n, n, n, n)</td>
                <td>16 значений</td>
              </tr>
              <tr>
                <td>transform: translate3d(0px, 0px, 0px) rotate3d(1, 1, 1, 0deg)</td>
                <td></td>
              </tr>
              <tr>
                <td>transform-style: flat</td>
                <td>задает стиль трансформации</td>
              </tr>
              <tr>
                <td>backface-visibility: visible</td>
                <td>показывает обратную сторону объекта</td>
              </tr>
              <tr>
                <td colspan="2">Flex</td>
                <td> </td>
              </tr>
              <tr>
                <td>display: flex;</td>
                <td>включает флекс разметку</td>
              </tr>
              <tr>
                <td>display: inline-flex;</td>
                <td>строчный флекс-контейнер</td>
              </tr>
              <tr>
                <td>justify-content</td>
                <td>определяет выравнивание вдоль основной оси</td>
              </tr>
              <tr>
                <td>justify-content: flex-start;</td>
                <td>элементы слева</td>
              </tr>
              <tr>
                <td>justify-content: flx-end;</td>
                <td>элементы справа</td>
              </tr>
              <tr>
                <td>justify-content: center;</td>
                <td>элементы в центре</td>
              </tr>
              <tr>
                <td>justify-content: space-between;</td>
                <td>пространство между элементами</td>
              </tr>
              <tr>
                <td>justify-content: space-around; </td>
                <td>пространство вокруг элементов</td>
              </tr>
              <tr>
                <td colspan="2">ДЛЯ ФЛЕКС-КОНТЕЙНЕРА</td>
                <td></td>
              </tr>
              <tr>
                <td>align-items</td>
                <td>определяет поведение вдоль перекрёстной оси</td>
              </tr>
              <tr>
                <td>align-items: stretch;</td>
                <td>элементы подстраиваются под самый высокий</td>
              </tr>
              <tr>
                <td>align-items: flex-start;</td>
                <td>высота флекс-элемента от верха на высоту контента</td>
              </tr>
              <tr>
                <td>align-items: flex-end;</td>
                <td>высота флекс-элемента от низа на высоту контента</td>
              </tr>
              <tr>
                <td>align-items: center;</td>
                <td>флекс-элементы выстроятся по горизонтальному центру самого высокого элемента</td>
              </tr>
              <tr>
                <td>align-items: baseline;</td>
                <td>выстраивает флекс-элементы по базовой линии</td>
              </tr>
              <tr>
                <td>flex-wrap: nowrap;</td>
                <td>флекс-элементы не адаптируются</td>
              </tr>
              <tr>
                <td>flex-wrap: wrap;</td>
                <td>флекс-элементы адаптируются</td>
              </tr>
              <tr>
                <td>flex-wrap: wrap-reverse;</td>
                <td>флекс-элементы адаптируются в обратном порядке</td>
              </tr>
              <tr>
                <td colspan="2">ДЛЯ ФЛЕКС-ЭЛЕМЕНТА</td>
                <td> </td>
              </tr>
              <tr>
                <td>align-self</td>
                <td>переопределяет выравнивание</td>
              </tr>
              <tr>
                <td>align-self: stretch;</td>
                <td></td>
              </tr>
              <tr>
                <td>align-self: center;</td>
                <td></td>
              </tr>
              <tr>
                <td>align-self: flex-start;</td>
                <td></td>
              </tr>
              <tr>
                <td>align-self: flex-end;</td>
                <td></td>
              </tr>
              <tr>
                <td>order</td>
                <td>порядок вывода элементов</td>
              </tr>
              <tr>
                <td>order: 1;</td>
                <td>выводим первым</td>
              </tr>
              <tr>
                <td>flex-basis</td>
                <td>базовый размер элемента</td>
              </tr>
              <tr>
                <td>flex-basis: auto;</td>
                <td>по размеру контента</td>
              </tr>
              <tr>
                <td>flex-grow</td>
                <td>возможность увеличиваться в размере</td>
              </tr>
              <tr>
                <td>flex-grow: 0;</td>
                <td>не больше чем flex-basis</td>
              </tr>
              <tr>
                <td>flex-shrink</td>
                <td>возможность уменьшаться в размере</td>
              </tr>
              <tr>
                <td>flex-shrink: 1;</td>
                <td>разрешено становиться меньше</td>
              </tr>
              <tr>
                <td>flex: 0 1 auto;</td>
                <td>короткая запись flex-grow flex-shrink flex-basis</td>
              </tr>
              <tr>
                <td>flex-direction</td>
                <td>устанавливает основную ось</td>
              </tr>
              <tr>
                <td>flex-direction: row;</td>
                <td>в ряд</td>
              </tr>
              <tr>
                <td>flex-direction: row-reverse;</td>
                <td>в обратную сторону в обратном порядке</td>
              </tr>
              <tr>
                <td>flex-direction: column;</td>
                <td>основная ось вертикально</td>
              </tr>
              <tr>
                <td>flex-direction: column-revers;</td>
                <td>вертикально снизу вверх</td>
              </tr>
              <tr>
                <td colspan="2">GRID</td>
                <td></td>
              </tr>
              <tr>
                <td>display: grid;</td>
                <td>определяет блочный грид-контейнер</td>
              </tr>
              <tr>
                <td>display: inline-grid;</td>
                <td>определяет строчный грид-контейнер</td>
              </tr>
              <tr>
                <td>grid-template-rows: ;</td>
                <td>управление рядами</td>
              </tr>
              <tr>
                <td>grid-template-rows: 1fr 1fr;</td>
                <td>два ряда делят высоту грид-контейнера поровну</td>
              </tr>
              <tr>
                <td>grid-template-columns: ;</td>
                <td>управление колонками</td>
              </tr>
              <tr>
                <td>grid-template-columns: 200px minmax(150px, 1fr) 200px;</td>
                <td>первая колонка 200рх, вторая - от 150рх и на всю ширину, третья - 200рх</td>
              </tr>
              <tr>
                <td>grid-template-columns: fit-content(400px) 1fr auto;</td>
                <td>первая колонка по контенту до 400рх, вторая - на всю ширину, третья - по контенту</td>
              </tr>
              <tr>
                <td>grid-template-columns: repeat(3, 1fr);</td>
                <td>3 колонки размером 1fr</td>
              </tr>
              <tr>
                <td>grid-template-areas: ;</td>
                <td>управляет областями</td>
              </tr>
              <tr>
                <td>grid-template: repeat(2, 1fr) / repeat(3, 1fr);</td>
                <td>две равные строки и три равные колонки</td>
              </tr>
              <tr>
                <td>grid-area: ;</td>
                <td>применяется к элементам</td>
              </tr>
              <tr>
                <td>grid-auto-rows: ;</td>
                <td>управляет рядом неявной сетки, т.е. ряд, который не обозначен в grid-template-rows</td>
              </tr>
              <tr>
                <td>grid-auto-columns: ;</td>
                <td>если не задан grid-template-columns</td>
              </tr>
              <tr>
                <td>grid-auto-flow: row;</td>
                <td>выстраивает грид-элементы поочередно в ряд</td>
              </tr>
              <tr>
                <td>grid-auto-flow: column;</td>
                <td>выстраивает грид-элементы поочередно в колонку</td>
              </tr>
              <tr>
                <td>grid-auto-flow: dense;</td>
                <td>выстраивает грид-элементы в произвольном порядке</td>
              </tr>
            </tbody>
          </table>
          <pre><code>/* присваиваем имена элементам */
.container > header {
  grid-area: header;
}
.container > menu {
  grid-area: menu;
}
.container > content {
  grid-area: content;
}
.container > footer {
  grid-area: footer;
}
.container {

  /* включить сетку */
  display: grid;

  /* расположить зоны в два столбца и три строчки */
  grid-template-areas:

    /* в первом ряду header занимает две колонки */
    "header header"

    /* второй ряд содержит колонки menu и content */
    "menu content"
    "footer footer";

  /* соотношение ширины столбцов */
  grid-template-columns: 1fr 3fr;

  /* расстояние между столбцами и строками */
  gap: 5px;
}
.container {
  display: grid;
  grid-template:
    [start] "header header" 100px [row2]

    /* высота рядов 1fr, ширина колонок 150px 1fr */
    [row2]  "side content" 1fr [row-end] / 150px 1fr;
}
</code></pre>
          <table>
            <caption>Размещение элементов с помощью линий сетки</caption>
            <thead> 
              <tr>
                <th>свойство</th>
                <th>назначение</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>grid-row-start: auto;</td>
                <td></td>
              </tr>
              <tr>
                <td>grid-row-end: auto;</td>
                <td></td>
              </tr>
              <tr>
                <td>grid-column-start: auto;</td>
                <td></td>
              </tr>
              <tr>
                <td>grid-column-end: auto;</td>
                <td></td>
              </tr>
              <tr>
                <td>grid-row-start: span 2;</td>
                <td>объект занимает 2 строчки</td>
              </tr>
              <tr>
                <td>grid-template-rows: [start] 1fr [row2] 1fr [row-end];</td>
                <td>две строки одинаковой высоты и [имена линий] между строк сверху вниз</td>
              </tr>
              <tr>
                <td>grid-template-columns: [start] 1fr [col2] 1fr [col3] 1fr [col-end];</td>
                <td>три столбца одинаковой ширины и [имена линий] меду столбцами слева направо</td>
              </tr>
              <tr>
                <td>grid-row: 1 / 2;</td>
                <td>на элементе указывает начало и конец элемента по линиям рядов</td>
              </tr>
              <tr>
                <td>grid-column: 1 / 2;</td>
                <td>на элементе указывает начало и конец элемента по линиям столбцов</td>
              </tr>
              <tr>
                <td>grid-row: start / row2;</td>
                <td>на элементе указывает начало и конец элемента по линиям рядов</td>
              </tr>
              <tr>
                <td>grid-column: start / col2;</td>
                <td>на элементе указывает начало и конец элемента по линиям столбцов</td>
              </tr>
              <tr>
                <td>order: 1;</td>
                <td>задается каждому элементу сетки и определяет порядок вывода элемента</td>
              </tr>
              <tr>
                <td>justify-items: stretch;</td>
                <td>растягивает/прижимает элементы в ячейках вправо/влево</td>
              </tr>
              <tr>
                <td>align-items: stretch;</td>
                <td>растягивает/прижимает элементы в ячейках вверх/вниз</td>
              </tr>
              <tr>
                <td>row-gap: 20px;</td>
                <td>расстояние между строками</td>
              </tr>
              <tr>
                <td>column-gap: 20px;</td>
                <td>расстояние между колонками</td>
              </tr>
              <tr>
                <td>gap: 20px;</td>
                <td>и для строк и для колонок одновременно</td>
              </tr>
            </tbody>
          </table>
          <h2>Адаптивная и отзывчивая верстка</h2>
          <ul>
            <li>Отзывчивая - всё в %, указываем только максимальную ширину для body, весь контент на своём месте, отзывается на изменение ширины экрана.</li>
            <li>Адаптивная - брейкпоинты, медиа-запросы, контент перестраивается на брейкпоинтах при изменении ширины экрана.</li>
            <li>Отзывчиво-адаптивная - делаем отзывчивую пока читается контент при уменьшении ширины экрана.</li>
            <li>При ширине плохо читабельного контента далем брейкпоинт - адаптив.</li>
          </ul>
          <pre><code>< meta name="viewport" content="width=device-width" /></code></pre>
          <h2>Брейкпоинт</h2>
          <pre><code>@media (max-width:1200px){
  .container{
    max-width: 970px;
  }
}

@media (max-width:992px){
  .container{
    max-width: 750px;
  }
}

@media (max-width:767px){
  .container{
    max-width: none;
  }
}

// Файл стилей подключится только при выполнении условия медиа-запроса
// медиа-запрос в css
@import url(color.css) screen and (color);

// медиа-запрос в html
link rel="stylesheet" media="screen and (color)" href="example.css"
</code></pre>
          <h2>Animation</h2>
          <table>
            <thead> 
              <tr>
                <th>свойство</th>
                <th>назначение</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>animation-name: имя ключевых кадров, имя ключевых кадров # 2;</td>
                <td>список применяемых к элементу анимаций (кадров)</td>
              </tr>
              <tr>
                <td>animation-duration</td>
                <td>продолжительность анимации</td>
              </tr>
              <tr>
                <td>animation-timing-function</td>
                <td>сценарий анимации</td>
              </tr>
              <tr>
                <td>animation-iteration-count</td>
                <td>количество повторов ключевых кадров</td>
              </tr>
              <tr>
                <td>animation-direction</td>
                <td>тип и направление проигрывания ключевых кадров</td>
              </tr>
              <tr>
                <td>animation-play-state</td>
                <td>запускает либо приостанавливает анимацию по событию</td>
              </tr>
              <tr>
                <td>animation-name: none;</td>
                <td>возвращает анимацию на исходную</td>
              </tr>
              <tr>
                <td>animation-delay</td>
                <td>задержка перед началом анимации</td>
              </tr>
              <tr>
                <td>animation-fill-mode</td>
                <td>определяет какие свойства применятся после завершения анимации</td>
              </tr>
            </tbody>
          </table>
          <pre><code>@keyframes grow {
  from {
    font-size: 20px;
  }
  to {
    font-size: 100px;
  }
}

h1 {
  animation-name: grow;
  animation-direction: 2s;
  animation-fill-mode: forwards;
}

или

@keyframes grow {
  from {
    left: 0%;
  }
  to {
    left: 50%;
  }
}

h1 {
  position: relative;
  animation-name: grow;
  animation-direction: 2s;
  animation-fill-mode: forwards;
}

animation: name duration function count direction delay mode;

animation: firstname 2s linear infinite alternate 0s forwards, secondname 5s ease infinite alternate 0s forwards;
</code></pre>
          <table> 
            <caption>Сколько свойств - столько и значений transition-duration через запятую</caption>
            <thead> 
              <tr>
                <th>свойство</th>
                <th>назначение</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>transition-duration</td>
                <td>время перехода</td>
              </tr>
              <tr>
                <td>transition-property</td>
                <td>содержит css свойства к которым будет применен переход</td>
              </tr>
              <tr>
                <td>transition-delay</td>
                <td>время задержки перехода</td>
              </tr>
              <tr>
                <td>transition-timing-function</td>
                <td>сценарий анимации</td>
              </tr>
            </tbody>
          </table>
          <p>Общая запись</p>
          <pre><code>transition: all 1s ease 0s; - transition: property duration function delay;

transition: padding 1s ease 0s, color 2s ease-in 0.5s;
</code></pre>
          <h2>Графика</h2>
          <table> 
            <thead> 
              <tr>
                <th>формат</th>
                <th>назначение</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td>JPEG/JPG</td>
                <td>растровый, оптимизируется хорошо, лучше для контента</td>
              </tr>
              <tr>
                <td>PNG</td>
                <td>растровый, оптимизируется плохо, может быть прозрачным, лучше для фона и элементов дизайна</td>
              </tr>
              <tr>
                <td>GIF</td>
                <td>растровый, до 256 цветов, видеоролик в формате изображения, оптимизируется хорошо</td>
              </tr>
              <tr>
                <td>SVG</td>
                <td>векторный, хорошо подходит для иконок и при масштабировании изображения</td>
              </tr>
              <tr>
                <td>WebP</td>
                <td>замена всех растровых форматов (прозрачность, анимация, хорошо оптимизируется)</td>
              </tr>
              <tr>
                <td>ico</td>
                <td>растровый, оптимизируется хорошо, может быть прозрачным, 16х16рх, для иконок</td>
              </tr>
              <tr>
                <td>object</td>
                <td>работа с изображениями в контейнере как background в фоне</td>
              </tr>
              <tr>
                <td>object-fit: fill;</td>
                <td>управляет изображением внутри контейнера</td>
              </tr>
              <tr>
                <td>object-position: center;</td>
                <td>позиционирование изображения относительно родителя</td>
              </tr>
            </tbody>
          </table>
          <pre><code>< link rel="shortcut icon" href="favicon.ico" /></code></pre>
        </details>
        <details> 
          <summary>SCSS</summary>
          <ul>
            <li><a href="https://sass-scss.ru/">SCSS</a>
            </li>
          </ul>
          <p>
            SCSS - препроцессор, добавляет функционала в css, препроцессор Sass похожий на синтаксис css.</br>
            Вложенность - писать правила css внутрь других правил:
          </p>
          <ul>
            <li>&amp; - подставляет вместо себя класс, внутри которого указан.</li>
            <li>Удобно для указания псевдоклассов и псевдоэлементов.</li>
          </ul>
          <pre><code>$var:80px; - переменная var со значением 80 пикселей</code></pre>
          <p>Шаблоны  </p>
          <pre><code>// задаём шаблон tpl
%tpl {параметры css}

// вставляем в нужный блок правил css
@extend %tpl;

// либо задаём шаблон tpl
.tpl {параметры css}

// вставляем в нужный блок правил css
@extend .tpl;

%message {
  font-family: sans-serif;
  font-size: 18px;
  font-weight: bold;
  border: 1px solid black;
  padding: 20px;
  margin: 20px;
}

.success {
  @extend %message;
  background-color: green;
}

.warning {
  @extend %message;
  background-color: orange;
}

.error {
  @extend %message;
  background-color: red;
}
</code></pre>
          <table>
            <caption>Миксины</caption>
            <tbody>
              <tr>
                <td>@mixin example($var) {font-size: $var;}</td>
                <td>объявляем миксин с переменной</td>
              </tr>
              <tr>
                <td>@include example(100px);</td>
                <td>вставляем в нужный блок правил css со значением поддерживает математические расчеты</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Комментарии</caption>
            <tbody>
              <tr>
                <td>/* */</td>
                <td>отображается и в файле scss и в css</td>
              </tr>
              <tr>
                <td>//</td>
                <td>отображается только в файле scss</td>
              </tr>
            </tbody>
          </table>
        </details>
        <details> 
          <summary>JS</summary>
          <ul>
            <li><a href="https://learn.javascript.ru/">javascript_ru</a>
            </li>
            <li><a href="https://learn.javascript.ru/basic-dom-node-properties#klassy-dom-uzlov">классы DOM-узлов</a>
            </li>
          </ul>
          <details> 
            <summary>Синтаксис JS</summary>
            <ul>
              <li>Имена должны быть легко читаемые, camelCase, описательные и лаконичные.</li>
              <li>Классы и модули строгий режим включают автоматически.</li>
            </ul>
            <pre><code>// вставить скрипт в html
< script> alert('Привет мир!')> </ script>
// подключить в html файл со скриптом
< script src="/path/to/script.js"></ script>

// строгий режим, отключить невозможно
"use strict" или 'use strict'

" " или ' ' - это строка

`${...}` - вставить выражение в строку

// - однострочный комментарий

/*...*/ - многострочный комментарий

// блок инструкций
{
  console.log('Учим');
  console.log('JS');
}</code></pre>
            <p>Комментируй</p>
            <ul>
              <li>Общую архитектуру.</li>
              <li>Использование функций.</li>
              <li>Неочевидные решения.</li>
              <li>Важные детали.</li>
            </ul>
            <p>Не комментируй что делает код.  </p>
            <p>Значения</p>
            <ul>
              <li>Выражения - комбинация значений переменных и операторов.</li>
              <li>Ключевые слова - определяет какое действие нужно выполнить.</li>
              <li>Автоматическое тестирование - тесты пишутся отдельно: запускают функции и сравнивают результат с ожидаемым.</li>
            </ul>
            <table>
              <thead> 
                <tr>
                  <th>значения</th>
                  <th>литералы</th>
                </tr>
              </thead>
              <tbody> 
                <tr>
                  <td>целое число</td>
                  <td>25</td>
                </tr>
                <tr>
                  <td>дробное число</td>
                  <td>23.8</td>
                </tr>
                <tr>
                  <td>строки</td>
                  <td>'Javascript', "Javascript"</td>
                </tr>
                <tr>
                  <td>массив</td>
                  <td>[], [15,7,89]</td>
                </tr>
                <tr>
                  <td>объект</td>
                  <td>{}, {name: 'Javascript', surname: 'Javascript'}</td>
                </tr>
                <tr>
                  <td>регулярное выражение</td>
                  <td>(ab\|bc)</td>
                </tr>
                <tr>
                  <td>константа</td>
                  <td>const MAX_VALUE = 17;</td>
                </tr>
                <tr>
                  <td>переменная</td>
                  <td>var section = 'JS'; или let arr = ['HTML','CSS','JS'];</td>
                </tr>
              </tbody>
            </table>
            <p>Спецификация</p>
            <pre><code>// описываем функцию pow
describe ("pow", function(){

  // рабочий блок - описывает что делает
  it ("возводит в степень n", function() {

    // функция assert проверяет работу функции pow
    assert.equal(pow(2, 3), 8);
  });
});</code></pre>
            <p>Опциональная цепочка</p>
            <ul>
              <li>если перед ?. undefined или null, то остановит вычисление и вернёт undefined (без ошибки).</li>
              <li>?. работает c: существующими переменными, функциями user1.admin?.(...) и квадратными скобками ?.[...].</li>
            </ul>
            <table> 
              <tbody> 
                <tr>
                  <td>let user = {};</td>
                  <td>пользователь без адреса</td>
                </tr>
                <tr>
                  <td>alert(user?.address?.street);</td>
                  <td>undefined (без ошибки)</td>
                </tr>
                <tr>
                  <td>delete user?.name</td>
                  <td>удалит user.name если user существует</td>
                </tr>
                <tr>
                  <td>obj?.prop</td>
                  <td>вернёт obj.prop если obj есть, иначе undefined</td>
                </tr>
                <tr>
                  <td>obj?.[prop]</td>
                  <td>вернёт obj[prop] если obj есть, иначе undefined</td>
                </tr>
                <tr>
                  <td>obj.method?.()</td>
                  <td>вызовет obj.method если он есть, иначе undefined</td>
                </tr>
              </tbody>
            </table>
          </details>
          <details> 
            <summary>Environment & Scope</summary>
            <ul>
              <li>переменная - это именованное хранилище для данных, которое является свойством Environment Record.</li>
              <li>переменные - это ссылки на значения, объекты или на другие переменные.</li>
              <li>переменные - это не свойства функции и не наоборот - это два параллельных мира.</li>
              <li>объекты хранятся и копируются по ссылке.</li>
              <li>имя переменной может содержать буквы, цифры, символы $ и _.</li>
              <li>первый символ в имени не цифра.</li>
              <li>регистр имеет значение.</li>
              <li>минификатор - программа уменьшения размера кода: локальным переменным даёт укороченные имена, удаляет комментарии и лишние пробелы.</li>
            </ul>
            <p>Создание переменной происходит в два этапа:</p>
            <ul>
              <li>declaration (объявление) - переменная не объявлена - is not defined</li>
              <li>definition (определение), initialization (инициализация) - переменная не определена - undefined</li>
            </ul>
            <table> 
              <thead> 
                <tr>
                  <th>синтаксис</th>
                  <th>назначение</th>
                </tr>
              </thead>
              <tbody> 
                <tr>
                  <td>const</td>
                  <td>неизменяемая переменная, область видимости блок, hoisting не работает</td>
                </tr>
                <tr>
                  <td>const KNOW_VAL = I know the value;</td>
                  <td>константа с известным заранее значением пишем в верхнем регистре</td>
                </tr>
                <tr>
                  <td>const donotKnow = I don't know the value;</td>
                  <td>константа с неизвестным заранее значением в нижнем регистре</td>
                </tr>
                <tr>
                  <td>let</td>
                  <td>изменяемая переменная, область видимости блок, hoisting не работает</td>
                </tr>
                <tr>
                  <td>var</td>
                  <td>изменяемая переменная, область видимости функция или скрипт, hoisting работает</td>
                </tr>
                <tr>
                  <td></td>
                  <td>область видимости в пределах модуля</td>
                </tr>
                <tr>
                  <td></td>
                  <td>исключение: если объявлена в теле функции, то видна только в теле функции</td>
                </tr>
              </tbody>
            </table>
            <p>hoisting (всплытие, поднятие)</p>
            <p>
              Это механизм в JS, в котором объявления переменных и функций, передвигаются вверх своей области видимости (локальной или глобальной) перед тем как код будет выполнен и мы можем обратиться к ним ещё до их определения.<br />
              hoisting передвигает только объявления функций и переменных, их определения остаются на своих местах.
              
            </p>
            <p>LexicalEnvironment - объект лексического окружения состоит из двух частей</p>
            <p>Environment Record - объект, в котором как свойства хранятся все локальные переменные, значение this и т.д</p>
            <p>Связь между идентификаторами переменных (a, b, c) и функций (funcA, funcB, funcC) с их определениями на основе вложенности лексических областей видимости.</p>
            <ul>
              <li>Один вызов функции - одно лексическое окружение.</li>
              <li>Лексическое окружение создаётся при выполнении блока кода и содержит локальные переменные для этого блока.</li>
              <li>Для цикла у каждой итерации своё отдельное лексическое окружение.</li>
              <li>Из-за того, что у блока есть собственное лексическое окружение, код снаружи не видит переменные этого блока.</li>
              <li>При обращении к переменной - сначала ищем во внутреннем лексическом окружении, затем во внешнем, и так до глобального.</li>
              <li>Функция получает последнее значение внешних переменных.</li>
              <li>Объект лексического окружения существует пока есть хотя бы одна вложенная функция, которая ссылается на него.</li>
            </ul>
            <pre><code>function funcA() {
  let a = 1;
  function funcB() {
    let b = 2;
    function funcC() {
      let c = 3;
      console.log(a, b, c);
    }
  }
}</code></pre>
            <p>Scope (лексическая область видимости) - ссылка на внешнее лексическое окружение, т.е. это область видимости, которая указывает на доступность переменных.</p>
            <ul>
              <li>глобальная область видимости - window или document в браузере.</li>
              <li>локальная область видимости  - в рамках одной функции или блока кода.</li>
            </ul>
            <p>Это область видимости, которая определена во время разбора кода на лексемы и формируется исходя из того, где переменные, функции и инструкции размещены в коде.</p>
            <table> 
              <caption>Лексемы</caption>
              <thead>
                <tr>
                  <th colspan="2">var a = 2;</th>
                  <th> </th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>var</td>
                  <td>объявление переменной</td>
                </tr>
                <tr>
                  <td>a  </td>
                  <td>идентификатор (имя) переменной</td>
                </tr>
                <tr>
                  <td>=  </td>
                  <td>оператор присваивания</td>
                </tr>
                <tr>
                  <td>2  </td>
                  <td>число</td>
                </tr>
                <tr>
                  <td>;  </td>
                  <td>конец инструкции</td>
                </tr>
              </tbody>
            </table>
            <pre><code>// global scope
let a = 'variable a';
let b = 'variable b';
{

  // a from global scope
  a = 'New variable A';

  // b from local scope
  let b = 'Local Variable B';

  // New Variable A
  console.log('A:', a);

  // Local Variable B
  console.log('B:', b);

  // ReferenceError
  console.log('C:', c);
  let c = 'Something';
}

// New Variable A
console.log('A:', a);

// Local Variable B
console.log('B:', b);</code></pre>
          </details>
          <details> 
            <summary>Модуль</summary>
            <p>Модуль - это файл.</p>
            <ul>
              <li>чтобы работал import/export, добавить атрибут type='module'.</li>
              <li>export отмечает переменные и функции, которые должны быть доступны вне текущего модуля.</li>
              <li>import позволяет импортировать функциональность из других модулей.</li>
              <li>import/export могут быть вначале или в конце скрипта, но не внутри блока { }.</li>
            </ul>
            <pre><code><! doctype html>
  < script type="module">
    import {sayHi} from './say.js';
    document.body.innerHTML = sayHi('John');
  </ script></code></pre>
            <p>У модулей</p>
            <ul>
              <li>отложенное (deferred) выполнение по умолчанию.</li>
              <li>загрузка внешних модулей не блокирует обработку HTML и выполняются только после загрузки HTML документа.</li>
              <li>выполняются в порядке расположения в документе.</li>
              <li>для загрузки внешнего модуля с другого источника, он должен ставить заголовки CORS.</li>
              <li>дублирующиеся внешние скрипты игнорируются.</li>
              <li>у модулей своя область видимости, обмен через import/export.</li>
              <li>в модуле всегда включен 'use strict'.</li>
              <li>код в модуле выполняется только один раз.</li>
            </ul>
            <table> 
              <caption>Синтаксис</caption>
              <tbody>
                <tr>
                  <td>export default class/function/variable</td>
                  <td>перед объявлением класса/функции/переменной</td>
                </tr>
                <tr>
                  <td>export {x as y, ...}</td>
                  <td>отдельный экспорт</td>
                </tr>
                <tr>
                  <td>export {x [as y], ...} from "moduleName"</td>
                  <td>реэкспорт</td>
                </tr>
                <tr>
                  <td>export * from "moduleName"</td>
                  <td>реэкспорт всего кроме export default</td>
                </tr>
                <tr>
                  <td>export {default [as y], ...} from "moduleName"</td>
                  <td>реэкспорт только export default</td>
                </tr>
                <tr>
                  <td>import {x [as y], ...}</td>
                  <td>именованный импорт из модуля</td>
                </tr>
                <tr>
                  <td>import x from "moduleName"</td>
                  <td>импорт по умолчанию</td>
                </tr>
                <tr>
                  <td>import {default as x} from "moduleName"</td>
                  <td>импорт по умолчанию</td>
                </tr>
                <tr>
                  <td>import * as obj from "moduleName"</td>
                  <td>импорт всего сразу</td>
                </tr>
                <tr>
                  <td>import "moduleName"</td>
                  <td>подключить модуль без присваивания переменной</td>
                </tr>
              </tbody>
            </table>
            <table> 
              <thead> 
                <tr>
                  <th>Именованный экспорт</th>
                  <th>Экспорт по умолчанию </th>
                </tr>
              </thead>
              <tbody> 
                <tr>
                  <td>export class User {...}</td>
                  <td>export default class User {...}</td>
                </tr>
                <tr>
                  <td>import {User} from ...</td>
                  <td>import User from ...</td>
                </tr>
              </tbody>
            </table>
            <p>
              Выражение import(moduleName) загружает модуль и возвращает промис, результатом которого становится объект модуля, содержащий все его экспорты.<br />
              Динамический импорт работает в обычных скриптах и не требует указания script type="module".<br />
              import() - это не функция, а спец.синтаксис, как super().
            </p>
            <pre><code>// say.js
export function hi() {
  alert('Привет');
}
export function buy() {
  alert('Пока');
}
export default function() {
  alert('Модуль загружен');
}

< !doctype html>;
< script>;                    
  async function load() {                             
    let say = await import('./say.js');
    // Привет     
    say.hi();
    // Пока
    say.buy();
    // Модуль загружен
    say.default();
  }                                               
< /script>
< button onclick = "load"> Нажми меня < /button></code></pre><img src="./assets/img/contimg/promise.png" alt="" loading="lazy"/>
          </details>
          <details> 
            <summary>Types</summary>
            <ul>
              <li>набор характеристик значения.</li>
              <li>не у переменной, а у значения.</li>
              <li>присваивается переменной вместе со значением.</li>
            </ul>
            <p>Примитивы</p>
            <ul>
              <li>примитивы - это конкретные значения.</li>
              <li>с помощью объектов-оберток (Number, String, ...) все примитивы кроме null и undefined имеют методы работы с ними.</li>
              <li>обычные числа в JS - это числа с плавающей точкой двойной точности (double precision floating point numbers), 64-битный формат IEEE-754.</li>
              <li>bigInt - числа позволяют работать с числами произвольной длины.</li>
            </ul>
            <table>
              <tbody> 
                <tr>
                  <td>undefined</td>
                  <td>не определен, нет значения</td>
                </tr>
                <tr>
                  <td>null</td>
                  <td>переменная определена, значение - ничего</td>
                </tr>
                <tr>
                  <td>boolean</td>
                  <td>true/false</td>
                </tr>
                <tr>
                  <td>number</td>
                  <td>числа целые и с точкой</td>
                </tr>
                <tr>
                  <td>infinity</td>
                  <td>бесконечность</td>
                </tr>
                <tr>
                  <td>NaN</td>
                  <td>Not a Number</td>
                </tr>
              </tbody>
            </table>
            <table>
              <tbody> 
                <tr>
                  <td>123e6 = 123 000 000</td>
                  <td>e6 - это 6 нулей</td>
                </tr>
                <tr>
                  <td>123e-6 = 0,000123</td>
                  <td></td>
                </tr>
                <tr>
                  <td>let someNum = 1000000;
                    <td>let someNum = 1e6;</td>
                  </td>
                </tr>
                <tr>
                  <td>let num = 0.000001;
                    <td>let num = 1e-6;</td>
                  </td>
                </tr>
              </tbody>
            </table>
            <p>Object</p><img src="./assets/img/contimg/proto.png" alt="" loading="lazy"/>
            <pre><code>Object
{
  property1: value1,
  property2: value2
}
let someObj = new Object();
let someObj = {
  key1: value1,
};
console.log(someObj.key);
console.log(someObj['key']);

// добавил в объект свойство (ключ: значение)
someObj.key2 = value2;

// удалил из объекта свойство (ключ: значение)
delete someObj.key2;

// скопировал ссылку на объект в другую переменную
let obj = someObj;

// сделал дубликат объекта
let obj = Object.assign({}, someObj);

// проверка на наличие свойства
if ("key1" in someObj) {}

// перебирает все свойства объекта
for (let key in object) {}

let someObj = {
  key1: value1,

  // метод объекта
  someFunc: function () {}
  
  someFunc() {}
};

// получить все свойства объекта с ключами-символами
Object.getOwnPropertySymbols(obj)

// возвращает все ключи объекта включая символьные
Reflect.ownKeys(obj)</code></pre>
            <p>преобразование объекта в примитив</p>
            <pre><code>// вызывается метод объекта если он существует
obj[Symbol.toPrimitive](hint)

// вызывается obj.toString(), если такого нет, то obj.valueOf()
hint = string

// вызывается obj.valueOf(), если такого нет, то obj.toString()
hint = number или default</code></pre>
            <p>Symbol - идентификатор объекта</p>
            <ul>
              <li>два Symbol('id') с одинаковым 'id' - это разные символы.</li>
              <li>в глобальном реестре под одним именем один символ.</li>
              <li>используется как 'скрытые' свойства объектов, т.к. символьное свойство не появится в for..in.</li>
            </ul>
            <pre><code>//  читает символ "id" из глобального реестра, если символа нет, то создаст новый глобальный символ.
let id = Symbol.for("id")

// для итераторов
Symbol.iterator

// для преобразования объектов в примитивы
Symbol.toPrimitive

// создание символа
let id = Symbol("id");
let user = {

  // не преобразуются в строку автоматически, просто id:123 не работает, т.к. нужно значение переменной id, а не срока id.
  name: "Вася",
  [id]: 123
};</code></pre>
            <p>typeof</p>
            <table> 
              <tbody> 
                <tr>
                  <td>typeof</td>
                  <td>возвращает тип аргумента</td>
                </tr>
                <tr>
                  <td>typeof 0</td>
                  <td>number</td>
                </tr>
                <tr>
                  <td>typeof true</td>
                  <td>boolean</td>
                </tr>
                <tr>
                  <td>typeof 'JS'</td>
                  <td>string</td>
                </tr>
                <tr>
                  <td>typeof undefined</td>
                  <td>undefined</td>
                </tr>
                <tr>
                  <td>typeof Math</td>
                  <td>object</td>
                </tr>
                <tr>
                  <td>typeof Symbol ('JS')</td>
                  <td>symbol</td>
                </tr>
                <tr>
                  <td>typeof null</td>
                  <td>object - баг, это null</td>
                </tr>
                <tr>
                  <td>typeof function() {}</td>
                  <td>function - баг, это object</td>
                </tr>
                <tr>
                  <td>typeof NaN</td>
                  <td>number - Not a Number возвращает number</td>
                </tr>
              </tbody>
            </table>
            <p>Приведение типов</p>
            <ul>
              <li>основные приведения: строковое, численное и логическое.</li>
              <li>операторы приводят значения null к 0, а undefined к NaN.</li>
              <li>при нестрогом равенстве null/undefined ни к чему не приводятся и равны только друг другу.</li>
            </ul>
            <table>
              <tbody> 
                <tr>
                  <td>' ', 0, null, undefined, Nan, false</td>
                  <td>приводятся Boolean() к false.</td>
                </tr>
                <tr>
                  <td>Boolean('Hello')</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>Boolean(' ')</td>
                  <td>true, пробел - это символ</td>
                </tr>
                <tr>
                  <td>Boolean('0')</td>
                  <td>true, '0' приводится к строке</td>
                </tr>
                <tr>
                  <td>Boolean(0)</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>Boolean([])</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>Boolean({})</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>null > 0</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>null >= 0</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>null == 0</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>undefined > 0</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>undefined == 0</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>NaN</td>
                  <td>false при любых сравнениях</td>
                </tr>
                <tr>
                  <td>String(value);</td>
                  <td>приведение к строке</td>
                </tr>
                <tr>
                  <td>Number(value);</td>
                  <td>приведение к числу</td>
                </tr>
                <tr>
                  <td>Number("123");</td>
                  <td>123</td>
                </tr>
                <tr>
                  <td>Number("123z");</td>
                  <td>NaN</td>
                </tr>
                <tr>
                  <td>Number(true);</td>
                  <td>1</td>
                </tr>
                <tr>
                  <td>Number(false);</td>
                  <td>0</td>
                </tr>
                <tr>
                  <td>+true</td>
                  <td>1</td>
                </tr>
                <tr>
                  <td>+''</td>
                  <td>0</td>
                </tr>
                <tr>
                  <td>null + 2</td>
                  <td>number 2, null приводится к 0</td>
                </tr>
                <tr>
                  <td>1 + '2'</td>
                  <td>string 12</td>
                </tr>
                <tr>
                  <td>'' + 1 + 0</td>
                  <td>string 10</td>
                </tr>
                <tr>
                  <td>'' - 1 + 0</td>
                  <td>number -1, у строки есть только оператор сложения (конкатенация), поэтому -1 это число + 0</td>
                </tr>
                <tr>
                  <td>'3' + '8'</td>
                  <td>number 24</td>
                </tr>
                <tr>
                  <td>4 + 10 + 'px'</td>
                  <td>string 14px</td>
                </tr>
                <tr>
                  <td>'px' + 4 + 10</td>
                  <td>string px410</td>
                </tr>
                <tr>
                  <td>'42' - 40</td>
                  <td>number 2</td>
                </tr>
                <tr>
                  <td>'42px' - 40</td>
                  <td>NaN, px к числу не приводится</td>
                </tr>
                <tr>
                  <td>undefined + 2</td>
                  <td>NaN, undefined приводится к NaN</td>
                </tr>
                <tr>
                  <td>parseInt()</td>
                  <td>возвращает целое число, которое смогло получить из параметра</td>
                </tr>
                <tr>
                  <td>parseFloat()</td>
                  <td>возвращает число с точкой, которое смогло получить из параметра</td>
                </tr>
                <tr>
                  <td>parseInt(str, base)</td>
                  <td>преобразует строку в число, base - система исчисления 2 =< base =< 36, по умолчанию 10</td>
                </tr>
                <tr>
                  <td>parseInt('0xff', 16)</td>
                  <td>255, дополнительное свойство - читает кодировки чисел</td>
                </tr>
                <tr>
                  <td>parseInt('100px')</td>
                  <td>100</td>
                </tr>
                <tr>
                  <td>parseFloat('12.5el')</td>
                  <td>12.5</td>
                </tr>
                <tr>
                  <td>parseInt('a123')</td>
                  <td>NaN, не смог прочитать ни одной цифры</td>
                </tr>
                <tr>
                  <td>num.toString(base)</td>
                  <td>преобразует число num в строку в виде системы исчисления base (от 2 до 32, по умолчанию 10)</td>
                </tr>
                <tr>
                  <td>123..toString(36)</td>
                  <td>вызывать метод на числе</td>
                </tr>
                <tr>
                  <td>(123).toString(36)</td>
                  <td></td>
                </tr>
                <tr>
                  <td>num.toFixed(n)</td>
                  <td>округляет до n знаков после запятой и возвращает результат в виде строки</td>
                </tr>
                <tr>
                  <td>isNaN(value)</td>
                  <td>преобразует в число и проверяет является ли оно NaN. NaN никогда не будет равно NaN</td>
                </tr>
                <tr>
                  <td>NaN === NaN</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>isFinite(value)</td>
                  <td>преобразует в число и возвращает true если обычное число</td>
                </tr>
                <tr>
                  <td>Object.is(a, b)</td>
                  <td>идентично a === b</td>
                </tr>
                <tr>
                  <td>Object.is(NaN, NaN)</td>
                  <td>=== true</td>
                </tr>
                <tr>
                  <td>Object.is(0, -0)</td>
                  <td>=== false, технически 0 и -0 это разные значения</td>
                </tr>
                <tr>
                  <td>Math</td>
                  <td>встроенный объект - математические операции над числами</td>
                </tr>
              </tbody>
            </table>
          </details>
          <details> 
            <summary>Операторы</summary>
            <p>операнд - это то, к чему применяется оператор</p>
            <table>
              <tbody> 
                <tr>
                  <td>-х;</td>
                  <td>унарный оператор - применяется к одному операнду</td>
                </tr>
                <tr>
                  <td>у - х;</td>
                  <td>бинарный оператор - применяется к двум операндам</td>
                </tr>
                <tr>
                  <td>+операнд</td>
                  <td>приведение к числу</td>
                </tr>
                <tr>
                  <td>=</td>
                  <td>оператор присваивания</td>
                </tr>
              </tbody>
            </table>
            <p>все операторы возвращают значение</p>
            <table> 
              <tbody> 
                <tr>
                  <td>+</td>
                  <td>сложения, если одно из слагаемых строка, то сумма - строка</td>
                </tr>
                <tr>
                  <td colspan="2">остальные операторы дают число</td>
                  <td> </td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>вычитания</td>
                </tr>
                <tr>
                  <td>*</td>
                  <td>умножения</td>
                </tr>
                <tr>
                  <td>%</td>
                  <td>взятие остатка от деления (5%2 = 1)</td>
                </tr>
                <tr>
                  <td>**</td>
                  <td>возведения в степень</td>
                </tr>
                <tr>
                  <td>2**2 = 4</td>
                  <td></td>
                </tr>
                <tr>
                  <td>4**(1/2) = 2</td>
                  <td>квадратный корень</td>
                </tr>
                <tr>
                  <td>8**(1/3) = 2</td>
                  <td>кубический корень</td>
                </tr>
                <tr>
                  <td>/</td>
                  <td>деления</td>
                </tr>
              </tbody>
            </table>
            <p>инкремент/декремент можно применять только к переменной</p>
            <table>
              <tbody> 
                <tr>
                  <td>++       </td>
                  <td>инкремент увеличивает на 1</td>
                </tr>
                <tr>
                  <td>--       </td>
                  <td>декремент уменьшает на 1</td>
                </tr>
                <tr>
                  <td>counter++</td>
                  <td>постфиксная форма возвращает старое значение (до увеличения/уменьшения числа)</td>
                </tr>
                <tr>
                  <td>++counter</td>
                  <td>префиксная форма возвращает новое значение</td>
                </tr>
              </tbody>
            </table>
            <table> 
              <caption>операторы == vs === (нестрогое vs строгое)</caption>
              <tbody> 
                <tr>
                  <td>==</td>
                  <td>сравнивает с приведением типов</td>
                </tr>
                <tr>
                  <td>===</td>
                  <td>сравнивает без приведения типов</td>
                </tr>
                <tr>
                  <td>2 == '2'</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>2 === '2'</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>undefined == null</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>undefined === null</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>'0' == false</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>'0' == 0</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>0 == 0</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>false == ''</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>false == []</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>false == {}</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>'' == 0</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>'' == []</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>'' == {}</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>'' == null</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>{} == {}</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>{} === {}</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>== и ===</td>
                  <td>для объектов работают одинаково, два объекта равны если это один и тот же объект</td>
                </tr>
              </tbody>
            </table>
            <table> 
              <caption>Приоритет</caption>
              <tbody> 
                <tr>
                  <td>+</td>
                  <td>унарный плюс</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>унарный минус</td>
                </tr>
                <tr>
                  <td>**</td>
                  <td>возведение в степень</td>
                </tr>
                <tr>
                  <td>*</td>
                  <td>умножение</td>
                </tr>
                <tr>
                  <td>/</td>
                  <td>деление</td>
                </tr>
                <tr>
                  <td>+</td>
                  <td>сложение</td>
                </tr>
                <tr>
                  <td>-</td>
                  <td>вычитание</td>
                </tr>
                <tr>
                  <td>=</td>
                  <td>присваивание</td>
                </tr>
              </tbody>
            </table>
            <h3>Операторы сравнения</h3>
            <ul>
              <li>все операторы сравнения возвращают true или false.</li>
              <li>строки сравниваются посимвольно.</li>
              <li>при сравнении разных типов - приведение к числу.</li>
            </ul>
            <table>
              <tbody> 
                <tr>
                  <td>a > b, a < b</td>
                  <td>больше/меньше</td>
                </tr>
                <tr>
                  <td>a >= b, a <= b</td>
                  <td>больше/меньше или равно</td>
                </tr>
                <tr>
                  <td>a == b</td>
                  <td>равно</td>
                </tr>
                <tr>
                  <td>a === b</td>
                  <td>строгое равно</td>
                </tr>
                <tr>
                  <td>a != b</td>
                  <td>не равно</td>
                </tr>
                <tr>
                  <td>a !== b</td>
                  <td>строгое не равно</td>
                </tr>
              </tbody>
            </table>
            <h3>Оператор запятая</h3>
            <ul>
              <li>позволяет вычислять несколько выражений, разделяя их запятой.</li>
              <li>каждое выражение выполняется, но возвращается результат только последнего.</li>
            </ul>
            <table> 
              <tbody> 
                <tr>
                  <td>let a = (1+2, 3+4);</td>
                  <td>скобки важны, т.к. приоритет ниже чем =</td>
                </tr>
                <tr>
                  <td>alert(a);          </td>
                  <td>7 - результат 3 + 4</td>
                </tr>
              </tbody>
            </table>
            <h3>Побитовые операторы</h3>
            <p>Побитовые операторы работают с 32-разрядными целыми числами (приводят к ним), на уровне их внутреннего двоичного представления.</p>
            <table> 
              <tbody> 
                <tr>
                  <td>&</td>
                  <td>AND</td>
                  <td>и</td>
                </tr>
                <tr>
                  <td>|</td>
                  <td>OR</td>
                  <td>или</td>
                </tr>
                <tr>
                  <td>^</td>
                  <td>XOR</td>
                  <td>побитовое исключающие или</td>
                </tr>
                <tr>
                  <td>~</td>
                  <td>NOT</td>
                  <td>не</td>
                </tr>
                <tr>
                  <td><<</td>
                  <td>LEFT SHIFT</td>
                  <td>левый сдвиг</td>
                </tr>
                <tr>
                  <td>>></td>
                  <td>RIGHT SHIFT</td>
                  <td>правый сдвиг</td>
                </tr>
                <tr>
                  <td>>>></td>
                  <td>ZERO-FILL RIGHT SHIFT</td>
                  <td>правый сдвиг с заполнением нулями</td>
                </tr>
              </tbody>
            </table>
            <h3>Логические операторы</h3>
            <h4>! НЕ</h4>
            <ul>
              <li>принимает один аргумент, приводит к логическому типу и возвращает противоположное значение.</li>
              <li>приоритет наивысший из всех логических операторов.</li>
            </ul>
            <table> 
              <tbody> 
                <tr>
                  <td>!true</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>!0</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>!"non-empty string"</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>!null</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>!операнд</td>
                  <td>приведение к boolean</td>
                </tr>
              </tbody>
            </table>
            <h4>&& - И</h4>
            <ul>
              <li>если оба аргумента true, то вернет true, иначе false.</li>
              <li>цепочка или &amp;&amp; возвращает первое ложное значение или или последнее, если такое значение не найдено.</li>
              <li>приоритет и &amp;&amp; больше чем или ||.</li>
            </ul>
            <table>
              <tbody>
                <tr>
                  <td>true  && true </td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>false && true </td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>true  && false</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>false && false</td>
                  <td>false</td>
                </tr>
              </tbody>
            </table>
            <h4>|| - ИЛИ</h4>
            <ul>
              <li>если любой из аргументов true, то вернет true, иначе false.</li>
              <li>цепочка или || возвращает первое истиное значение или последнее, если такое значение не найдено.</li>
              <li>цепочка вычисляется слева направо.</li>
            </ul>
            <p>или || спотыкается на правде, и && спотыкается на лжи</p>
            <table>
              <tbody>
                <tr>
                  <td>true  || true</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>false || true</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>true  || false</td>
                  <td>true</td>
                </tr>
                <tr>
                  <td>false || false</td>
                  <td>false</td>
                </tr>
                <tr>
                  <td>undefined || null || 0</td>
                  <td>// результат 0</td>
                </tr>
              </tbody>
            </table>
            <p>?? - оператор объединения с null, возвращает первое определённое значение, если оно отличается от null или undefined</p>
            <p>запрещено использовать оператор ?? вместе с && и || без явного указания приоритета скобками</p>
            <pre><code>let height = 0;

// вернет 100
height || 100

// вернет 0
height ?? 100

//результат a, если а определено, иначе b
a ?? b

let user;

//Аноним
alert(user??"Аноним");</code></pre>
            <p>... - ТРОЕТОЧИЕ</p>
            <ul>
              <li>обозначает оператор 'остаточные параметры' если находится в конце списка аргументов функции либо оператор 'расширения'.</li>
              <li>оператор 'остаточные параметры' используется, чтобы создавать функции с неопределённым числом аргументов, собирает оставшиеся параметры в массив.</li>
              <li>оператор 'расширения' позволяет вставить массив в функцию, расширяя перебираемый объект arr в список аргументов (f...arr).</li>
              <li>оператор 'расширения' работает только с итерируемыми объектами.</li>
            </ul>
            <pre><code>let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];</code></pre>
          </details>
          <details> 
            <summary>Инструкции</summary>
            <p>Условное ветвление</p>
            <ul>
              <li>вычисляет условие в скобках.</li>
              <li>приводит к логическому типу.</li>
              <li>если условие true, то выполняет блок кода.</li>
              <li>блоков else и else if может быть сколько угодно, а может и не быть.</li>
            </ul>
            <ul>
              <li>switch заменяет несколько if.</li>
              <li>switch имеет один или несколько блоков case.</li>
              <li>проверка равенства всегда строгая.</li>
              <li>если нет break, то выполнение пойдет по следующим case без проверки.</li>
            </ul>
            <pre><code>switch(x) {
  case 'value1':
    // выполнить действие
    break
  case 'value2':
    // выполнить действие
    break
  default:
    // выполнить действие
  break
}</code></pre>
            <p>? - тернарный оператор (три аргумента), break/continue использовать нельзя</p>
            <pre><code>// если условие true, то значение1, иначе значение2
let result = условие ? значение1 : значение2;

// тоже самое if () {} else {}
(условие) ? valueIfTrue : valueIfFalse;</code></pre>
            <p>Циклы</p>
            <ul>
              <li>выполнить начало.</li>
              <li>если условие true, то выполнить тело и затем выполнить шаг.</li>
              <li>повторять пока условие true.</li>
              <li>любая часть может быть пропущена.</li>
              <li>for..in для перебора свойств объекта.</li>
              <li>for..of для перебора значений массива.</li>
            </ul>
            <pre><code>// тело цикла - выполняется пока условие true, если процедура не одна, то {}
while (условие) {}

// если процедура не одна
while (условие) procedure;

do {
  // тело цикла
} while (условие);</code></pre>
            <pre><code>for (начало; условие; шаг) {тело цикла}

// будет выполняться вечно
for (;;) {}

// тело цикла выполняется для каждого свойства объекта
for (key in object) {}

let fruits = ["Яблоко", "Апельсин", "Слива"];

// проходит по значениям каждого элемента массива
for (let fruit of fruits) {

  // не предоставляет доступа к номеру элемента, только к его значению
  alert(fruit);
}</code></pre>
            <p>метка - точка местоположения в коде</p>
            <pre><code>// outer: - метка-идентификатор с двоеточием
outer: for (начало; условие; шаг) {
  for (начало; условие; шаг) {

    // break/continue возвращает к метке
    if (!input) break outer;
  }
}</code></pre>
            <p>Функция</p>
            <p>Function - это Object, но выведен отдельно для простоты определения функций</p><img src="../assets/img/contimg/синтаксис.png" alt="" loading="lazy"/>
            <ul>
              <li>функция - это значение, представляющее действие, одна функция - одно действие.</li>
              <li>функция - это объект, у него есть свойства.</li>
              <li>name - имя функции.</li>
              <li>length - количество аргументов в объявлении функции, троеточие (остаточные аргументы) не считаться.</li>
              <li>можно передать внутрь функции любую информацию через аргументы функции.</li>
              <li>переданные через **аргументы** значения копируются в локальные переменные (**параметры**) и используются в теле функции.</li>
              <li>функция всегда получает только копию значения.</li>
              <li>если аргумент не указан, то его значением становится undefined.</li>
              <li>все аргументы функции находятся в псевдомассиве **arguments** под своими порядковыми номерами.</li>
              <li>псевдомассив arguments не поддерживает методы массивов - мы не можем получить их часть.</li>
              <li>функция может содержать другие функции в своих свойствах.</li>
            </ul>
            <pre><code>function sayHi(аргументы, через, запятую) {тело функции, код}

// обращение к переменной, содержащей код функции
sayHi

// вызываем код функции на выполнение
sayHi()

function showMessage(from, text = "текст не добавлен") {
  
  // "текст не добавлен" - текст по умолчанию
  alert(from + ": " + text);
}</code></pre>
            <ul>
              <li>return - функция останавливается и возвращает значение, результат функции с пустым return или без него - undefined.</li>
              <li>вложенной функция - функция внутри другой функции.</li>
              <li>рекурсия - функция вызывает саму себя, глубина рекурсии - количество вызовов самой себя.</li>
              <li>колбэк функция - функция передаваемая параметром в другую функцию и вызываемая внутри другой функции.</li>
            </ul>
            <pre><code>function func1(param1, param2) {}
function func2(param3) {}
function func3(param1, param2) {
  func2(func1(param1, param2));
}

// вернёт результат работы func1 и func2
func3(param1, param2);</code></pre>
            <p>Function Declaration (Объявление функций)</p>
            <ul>
              <li>считывается интерпретатором когда создаётся лексическое окружение, в котором объявлена, hosting работает.</li>
              <li>при запуске функций, для неё создаётся лексическое окружение для хранения локальных переменных и параметров вызова.</li>
            </ul>
            <pre><code>function sayHi(аргументы, через, запятую) {
  // тело, код функции
}</code></pre>
            <p>Function Expression (Функциональное выражение) считывается когда выполнение доходит до него, hosting не работает</p>
            <pre><code>let sayHi = function() {
  alert("Привет");
}</code></pre>
            <p>Named Function Expression NFE (именованное функциональное выражение)</p>
            <ul>
              <li>у функционального выражения есть имя.</li>
              <li>имя функционального выражения не доступно за пределами функции и позволяет функции ссылаться на себя (рекурсивные вызовы).</li>
            </ul>
            <pre><code>let sayHi = function func(who) {
  alert(`Hello, ${who}`);
}</code></pre>
            <p>IIFE (Immediate Invoked Function Expression)</p>
            <ul>
              <li>функциональное выражение моментального выполнения.</li>
              <li>позволяет оборачивать функции для моментального выполнения, передавая необходимые параметры.</li>
              <li>используются для создания локальной области видимости (scope) с замыканием на внешнюю переменную.</li>
            </ul>
            <table>
              <caption>создать IIFE</caption>
              <tbody> 
                <tr>
                  <td>(function() { alert() })();</td>
                  <td>Скобки вокруг функции</td>
                </tr>
                <tr>
                  <td>(function() { alert() }());</td>
                  <td>Скобки вокруг всего</td>
                </tr>
                <tr>
                  <td>!function() { alert() }();</td>
                  <td>Выражение начинается с логического оператора NOT</td>
                </tr>
                <tr>
                  <td>+function() { alert() }();</td>
                  <td>Выражение начинается с унарного плюса</td>
                </tr>
              </tbody>
            </table>
            <p>=> Arrow functions (Стрелочные функции)</p>
            <ul>
              <li>не имеют this - значение this из внешнего кода.</li>
              <li>не имеют arguments - arguments внешней функции.</li>
              <li>не могут быть вызваны с new - не могут быть конструктором.</li>
              <li>нет super.</li>
              <li>предназначены для небольшого кода без своего контекста - выполняются в контексте внешнего кода.</li>
              <li>func.bind(this) создаёт связанную версию функции, а =&gt; ничего не привязывает, т.к. у неё нет this.</li>
            </ul>
            <pre><code>let sum = (a, b) => a + b;

let sum = (a, b) => {
  let result = a + b;
  
  // при фигурных скобках для возврата значения нужно явно вызвать return
  return result;
};</code></pre>
            <p>new Function</p>
            <ul>
              <li>доступ только к глобальным переменным, т.к. при создании функции в её [[Environment]] записывается ссылка на глобальное лексическое окружение.</li>
              <li>используют new Function когда код функции заранее не известен, а будет определен только в процессе выполнения.</li>
              <li>переданные явно глобальные аргументы не вызывают проблем у минификаторов.</li>
            </ul>
            <pre><code>let func = new Function([arg1, arg2, ...argN], functionBody);
let sum = new Function('a', 'b', return a+b);

// код полученный с сервера динамически
let str = "https://server/srvcode";
let func = new Function(str);
func();</code></pre>
            <p>Функции-конструкторы (Конструкторы)</p>
            <ul>
              <li>имя с заглавной буквы.</li>
              <li>вызывается при помощи оператора new.</li>
              <li>используется для повторного создания однотипных объектов.</li>
              <li>при вызове создаёт пустой this в начале и возвращает заполненный (свойства и их значения) в конце.</li>
              <li>this - обозначает текущий объект.</li>
            </ul>
            <pre><code>// явно добавляет свойства к this
this = {};

// неявно
return this;

// выполняет роль класса, сама функция ничего не возвращает
function User(name) {
  this.name = name;            
  this.isAdmin = false;
}                                
let user = new User("Вася");

// создаю конструктором новый объект Вася и вывожу в консоль
function SomeFuncCon(name, age) {
  this.name = name;
  this.age = age;
}
console.log(new SomeFuncCon('Vasya', 30));</code></pre>
            <p>Или</p>
            <pre><code>function Cat(color, name) {
  this.color = color;
  this.name = name;
}

const cat = new Cat('black', 'Кот');

// Cat {color:'black', name: 'Кот'}
console.log(cat);

// присвоит cat undefined, т.к. Cat() ничего не возвращает
const cat = Cat();

// присвоит cat - Cat{color: undefined, name: undefined}, т.к. нет входных аргументов
const cat = new Cat();

// создать своё ключевое слово new
function myNew(constructor, ...args) {

  // new всегда возвращает новый объект
  const obj = {};

  // установить в поле prototype объекта переданную в аргументах constructor-ссылку, теперь constructor прототип obj
  // obj имеет доступ ко всем полям constructor
  Object.setPrototypeOf(obj.constructor.prototype)

  // выполнить конструктор в контексте obj с аргументами args или в случае ошибки вернуть obj
  return constructor.apply(obj, args) || obj;
}

// выполнить ключевое слово myNew c constructor в контексте Cat и аргументами 'black' и 'Кот'
const cat = myNew(Cat, 'black', 'Кот');

// Cat {color:'black', name:'Кот'}
console.log(cat);</code></pre>
            <p>планирование вызова функции</p>
            <ul>
              <li>setTimeout - (функция или код, задержка, параметр, параметр) - вызывает функцию один раз через какое-то время.</li>
              <li>setInterval - (функция или код, задержка, параметр, параметр) - вызывает функцию много раз через интервал времени.</li>
              <li>если setTimeout вызывать из setTimeout (рекурсия), то получим setInterval.</li>
              <li>clearInterval тоже самое что и setInterval.</li>
            </ul>
            <pre><code>let timeId = setTimeout(someFunc, param, param);

// прерывание setTimeout
setInterval(timeId);</code></pre>
            <p>Контекст</p>
            <ul>
              <li>объект, который передают при вызове и который указывает с каким объектом работает вызываемая функция.</li>
              <li>ключевое слово function создаёт свой контекст, к которому нужно привязать объект (this), с которым работает функция.</li>
            </ul>
            <p>Контекст выполнения - специальная внутренняя структура данных, которая содержит информацию о вызове функции</p>
            <ul>
              <li>место в коде, где находится интерпретатор.</li>
              <li>локальные переменные функции.</li>
              <li>значение this.</li>
              <li>прочая служебная информация.</li>
            </ul>
            <p>Привязка контекста bind</p>
            <ul>
              <li>при передаче методов объекта в качестве колбэков, например в setTimeout, метод передаётся отдельно от объекта, происходит потеря this.</li>
              <li>встроенный в функции метод bind позволяет зафиксировать this.</li>
              <li>частичная или частично применённая функция - это функция с привязанными аргументами.</li>
            </ul>
            <pre><code>// в отличии от call и apply, bind не вызывает метод knows на выполнение
person.knows.bind(john, 'ничего не', 'Джон');

// а возвращает новый объект, который нужно вызвать как функцию (), чтобы передать вызов в knows и установить this = john
const bound = person.knows.bind(john, 'ничего не', 'Джон');
bound();</code></pre>
            <pre><code>let bound = func.bind(context, [arg1], [arg2], ...);</code></pre>
            <p>явная привязка контекста</p>
            <pre><code>function logThis() {
  console.log(this)
}

const obj = {num: 42};

// консоль выведет {num: 42}
logThis.apply(obj); {num: 42}

// консоль выведет {num: 42}
logThis.call(obj); {num: 42}

// консоль выведет {num: 42}
logThis.bind(obj)(); {num: 42}</code></pre>
            <p>неявная привязка контекста</p>
            <pre><code>const animal = {
  legs: 4,
  logThis: function() {
    console.log(this);
  }
}

// {legs: 4, logThis:[Function: logThis]}, в контекст привязался тот объект, в котором была вызвана функция
animal.logThis();</code></pre>
          </details>
          <details> 
            <summary>Методы</summary>
            <ul>
              <li>это функции как свойства объекта.</li>
              <li>методы ссылаются на объект через this для доступа к информации внутри объекта.</li>
              <li>значение this вычисляется во время выполнения кода (когда функция вызвана) и зависит от контекста.</li>
              <li>функция может быть скопирована между объектами (из одного объекта в другой).</li>
              <li>значением this во время вызова синтаксисом 'метода' (object.method()) является объект перед точкой.</li>
              <li>у стрелочных функций нет this, его значение берётся из внешней функции.</li>
              <li>для работы вызовов типа user.hi(), точка возвращает не саму функцию,а специальное значение 'ссылочного типа' - Reference Type.</li>
            </ul>
            <p>Значение ссылочного типа - это "триплет", комбинация из трёх значений</p>
            <ul>
              <li>base - объект.</li>
              <li>name - имя свойства объекта.</li>
              <li>strict - режим исполнения (true если 'use strict').</li>
            </ul>
            <pre><code>(user, "hi", true)</code></pre>
            <p>когда скобки () применяются к значению ссылочного типа, они получают полную информацию об объекте и его методе, и могут подставить правильный this</p>
            <pre><code>obj.method()</code></pre>
            <p>
              Ссылочный тип - исключительно внутренний, промежуточный, используется чтобы передать информацию от точки до вызывающих скобок ().<br />
              При любой другой операции, например hi = user.hi, ссылочный тип заменяется на значение user.hi (метод hi объекта user), и дальше работа только с методом - без this.
              
            </p>
            <p>
              Замыкание - это функция, которая помнит лексическое окружение где она была создана (свои внешние переменные) и может получить к нему доступ с помощью скрытого свойства [[Environment]].<br />
              Все функции, кроме newFunction(), изначально являются замыканиями.
            </p>
            <pre><code>function sayHelloTo(name) {
  const message = 'Hello' + name;

  // анонимная функция
  return function() {
    console.log(message);
  }
}

// helloToElena ссылается на анонимную функцию
const helloToElena = sayHelloTo('Elena');

// helloToIgor ссылается на анонимную функцию
const helloToIgor = sayHelloTo('Igor');

// Hello Elena
helloToElena();

// Hello Igor
helloToIgor();

const fib = [1, 2, 3, 5, 8, 13];

// через 1,5 секунды должен вывести индекс = значение
for (var i=0; i < fib.length; i++) {
  setTimeout(function() {

    // но за 1,5 секунды цикл успевает пробежать по всей длине массива и var i уже равно 6
    console.log(`fib[${j}] = ${fib[j]}`)

  // только потом срабатывает setTimeout
  }, 1500)
}

// исправление через область видимости
const fib = [1, 2, 3, 5, 8, 13];

// поменять var на let, т.к. let действует только в области видимости цикла
for (let i=0; i < fib.length; i++) {
  setTimeout(function() {
    console.log(`fib[${j}] = ${fib[j]}`)
  }, 1500)
}

const fib = [1, 2, 3, 5, 8, 13];

// исправление через замыкание
for (var i=0; i < fib.length; i++) {

  // обернуть setTimeout в функцию и через ()()(IIFE) замкнуть функцию на var i
  (function(j) {
    setTimeout(function() {
      console.log(`fib[${j}] = ${fib[j]}`)
    }, 1500)
  })(i)
}</code></pre>
            <p>
              someObj.someFunc(); - ошибка, anotherFunc() создает свою область видимости и замыкается (использует) область видимости someFunc(),<br />
              this ищет свойство key1 в области видимости someFunc().
            </p>
            <pre><code>let someObj = {
  key1: value1,

  someFunc() {
    function anotherFunc() {console.log(`${this.key1}`)}

    anotherFunc();
  }
};</code></pre>
            <p>
              someObj.someFunc(); - стрелочная функция не создает свою область видимости и пользуется всем что есть у someFunc(),<br />
              т.е. области видимости someFunc() и someObj, this находит свойство key1 в области видимости someObj.
            </p>
            <pre><code>let someObj = {
  key1: value1,

  someFunc() {
    let someVar = () => console.log(`${this.key1}`)

    someVar();
  }
};</code></pre>
            <p>Перенапрвление вызова (call forwarding) - передача всех аргументов вместе с контекстом другой функции</p>
            <p>call и apply - встроенные методы функции, позволяют вызывать функцию, явно устанавливая this</p>
            <ul>
              <li>call принимает перебираемый объект args в виде списка от оператора расширения ...</li>
              <li>apply принимает только псевдомассив args.</li>
            </ul>
            <pre><code>const person = {
  surname: 'Старк',
  knows: function(what, name) {
    console.log(`Ты ${what} знаешь, ${name} ${this.surname}`)
  }
}

// функция работает в контексте (this) объекта person
const john = {surname: 'Сноу'}

// Ты всё знаешь Бран Старк
person.knows('всё', 'Бран')</code></pre>
            <p>чтобы перенаправить вызов, функцию knows не вызываем (), а обращаемся к ней как к объекту и вызываем её метод call(), в который передаём объект (this), в контексте которого она должна отработать и аргументы самой функции knows</p>
            <table> 
              <tbody> 
                <tr>
                  <td>person.knows.call(john, 'ничего не', 'Джон');     </td>
                  <td>Ты ничего не знаешь, Джон Сноу</td>
                </tr>
                <tr>
                  <td>person.knows.apply(john, ['ничего не', 'Джон']);  </td>
                  <td>аргументы в виде массива</td>
                </tr>
                <tr>
                  <td>person.knows.call(john, ...['ничего не', 'Джон']);</td>
                  <td>ES-6 синтаксис - оператор спред (...) разворачивает массив</td>
                </tr>
              </tbody>
            </table>
            <p>Заимствование метода</p>
            <pre><code>function hash (args) {
  // функция делает ключ-строку из принимаемых аргументов
  return args[0] + ',' + args[1];
}

function hash (args) {
  // позаимствовал join у массива
  alert([].join.call(args));
}</code></pre>
          </details>
          <details> 
            <summary>Event loop</summary>
            <p>Event loop - событийный цикл (бесконечный)</p>
            <ul>
              <li>Выполнить старейшую задачу из очереди макрозадач: setTimeout(f) с нулевой задержкой добавляет в очередь новую макрозадачу.</li>
              <li>Выполнить старейшую задачу из очереди макрозадач: queuemicrotask(f) - добавляет в очередь новую микрозадачу.</li>
              <li>Отрисовать изменения страницы (если есть).</li>
              <li>Если очередь макрозадач пуста - подождать, когда появится макрозадача.</li>
            </ul><img src="./assets/img/contimg/eventLoop.png" alt="" loading="lazy"/>
            <p>Сразу после каждой макрозадачи: все микрозадачи -> события -> рендеринг -> макрозадача</p>
            <ul>
              <li>очередь - (queue) добавляем в конец, извлекаем с начала.</li>
              <li>стек - (stack) новые элементы всегда добавляются или удаляются с конца.</li>
            </ul>
            <p>Web workers</p>
            <ul>
              <li>способ исполнить код в параллельном потоке.</li>
              <li>обмениваются сообщениями с основным процессом.</li>
              <li>имеют свои переменные и свой событийный цикл.</li>
              <li>позволяют задействовать несколько ядер процессора сразу.</li>
              <li>не имеют доступа к DOM.</li>
              <li>используются для длительных тяжёлых вычислений, которые не должны блокировать событийный цикл.</li>
            </ul>
          </details>
          <details> 
            <summary>Коллекции</summary>
            <p>Итерируемые объекты</p>
            <ul>
              <li>объекты, которые реализуют метод Symbol.iterator, и их можно использовать в цикле for..of</li>
              <li>итерацией управляет итератор - результат вызова obj[Symbol.iterator]</li>
              <li>метод Symbol.iterator автоматически вызывается циклом for..of, но можно вызвать его и напрямую</li>
              <li>строковый итератор знает про сурогатные пары</li>
              <li>метод toString возвращает список элементов, разделённых запятыми</li>
              <li>итератор должен иметь метод next(), который возвращает объект {done: true, value: any}</li>
              <li>done: true - окончание итерации, иначе value - следующее значение</li>
            </ul>
            <p>Строка</p>
            <pre><code>' ', " ", `${}`

let str = "Какое-то \n предложение \n\t тут";
\n   // перевод строки
\t   // табуляция (отступ)
\    // экранирование
${}  // вставить JS код в строку

let someText = "text";

// длина строки
console.log(someText.length);

// получаем символ строки
let firstSymbol = someText[0];

// последний символ строки
let lastSymbol = someText[someText.length-1];

// перебирает символы строки
for (const char of someText) {
  console.log(char);
}

// все буквы большие
someText.toUpperCase()

// все буквы маленькие
someText.toLowerCase()

// ищет подстроку substr в строке someText, pos - необязательный, символ с которого искать
someText.indexOf(substr, pos)

// возвращает часть строки без end
slice(start, end)

// проверяет на наличие, возвращает true или false
includes(substr, pos), startsWith(substr), endsWith(substr)</code></pre>
            <p>Регулярные выражения</p>
            <ul>
              <li>средство поиска и замены в строке</li>
              <li>реализовано объектом RegExp и интегрировано в методы строк</li>
              <li>состоит из шаблона «паттерн» и необязательных флагов</li>
            </ul>
            <pre><code>// создать
regexp = new RegExp("шаблон", "флаги");

// без флагов
regexp = /шаблон/;

// с флагами gmi
regexp = /шаблон/gmi;

либо динамически
let tag = prompt("Какой тег найти?", "h2");

// то же, что /< h2>/  при ответе "h2" на prompt выше
let regexp = new RegExp(`<${tag}>`);</code></pre>
            <table> 
              <caption>специальные символы</caption>
              <tbody> 
                <tr>
                  <td>0b11111111</td>
                  <td>бинарная (двоичная) форма записи числа 255</td>
                </tr>
                <tr>
                  <td>0о377     </td>
                  <td>восьмеричная форма записи числа 255</td>
                </tr>
                <tr>
                  <td>0xff      </td>
                  <td>шестнадцатеричная форма записи числа 255</td>
                </tr>
                <tr>
                  <td>.</td>
                  <td>точка, любой символ кроме новой строки \n (с флагом s и символ новой строки тоже)</td>
                </tr>
                <tr>
                  <td>^</td>
                  <td>циркумфлекс, значение начинается с указанной подстроки</td>
                </tr>
                <tr>
                  <td>$</td>
                  <td>доллар, значение заканчивается указанной подстрокой</td>
                </tr>
                <tr>
                  <td>~</td>
                  <td>тильда, значение содержит указанное слово</td>
                </tr>
                <tr>
                  <td>+</td>
                  <td>плюс, один или более</td>
                </tr>
                <tr>
                  <td>*</td>
                  <td>звезда, значение содержит указанную подстроку</td>
                </tr>
                <tr>
                  <td>!</td>
                  <td>восклицательный знак, значение без указанной подстроки</td>
                </tr>
                <tr>
                  <td>?</td>
                  <td>
                    вопросительный знак, ноль или один
                    ()? - необязательная группа  
                    ?: - не запоминать в результат  
                    +? - ленивый режим  
                    ?= - позитивная опережающая проверка  
                    ?! - негативная опережающая проверка
                    ?<= - позитивная ретроспективная проверка  
                    ?<! - негативная ретроспективная проверка  
                  </td>
                </tr>
                <tr>
                  <td>|</td>
                  <td>вертикальная черта, значение содержит указанное слово или после этого слова знак дефиса</td>
                </tr>
                <tr>
                  <td>\</td>
                  <td>обратная косая черта, экранирование</td>
                </tr>
                <tr>
                  <td>( )</td>
                  <td>круглые скобки, скобочная группа</td>
                </tr>
                <tr>
                  <td>{n}</td>
                  <td>фигурные скобки, сколько повторений искать</td>
                </tr>
                <tr>
                  <td>[ ]</td>
                  <td>
                    квадратные скобки,
                    набор [eao]      - любой из 3-х символов: 'a', 'e' или 'o'
                    диапазон [a-z]   - символ в диапазоне от a до z
                    [^aeyo]          – любой символ, за исключением 'a', 'e', 'y' или 'o'
                    [-().^+]         - ищет один из символов -().^+
                  </td>
                </tr>
              </tbody>
            </table>
            <table>
              <caption>Символьный класс - обозначение, которое соответствует любому символу из набора</caption>
              <tbody> 
                <tr>
                  <td>\d</td>
                  <td>цифра: символ от 0 до 9</td>
                </tr>
                <tr>
                  <td>\D</td>
                  <td>не цифра: любой символ, кроме \d, например буква</td>
                </tr>
                <tr>
                  <td>\s</td>
                  <td>пробельные символы: символ пробела, табуляции \t, перевода строки \n и редкие пробельные символы \v, \f и \r</td>
                </tr>
                <tr>
                  <td>\S</td>
                  <td>не пробел: любой символ, кроме \s, например буква</td>
                </tr>
                <tr>
                  <td>\w</td>
                  <td>буква латинского алфавита или подчёркивание _</td>
                </tr>
                <tr>
                  <td>\W</td>
                  <td>любой символ, кроме \w, то есть не буквы из латиницы, не знак подчёркивания. Русские буквы принадлежат этому классу</td>
                </tr>
                <tr>
                  <td>\w</td>
                  <td>искать слово в строке (с флагом g все слова)</td>
                </tr>
              </tbody>
            </table>
            <table> 
              <caption>Юникодные свойства \p{…}, категории символов и их подкатегории</caption>
              <tbody> 
                <tr>
                  <td>буквы L</td>
                  <td>в нижнем регистре Ll, модификаторы Lm, заглавные буквы Lt, в верхнем регистре Lu, прочие Lo</td>
                </tr>
                <tr>
                  <td>числа N</td>
                  <td>десятичная цифра Nd, цифры обозначаемые буквами (римские) Nl, прочие No</td>
                </tr>
                <tr>
                  <td>отметки M (например, акценты)</td>
                  <td>двоеточия Mc, вложения Me, апострофы Mn</td>
                </tr>
                <tr>
                  <td>символы S</td>
                  <td>валюты Sc, модификаторы Sk, математические Sm, прочие So</td>
                </tr>
                <tr>
                  <td>разделители Z</td>
                  <td>линия Zl, параграф Zp, пробел Zs</td>
                </tr>
                <tr>
                  <td>прочие C</td>
                  <td>контрольные Cc, форматирование Cf, не назначенные Cn, для приватного использования Co, суррогаты Cs</td>
                </tr>
                <tr>
                  <td>знаки пунктуации P</td>
                  <td>соединители Pc, тире Pd, открывающие кавычки Pi, закрывающие кавычки Pf, открывающие скобки Ps, закрывающие скобки Pe, прочее Po</td>
                </tr>
              </tbody>
            </table>
            <table> 
              <caption>флаги</caption>
              <tbody> 
                <tr>
                  <td>i</td>
                  <td>поиск без регистра: нет разницы между A и a</td>
                </tr>
                <tr>
                  <td>g</td>
                  <td>ищет все совпадения, без него – только первое</td>
                </tr>
                <tr>
                  <td>m</td>
                  <td>многострочный режим</td>
                </tr>
                <tr>
                  <td>s</td>
                  <td>режим «dotall», в котором точка . соответствует любому символу, в том числе новой строки \n</td>
                </tr>
                <tr>
                  <td>u</td>
                  <td>включает полную поддержку Юникода, регулярное выражение работает с 4-байтными символами правильно.</td>
                </tr>
                <tr>
                  <td>y</td>
                  <td>режим поиска на конкретной позиции в тексте</td>
                </tr>
                <tr>
                  <td>d</td>
                  <td>результат помещается в массив, содержащий дополнительную информацию о регулярном выражении, например индексы начала и конца подстрок</td>
                </tr>
              </tbody>
            </table>
            <p>Флаг d не меняет поведение регулярного выражения, а лишь предоставляет дополнительную информацию.  </p>
            <table> 
              <caption>методы строк</caption>
              <tbody> 
                <tr>
                  <td>regexp.exec(str)</td>
                  <td>ищет совпадение с regexp в строке str, вызывается на регулярном выражении, а не на строке, str.matchAll, удобнее</td>
                </tr>
                <tr>
                  <td>regexp.test(str)</td>
                  <td>проверяет, есть ли хоть одно совпадение, если да, то возвращает true, иначе false</td>
                </tr>
                <tr>
                  <td>str.match(regexp)</td>
                  <td>для строки str возвращает массив совпадений с регулярным выражением regexp, если совпадений нет - null</td>
                </tr>
                <tr>
                  <td>str.matchAll(regexp)</td>
                  <td>улучшенная версия str.match, возвращает перебираемый объект, если совпадений нет - пустой перебираемый объект</td>
                </tr>
                <tr>
                  <td>str.matchAll(regexp) с флагом g</td>
                  <td>возвращает каждое совпадение в виде массива со скобочными группами</td>
                </tr>
                <tr>
                  <td>str.split(regexp|substr, limit)</td>
                  <td>разбивает строку в массив по разделителю</td>
                </tr>
                <tr>
                  <td>str.search(regexp)</td>
                  <td>возвращает позицию первого совпадения с regexp в строке str или -1, если совпадения нет</td>
                </tr>
                <tr>
                  <td>str.replace(regexp, replacement)</td>
                  <td>заменяет совпадения с regexp в строке str на replacement (все, если есть флаг g, иначе только первое)</td>
                </tr>
              </tbody>
            </table>
            <table> 
              <caption>спецсимволы в replacement</caption>
              <tbody> 
                <tr>
                  <td>$&</td>
                  <td>вставляет всё найденное совпадение</td>
                </tr>
                <tr>
                  <td>$`</td>
                  <td>вставляет часть строки до совпадения</td>
                </tr>
                <tr>
                  <td>$'</td>
                  <td>вставляет часть строки после совпадения</td>
                </tr>
                <tr>
                  <td>$n</td>
                  <td>если n это 1-2 значное число, вставляет содержимое n-й скобочной группы регулярного выражения</td>
                </tr>
                <tr>
                  <td>$$</td>
                  <td>вставляет символ "$"</td>
                </tr>
                <tr>
                  <td>$< name ></td>
                  <td>вставляет содержимое скобочной группы с именем name</td>
                </tr>
              </tbody>
            </table>
            <pre><code>let str = "Я ЛюБлЮ JavaScript";
let regexp = /люблю/i;
alert( regexp.test(str) );                     // true

let str = `
  1е место: Вини
  2е место: Пятачок
  3е место: Слонопотам
`;                                             // начало строки - это после \n (перевод строки)
console.log( str.match(/^\d/gm) );             // 1, 2, 3       - начало каждой строки в тексте
console.log( str.match(/^\d/g) );              // 1             - без флага m только первое число

let str = `
  Вини: 1
  Пятачок: 2
  Слонопотам: 3
`;
console.log( str.match(/\d$/gm) );             // 1, 2, 3       - \d$ ищет последнюю цифру в каждой строке
console.log( str.match(/\d$/g) );              // 1             - без флага m только конец первой строки
console.log( str.match(/\d\n/g) );             // 1\n,2\n       - найти последний символ строки и символ перевода строки \n

let str = "+7(903)-123-45-67";
let regexp = /\d/g;
alert( str.match(regexp) );                    // массив совпадений: 7,9,0,3,1,2,3,4,5,6,7
alert( str.match(regexp).join('') );           // 79031234567
alert( str.replace(/\D/g, "") );               // 79031234567

let str = "A ბ ㄱ";                            // английская, грузинская и корейская буквы
alert( str.match(/\p{L}/gu) );                 // A,ბ,ㄱ
alert( str.match(/\p{L}/g) );                  // null (ничего не нашло, так как \p не работает без флага "u")

let regexp = /x\p{Hex_Digit}\p{Hex_Digit}/u;   // ищем шестнадцатеричные числа
alert("число: xAF".match(regexp));             // xAF

let regexp = /\p{sc=Han}/gu;                   // поиска символов в нужной системе \p{sc=Cyrillic}, Greek, Arabic, Han. Script=<значение>
let str = `Hello Привет 你好 123_456`;
alert( str.match(regexp) );                    // 你,好

let regexp = /\p{Sc}\d/gu;                     // валюта, за которой идёт цифра
let  str = `Цены: $2, €1, ¥9`;
alert( str.match(regexp) );                    // $2,€1,¥9


let str = 'let varName';
let regexp = /\w+/g;
alert(regexp.lastIndex);                       // 0 (при создании lastIndex=0)

let word1 = regexp.exec(str);
alert(word1[0]);                               // let (первое слово)
alert(regexp.lastIndex);                       // 3 (позиция за первым совпадением)

let word2 = regexp.exec(str);
alert(word2[0]);                               // varName (второе слово)
alert(regexp.lastIndex);                       // 11 (позиция за вторым совпадением)

let word3 = regexp.exec(str);
alert(word3);                                  // null (больше совпадений нет)
alert(regexp.lastIndex);                       // 0 (сбрасывается по окончании поиска)


let str = 'let varName';
let regexp = /\w+/g;
let result;

while (result = regexp.exec(str)) {
  alert( `Найдено ${result[0]} на позиции ${result.index}` );
  // Найдено let на позиции 0
  // Найдено varName на позиции 4
}


let str = 'let varName = "value"';
let regexp = /\w+/g;                           // без флага g свойство lastIndex игнорируется
regexp.lastIndex = 4;

let word = regexp.exec(str);
alert(word);                                   // varName

let str = 'let varName = "value"';
let regexp = /\w+/g;                           // при флаге g свойство lastIndex задаёт начальную позицию поиска
regexp.lastIndex = 3;

let word = regexp.exec(str);
alert(word[0]);                                // varName
alert(word.index);                             // 4

let str = 'let varName = "value"';
let regexp = /\w+/y;                           // при флаге y искать ровно на позиции lastIndex, ни до и ни после

regexp.lastIndex = 3;
alert( regexp.exec(str) );                     // null (на позиции 3 пробел, а не слово)

regexp.lastIndex = 4;
alert( regexp.exec(str) );                     // varName (слово на позиции 4)</code></pre>
            <p>
              жадный поиск (по умолчанию) ищет цифры один или более раз d+, пробел не цифра - поиск остановлен, ищет пока есть
              ленивый поиск ищет цифры один или более раз d+?, одну нашел и остановился, ищет минимально требуемое количество
            </p>
            <pre><code>// 123 4
alert( "123 456".match(/\d+ \d+?/) );

// жадный поиск
let regexp = /".+"/g;
let str = 'a "witch" and her "broom" is one';
// "witch" and her "broom"
alert( str.match(regexp) );

// ленивый поиск
let regexp = /".+?"/g;
let str = 'a "witch" and her "broom" is one';
// "witch","broom"
alert( str.match(regexp) );

// ищет шаблон - кавычка ", потом не кавычка один или более раз [^"]+, потом кавычка "
let regexp = /"[^"]+"/g;
let str = 'a "witch" and her "broom" is one';
// "witch","broom"
alert( str.match(regexp) );

// найти html или css или java, возможно javascript
let regexp = /html|css|java(script)?/gi;
let str = "Сначала появился язык Java, затем HTML, потом JavaScript";
// Java, HTML, JavaScript
alert( str.match(regexp) );</code></pre>
            <p>
              часы: [01]\d|2[0-3] - если первая цифра 0 либо 1, то потом любая или если первая цифра 2, то потом от 0 до 3
              минуты: [0-5]\d - первая цифра от 0 до 5, потом любая
            </p>
            <pre><code>let regexp = /([01]\d|2[0-3]):[0-5]\d/g;</code></pre>
            <pre><code>// 00:00, 10:10, 23:59
alert("00:00 10:10 23:59 25:99 1:2".match(regexp));

// позитивная опережающая проверка - найти Х, за которым следует Y
let str = "1 индейка стоит 30€";
// 30, число 1 проигнорировано, так как за ним НЕ следует €, шабло X(?=Y)
alert( str.match(/\d+(?=€)/) );
// 1, шаблон X(?=Y)(?=Z)
alert( str.match(/\d+(?=\s)(?=.*30)/) );

// негативная опережающая проверка опережающая проверка - найти Х, за которым не следует Y
let str = "2 индейки стоят 60€";
// 2
alert( str.match(/\d+(?!€)/) );

// знак доллара экранируем \$, так как это специальный символ
let str = "1 индейка стоит $30";
// 30, (?<=Y)X - позитивная ретроспективная проверка, найти Х когда перед ним Y
alert( str.match(/(?<=\$)\d+/) );

let str = "2 индейки стоят $60";
// 2, (?<!Y)X - негативная ретроспективная проверка, найти X когда перед ним НЕТ Y
alert( str.match(/(?<!\$)\d+/) );

let str = "1 индейка стоит 30€";
// добавил дополнительные скобки вокруг €|kr - включил в результат поиска
let regexp = /\d+(?=(€|kr))/;
// 30, €
alert( str.match(regexp) );

let str = "1 индейка стоит $30";
let regexp = /(?<=(\$|£))\d+/;
// 30, $
alert( str.match(regexp) );

// массив [12, 34, 56]
alert('12-34-56'.split('-'))
// массив [12, 34, 56]
alert('12, 34, 56'.split(/,\s*/))

let str = "Я люблю JavaScript!";
let regexp = /Java.+/;
// 8
alert( str.search(regexp) );

// 12:34-56 - заменить тире двоеточием
alert('12-34-56'.replace("-", ":"))
// 12:34:56 - заменить все тире двоеточием
alert( '12-34-56'.replace( /-/g, ":" ))

let str = 'Больше о JavaScript на https://javascript.info';
let regexp = /javascript/ig;
let result;
// повторные вызовы возвращают одно за другим все совпадения, используя свойство regexp.lastIndex
while (result = regexp.exec(str)) {
  alert( `Найдено ${result[0]} на позиции ${result.index}` );
  // Найдено JavaScript на позиции 9
  // Найдено javascript на позиции 31
}</code></pre>
            <p>скобочные группы</p>
            <ul>
              <li>alert('Gogogo now!'.match(/go+/ig)); : 'Ggooo' : ищет повторяющиеся символы g и o</li>
              <li>alert('Gogogo now!'.match(/(go)+/ig)); : 'Gogogo' : ищет повторяющиеся go</li>
              <li>let regexp = /(w+.)+w+/g; - (w+.) : поддомен с точкой</li>
              <li>alert('site.com my.site.com'.match(regexp)); : site.com, my.site.com</li>
              <li>let regexp = /[-.w]+@([w-]+.)+[w-]+/g; : [-.w]+ : любое слово, разрешены дефисы и точки</li>
              <li>alert('my@mail.com @ his@site.com.uk'.match(regexp)); : my@mail.com, his@site.com.uk</li>
              <li>let str='&lt;span class='my'&gt;';</li>
              <li>let regexp = /&lt;(([a-z]+)s*([^&gt;]*))&gt;/; : вложенные скобочные группы</li>
              <li>let result = str.match(regexp);</li>
              <li>alert(result[0]); : &lt;span class='my'&gt; : полное совпадение</li>
              <li>alert(result[1]); : span class='my' : первая скобочная группа, содержит вложенные</li>
              <li>alert(result[2]); : span : вторая скобочная группа</li>
              <li>alert(result[3]); : class='my' : третья скобочная группа</li>
              <li>let match = 'a'.match(/a(z)?(c)?/); : ищет букву 'a', за которой необязательная буква 'z', за которой необязательная буква 'c'</li>
              <li>alert( match.length ); : 3 : длина массива</li>
              <li>alert( match[0] ); : a : всё совпадение</li>
              <li>alert( match[1] ); : undefined : нет совпадения z</li>
              <li>alert( match[2] ); : undefined : нет совпадения c</li>
              <li>let match = 'ac'.match(/a(z)?(c)?/) : ищет букву 'a', за которой необязательная буква 'z', за которой необязательная буква 'c'</li>
              <li>alert( match.length ); : 3 : длина массива</li>
              <li>alert( match[0] ); : ac : всё совпадение</li>
              <li>alert( match[1] ); : undefined : нет совпадения z</li>
              <li>alert( match[2] ); : c : есть совпадение c</li>
              <li>let str = '&lt;h1&gt;Hello, world!&lt;/h1&gt;';</li>
              <li>let tag = str.match(/&lt;(.*?)&gt;/);</li>
              <li>alert( tag[0] ); : &lt;h1&gt; : всё совпадение целиком</li>
              <li>alert( tag[1] ); : h1 : содержимое скобочной группы</li>
              <li>let results = '&lt;h1&gt; &lt;h2&gt;'.matchAll(/&lt;(.*?)&gt;/gi);</li>
              <li>for(let result of results) { : перебирает объект в цикле</li>
              <li>alert(result);} : &lt;h1&gt;,h1 &lt;h2&gt;,h2</li>
              <li>let [tag1, tag2] = results; : деструктуризация перебираемого объекта</li>
              <li>alert( tag1[0] ); : &lt;h1&gt;</li>
              <li>alert( tag1[1] ); : h1</li>
              <li>alert( tag1.index ); : 0</li>
              <li>alert( tag1.input ); : &lt;h1&gt; &lt;h2&gt;</li>
              <li>let dateRegexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/; : у скобочных групп есть имена year, month, day</li>
              <li>let str = '2019-04-30';</li>
              <li>let groups = str.match(dateRegexp).groups; : группы располагаются в свойстве groups результата match</li>
              <li>alert(groups.year); : 2019</li>
              <li>alert(groups.month); : 04</li>
              <li>alert(groups.day); : 30</li>
              <li>let dateRegexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/g;</li>
              <li>let str = '2019-10-30 2020-01-01';</li>
              <li>let results = str.matchAll(dateRegexp);</li>
              <li>for(let result of results) {</li>
              <li>let {year, month, day} = result.groups;</li>
              <li>alert(`${day}.${month}.${year}`);} : 30.10.2019, 01.01.2020</li>
              <li>let str = 'John Bull';</li>
              <li>let regexp = /(w+) (w+)/;</li>
              <li>alert(str.replace(regexp, '$2, $1')); : Bull, John. Метод str.replace() использует в строке замены содержимое скобок: $номер_скобочной_группы</li>
              <li>alert(str.replace(/(w+) (w+)/i, '$2, $1')) : Bull, John</li>
              <li>let str = 'html and css';</li>
              <li>alert(str.replace(/html|css/gi, str =&gt; str.toUpperCase())); : HTML and CSS</li>
              <li>func(match, p1, p2, ..., pn, offset, input, groups)</li>
              <li>match : найденное совпадение</li>
              <li>p1, p2, ..., pn : содержимое скобок</li>
              <li>offset : позиция, на которой найдено совпадение</li>
              <li>input : исходная строка</li>
              <li>groups : объект с содержимым именованных скобок</li>
              <li>alert('Хо-Хо-хо'.replace(/хо/gi, (match, offset) =&gt; offset)); : 0-3-6 : заменить каждое совпадение на его позицию в строке</li>
              <li>let str = 'John Smith';</li>
              <li>Smith, John, match : всё совпадение, name и surname : содержимое скобок</li>
              <li>alert(str.replace(/(w+) (w+)/, (match, name, surname) =&gt; `${surname}, ${name}`));</li>
              <li>alert(str.replace(/(w+) (w+)/, (...match) =&gt; `${match[2]}, ${match[1]}`)); : если в регулярном выражении много скобочных групп</li>
              <li>let result = str.replace(/(?&lt;name&gt;w+) (?&lt;surname&gt;w+)/, (...match) =&gt; {</li>
              <li>let groups = match.pop();</li>
              <li>return `${groups.surname}, ${groups.name}`;}); : если используем именованные группы</li>
              <li>alert(result); : Smith, John</li>
              <li>let regexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/g;</li>
              <li>let str = '2019-10-30, 2020-01-01';</li>
              <li>alert(str.replace(regexp, '$&lt;day&gt;.$&lt;month&gt;.$&lt;year&gt;')); : 30.10.2019, 01.01.2020 : в строке замены содержимое скобок: $&lt;имя_скобочной_группы&gt;</li>
              <li>let str = 'Gogogo John!';</li>
              <li>let regexp = /(?:go)+ (w+)/i; : ?: исключает go из запоминания в результат</li>
              <li>let result = str.match(regexp);</li>
              <li>alert( result[0] ); : Gogogo John (полное совпадение)</li>
              <li>alert( result[1] ); : John</li>
              <li>alert( result.length ); : 2 (больше в массиве элементов нет)</li>
            </ul>
            <pre><code>let str = `He said: "She's the one!".`;
let regexp = /['"](.*?)['"]/g;

// "She"
alert(str.match(regexp));

let str = `He said: "She's the one!".`;

// обратиться к первой скобочной группе \1
let regexp = /(['"])(.*?)\1/g;

// "She's the one!" - скобочная группа (['"])
alert(str.match(regexp));

let str = `He said: "She's the one!".`;

//- обратиться к скобочной группе по имени
let regexp = /(?< quote>['"])(.*?)\k< quote>/g;

//- "She's the one!" скобочная группа < quote>
alert(str.match(regexp));</code></pre>
            <h3>Массив</h3>
            <ul>
              <li>подвид объектов для хранения упорядоченных коллекций, расширяют объекты свойством length и методами для работы с упорядоченными коллекциями данных.</li>
              <li>свойство length - это наибольший цифровой индекс плюс 1, самый простой способ очистить массив - это arr.length = 0.</li>
              <li>получить доступ к элементу arr[0] - синтаксис доступа по ключу (obj[key]), obj это arr, key - числовой индекс в массиве могут храниться элементы любого типа.</li>
              <li>намного быстрее объекта если работать с массивом не как с объектом, а как с упорядоченной коллекцией.</li>
              <li>свойства именовать цифрами (индексы - числа, а не строки).</li>
              <li>не создавать дыр, т.е. не оставлять свойства без значений (0: 'Вася', 1: , 2: 'Петя').</li>
              <li>не заполнять массив значениями в обратном порядке (с конца).</li>
            </ul>
            <p>создать массив:</p>
            <table>
              <tbody>
                <tr>
                  <td>let arr = [];</td>
                  <td>создать пустой массив</td>
                </tr>
                <tr>
                  <td>let arr = new Array();</td>
                  <td></td>
                </tr>
                <tr>
                  <td>let arr = newArray(2);</td>
                  <td>создать пустой массив на 2 пустых элемента.</td>
                </tr>
                <tr>
                  <td>let fruits = ["Яблоко", "Апельсин", "Слива"];</td>
                  <td></td>
                </tr>
                <tr>
                  <td>fruits[0]</td>
                  <td>получить элемент</td>
                </tr>
                <tr>
                  <td>fruits[2] = 'Груша';</td>
                  <td>заменить элемент с индексом 2</td>
                </tr>
                <tr>
                  <td>fruits[3] = 'Лимон';</td>
                  <td>добавить новый элемент</td>
                </tr>
                <tr>
                  <td>fruits.length</td>
                  <td>общее число элементов массива</td>
                </tr>
                <tr>
                  <td>alert(fruits);</td>
                  <td>вывести массив целиком</td>
                </tr>
                <tr>
                  <td>let arr = new Array();</td>
                  <td></td>
                </tr>
                <tr>
                  <td>let arr = [];</td>
                  <td></td>
                </tr>
                <tr>
                  <td>let arr = [el1, el2, el3,];</td>
                  <td>элементом массива может быть что угодно</td>
                </tr>
                <tr>
                  <td>arr[1]</td>
                  <td>обращение к элементу, индексация с 0</td>
                </tr>
                <tr>
                  <td>arr.length</td>
                  <td>длина массива</td>
                </tr>
                <tr>
                  <td>let arrNew = arr;</td>
                  <td>скопировал ссылку на массив</td>
                </tr>
                <tr>
                  <td>Array.isArray(arr)</td>
                  <td>возвращает true если arr это массив, иначе false</td>
                </tr>
                <tr>
                  <td>limit()</td>
                  <td>ограничивает количество элементов, которые попадут в массив, по умолчанию все</td>
                </tr>
              </tbody>
            </table>
            <p>деструктуризация</p>
            <ul>
              <li>позволяет разбивать объект или массив на переменные при присвоении.</li>
              <li>позволяет извлекать данные из вложенных объектов и массивов, если структура левой и правой сторон одинаковая.</li>
              <li>для объекта неупомянутые свойства копируются в объект rest.</li>
              <li>для массива первый элемент копируется в item1, второй в item2, остальные в массив rest.</li>
            </ul>
            <pre><code>let {prop: varName = default, ...rest} = object
let [item1 = default, item2, ...rest] = array</code></pre>
            <p>добавление/удаление элементов</p>
            <ul>
              <li>методы push/pop выполняются быстро, а shift/unshift - медленно.</li>
              <li>если какой-то из items является массивом, то берутся его элементы.</li>
              <li>если объект имеет свойство Symbol.isConcatSpreadable, то он обрабатывается concat как массив, т.е. вместо объекта добавляются его числовые свойства.</li>
              <li>массивы могут работать и как очередь и как стек.</li>
            </ul>
            <table> 
              <tbody> 
                <tr>
                  <td>push(...items)</td>
                  <td>добавляет элементы в конец</td>
                </tr>
                <tr>
                  <td>pop()</td>
                  <td>извлекает элемент с конца</td>
                </tr>
                <tr>
                  <td>shift()</td>
                  <td>извлекает элемент с начала</td>
                </tr>
                <tr>
                  <td>unshift(...items)</td>
                  <td>добавляет элементы в начало</td>
                </tr>
                <tr>
                  <td>delete arr[1]</td>
                  <td>удаление конкретного элемента</td>
                </tr>
                <tr>
                  <td>arr.splice(pos, count)</td>
                  <td>начиная с индекса pos удалить count элементов (pos - считаем сначала, -pos - считаем с конца)</td>
                </tr>
                <tr>
                  <td>let rm = arr.splice(pos, count);</td>
                  <td>начиная с индекса pos удалить count элементов и вернуть удаленные элементы в переменную</td>
                </tr>
                <tr>
                  <td>arr.splice(pos, count, elem);</td>
                  <td>начиная с индекса pos заменить count элементов на elem</td>
                </tr>
                <tr>
                  <td>arr.splice(pos, 0, elem1, elem2);</td>
                  <td>начиная с индекса pos добавить elem1, elem2</td>
                </tr>
                <tr>
                  <td>let arrNew = arr.slice();</td>
                  <td>копируем весь массив</td>
                </tr>
                <tr>
                  <td>let arrNew = arr.slice(1, 2);</td>
                  <td>копируем массив с индекса 1 до индекса 2, не включая позицию 2</td>
                </tr>
                <tr>
                  <td>let arrNew = arr.concat(elem);</td>
                  <td>копирует весь массив и добавляет в конец нового массива elem</td>
                </tr>
              </tbody>
            </table>
            <table> 
              <caption>поиск среди элементов</caption>
              <tbody> 
                <tr>
                  <td>arr.indexOf(elem, from);</td>
                  <td>ищет elem с индекса from, возвращает индекс найденного item или -1</td>
                </tr>
                <tr>
                  <td>arr.lastIndexOf(elem);</td>
                  <td>возвращает индекс найденного elem или -1, ищет справа налево</td>
                </tr>
                <tr>
                  <td>arr.includes(elem, from);</td>
                  <td>ищет elem с индекса from, возвращает true или false</td>
                </tr>
              </tbody>
            </table>
            <p>для массивов, элементы которых объекты</p>
            <pre><code>// ищет в объекте elem свойство по заданному условию, возвращает либо свойство либо undefined
let res = arr.find(function(elem, index, array) {
  return elem.prop === 18;
});

let res = arr.find(elem => elem.prop === 18);

// ищет в объекте elem свойство по заданному условию, возвращает либо индекс либо undefined
let res = arr.findIndex(elem => elem.prop === 18);

// ищет в объекте elem свойство по заданному условию, возвращает либо массив свойств либо undefined
let res = arr.filter(elem => elem.prop >= 18);</code></pre>
            <p>сортировка массива</p>
            <pre><code>function compareNum(a, b) {
  console.log(`Сравниваем ${a} и ${b}`);
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}
// сортирует массив по алгоритму функции compareNum, sort() - по возрастанию
console.log(arr.sort(compareNum));

function compareNum(a, b) {
  console.log(`Сравниваем ${a} и ${b}`);
  return a - b;
}
console.log(arr.sort(compareNum));

console.log(arr.sort((a, b) => a - b));

// меняет порядок элементов в массиве на обратный
arr.reverse()</code></pre>
            <p>преобразование массива</p>
            <pre><code>let str = 'elem1,elem2,elem3';
// строку в массив по указанному разделителю
let arr = str.split(';', limit);

let arr = ['elem1', 'elem2', 'elem3'];
// массив в строку с указанным разделителем
let res =  arr.join(';');

let arr = ['elem1', 'elem2', 'elem3'];
// массив в строку, разделитель всегда запятая
let res =  String(arr);</code></pre>
            <p>перебор элементов массива</p>
            <pre><code>for (i=0; i < arr.length; i++)

for (let var of arr) {}

// применяет функцию к каждому элементу массива и заменяет его результатом
let res = arr.map(function(elem, index, array) {});

// применяет функцию для каждого элемента массива
arr.foreach(function(elem, index, array) {
  console.log(`${elem} находится на ${index} позиции в ${array}`);
});

arr.forEach((elem, index, array) => {
  console.log(`${elem} находится на ${index} позиции в ${array}`);
});

let func = function(elem, index, array) {
  console.log(`${elem} находится на ${index} позиции в ${array}`);
};
arr.forEach(func);

// перебирает элементы массива и вычисляет значение на основе всего массива
let value = arr.reduce(   
  function(
    previousValue, // результат предыдущего вызова этой функции, равен initial при первом вызове функции
    elem,          // очередной элемент массива
    index,         // его индекс
    array          // сам массив
  ) {},
  [initial]
);

// так же как и reduce(), но справа на лево
reduceRight()</code></pre><img src="./assets/img/contimg/methods.jpg" alt="" loading="lazy"/>
            <p>Псевдомассив</p>
            <ul>
              <li>объекты, у которых есть индексы и свойство length.</li>
              <li>могут иметь свойства и методы, но у них нет встроенных методов массива.</li>
            </ul>
            <pre><code>// создаёт массив из итерируемого объекта или псевдомассива obj, затем к нему можно применить методы массивов
Array.from(
  obj,

  // необязательные аргументы позволяют применять функцию с задаваемым контекстом к каждому элементу
  [mapFn, thisArg]
)</code></pre>
            <p>Map & Set</p>
            <ul>
              <li>map - это коллекция пар (ключ: значение), что угодно может быть ключом, в том числе и объекты.</li>
              <li>set - это коллекция уникальных значений без ключей.</li>
              <li>есть методы и свойство size.</li>
              <li>перебор Map и Set всегда осуществляется в порядке добавления элементов, поменять порядок элементов или получить элемент напрямую по номеру нельзя.</li>
            </ul>
            <table> 
              <caption>Методы и свойства</caption>
              <tbody> 
                <tr>
                  <td>let obj = Object.fromEntries(map)</td>
                  <td>создаёт объект из map</td>
                </tr>
                <tr>
                  <td>Object.entries(obj)</td>
                  <td>создаёт map из обычного объекта</td>
                </tr>
                <tr>
                  <td>newMap([iterable])</td>
                  <td>создаёт коллекцию, можно указать перебираемый объект (обычно массив) из пар [ключ, значение] для инициализации</td>
                </tr>
                <tr>
                  <td>map.set(key.value)</td>
                  <td>записывает по ключу key значение value</td>
                </tr>
                <tr>
                  <td>map.get(key)</td>
                  <td>возвращает значение по ключу или undefined, если ключа нет</td>
                </tr>
                <tr>
                  <td>map.has(key)</td>
                  <td>возвращает true, если ключ key присутствует в коллекции, иначе false</td>
                </tr>
                <tr>
                  <td>map.delete(key)</td>
                  <td>удаляет элемент по ключу key</td>
                </tr>
                <tr>
                  <td>map.clear()</td>
                  <td>очищает коллекцию от всех элементов</td>
                </tr>
                <tr>
                  <td>map.size</td>
                  <td>возвращает текущее количество элементов</td>
                </tr>
                <tr>
                  <td>map.keys()</td>
                  <td>возвращает итерируемый объект по ключам</td>
                </tr>
                <tr>
                  <td>map.values()</td>
                  <td>возвращает итерируемый объект по значениям</td>
                </tr>
                <tr>
                  <td>map.entries()</td>
                  <td>возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of</td>
                </tr>
                <tr>
                  <td>newSet([iterable])</td>
                  <td>создаёт Set, можно указать перебираемый объект со значениями без инициализации</td>
                </tr>
                <tr>
                  <td>set.add(value)</td>
                  <td>добавляет значение если такого нет, возвращает тот же объект</td>
                </tr>
                <tr>
                  <td>set.delete(value)</td>
                  <td>удаляет значение, возвращает true если value было, иначе false</td>
                </tr>
                <tr>
                  <td>set.has(value)</td>
                  <td>возвращает true, если значение есть, иначе false</td>
                </tr>
                <tr>
                  <td>set.clear()</td>
                  <td>удаляет все значения</td>
                </tr>
                <tr>
                  <td>set.size</td>
                  <td>возвращает количество элементов в множестве</td>
                </tr>
                <tr>
                  <td>set.values()</td>
                  <td>возвращает перебираемый объект для значений</td>
                </tr>
                <tr>
                  <td>set.keys()</td>
                  <td>то же самое, что и set.values(), нужен для обратной совместимости с Map</td>
                </tr>
              </tbody>
            </table>
            <p>WeakMap & WeakSet</p>
            <ul>
              <li>weakMap - map коллекция, где ключи только объекты, автоматически удаляемые вместе со значениями как только они становятся недостижимыми.</li>
              <li>weakSet - Set коллекция, которая хранит только объекты и удаляет их, как только они становятся недостижимыми.</li>
              <li>weakMap и weakSet поддерживают операции только на отдельном элементе коллекции.</li>
            </ul>
            <table>
              <caption>Методы</caption>
              <tbody> 
                <tr>
                  <td>weakMap.get(key)</td>
                  <td>weakSet.get(key)</td>
                </tr>
                <tr>
                  <td>weakMap.set(key, value)</td>
                  <td>weakSet.set(key, value)</td>
                </tr>
                <tr>
                  <td>weakMap.delete(key)</td>
                  <td>weakSet.delete(key)</td>
                </tr>
                <tr>
                  <td>weakMap.has(key)</td>
                  <td>weakSet.has(key)</td>
                </tr>
              </tbody>
            </table>
          </details>
          <details> 
            <summary>Window</summary><img src="./assets/img/contimg/windowJS.png" alt="" loading="lazy"/>
            <ul>
              <li>Object &lt;- EventTarget &lt;- Window - интерфейс Window наследует свойства интерфейса EventTarget.</li>
              <li>интерфейс Window реализует свойства из WindowOrWorkerGlobalScope и миксин WindowEventHandlers.</li>
              <li>объект window реализует интерфейс Window = globalThis + DOM + BOM - глобальный объект JS в браузере.</li>
              <li>browser Object Model (BOM) - объектная модель браузера.</li>
              <li>у каждого окна и у каждой вкладки свой объект window, глобальные функции доступны как методы глобального объекта.</li>
            </ul>
            <table>
              <caption>свойства window: все координаты в контексте окна считаются от верхнего левого угла</caption>
              <tbody> 
                <tr>
                  <td>window.opener</td>
                  <td>ссылка на открывающее окно</td>
                </tr>
                <tr>
                  <td>window.closed</td>
                  <td>true (закрыто), false (открыто)</td>
                </tr>
                <tr>
                  <td>window.frames</td>
                  <td>коллекция объектов window вложенных ифреймов</td>
                </tr>
                <tr>
                  <td>window.parent</td>
                  <td>ссылка на родительское окно</td>
                </tr>
                <tr>
                  <td>window.top</td>
                  <td>ссылка на окно самого верхнего уровня</td>
                </tr>
                <tr>
                  <td>window.innerWidth</td>
                  <td>ширина окна с полосой прокрутки</td>
                </tr>
                <tr>
                  <td>window.innerHeight</td>
                  <td>высота окна с полосой прокрутки</td>
                </tr>
                <tr>
                  <td>window.pageYOffset</td>
                  <td>количество пикселей прокрученных сверху</td>
                </tr>
                <tr>
                  <td>window.pageXOffset</td>
                  <td>количество пикселей прокрученных слева</td>
                </tr>
                <tr>
                  <td>window.scrollY</td>
                  <td></td>
                </tr>
                <tr>
                  <td>window.navigator</td>
                  <td>информация о браузере пользователя</td>
                </tr>
                <tr>
                  <td>window.screen</td>
                  <td>информация об экране пользователя</td>
                </tr>
                <tr>
                  <td>window.location</td>
                  <td>адресная строка: текущие компоненты</td>
                </tr>
                <tr>
                  <td>window.frames</td>
                  <td>фреймы и ифреймы</td>
                </tr>
                <tr>
                  <td>window.history</td>
                  <td>история посещений (url), движения вперед и назад в окне</td>
                </tr>
                <tr>
                  <td>window.XMLHttp Request</td>
                  <td>встроенный объект для Http запросов к серверу без перезагрузки страницы</td>
                </tr>
                <tr>
                  <td>window.document</td>
                  <td>DOM-документ загруженный в окно</td>
                </tr>
                <tr>
                  <td>position: fixed;</td>
                  <td>для координат относительно окна</td>
                </tr>
                <tr>
                  <td>position: absolute;</td>
                  <td>для координат относительно документа</td>
                </tr>
              </tbody>
            </table>
            <pre><code>function sayHi() {alert('Hello');}
window.sayHi();</code></pre>
            <table> 
              <caption>методы window</caption>
              <tbody> 
                <tr>
                  <td>open (url, name, params)</td>
                  <td>открывает новое окно и возвращает ссылку на него</td>
                </tr>
                <tr>
                  <td>close()</td>
                  <td></td>
                </tr>
                <tr>
                  <td>focus()</td>
                  <td></td>
                </tr>
                <tr>
                  <td>blur()</td>
                  <td></td>
                </tr>
                <tr>
                  <td>alert("Hello")</td>
                  <td>показывает сообщение</td>
                </tr>
                <tr>
                  <td>result = prompt(title, [default]);</td>
                  <td>сообщение с вводом текста, вернёт напечатанный в поле ввода текст или null</td>
                </tr>
                <tr>
                  <td>result = confirm (question);</td>
                  <td>сообщение с кнопками ОК или Отмена, вернёт true если нажата ОК и false - если отмена</td>
                </tr>
                <tr>
                  <td>iframe.contentWindow</td>
                  <td>объект window внутри тега < iframe></td>
                </tr>
                <tr>
                  <td>window.scroll(x, y);</td>
                  <td>прокручивает страницу на абсолютные координаты</td>
                </tr>
                <tr>
                  <td>window.scrollTo(x, y)</td>
                  <td>прокручивает страницу на абсолютные координаты</td>
                </tr>
                <tr>
                  <td>window.scrollBy(x, y)</td>
                  <td>прокрутка относительно текущего места</td>
                </tr>
                <tr>
                  <td>window.scrollIntoView(top)</td>
                  <td>прокрутить страницу, чтобы elem стал видимым (выровнять относительно верхней/нижней части окна)</td>
                </tr>
                <tr>
                  <td>window.getSelection()</td>
                  <td>получит выделение в документе</td>
                </tr>
              </tbody>
            </table>
          </details>
          <details> 
            <summary>Storage</summary>
            <p>
              localStorage и sessionStorage - объекты вэб-хранилища, позволяют хранить пары ключ/значение в браузере.<br />
              localStorage - используется между всеми вкладками и окнами одного источника совместно. Переживает перезапуск браузера.<br />
              sessionStorage - разделяется в рамках вкладки браузера, среди инфреймов из того же источника. Переживает перезагрузку страницы, но не закрытие вкладки.
            </p>
            <ul>
              <li>key и value - строки.</li>
              <li>лимит 2 Mb - зависит от браузера.</li>
              <li>данные не имеют срока хранения.</li>
              <li>данные привязаны к источнику (домен/протокол/порт).</li>
            </ul>
            <p>API storage</p>
            <table> 
              <tbody> 
                <tr>
                  <td>setItem(key, value)</td>
                  <td>сохранить пару ключ/значение</td>
                </tr>
                <tr>
                  <td>getItem(key)</td>
                  <td>получить данные по ключу key</td>
                </tr>
                <tr>
                  <td>removeItem(key)</td>
                  <td>удалить значение по ключу key</td>
                </tr>
                <tr>
                  <td>clear()</td>
                  <td>удалить всё</td>
                </tr>
                <tr>
                  <td>key(index)</td>
                  <td>получить ключ по заданной позиции</td>
                </tr>
                <tr>
                  <td>length</td>
                  <td>количество элементов в хранилище</td>
                </tr>
                <tr>
                  <td>Object.keys</td>
                  <td>получить все ключи</td>
                </tr>
              </tbody>
            </table>
            <p>
              Если обращаться к ключам как к обычным свойствам объекта, то событие storage не срабатывает.<br />
              событие storage:
            </p>
            <ul>
              <li>срабатывает при вызове setItem, removeItem, clear.</li>
              <li>содержит все данные о произошедшем обновлении (key/oldValue/newValue), url документа и объект хранилища storageArea.</li>
              <li>срабатывает на всех объектах window, которые имеют доступ к хранилищу, кроме того где оно было сгенерировано (внутри вкладки для sessionStorage, глобально для localStorage).</li>
            </ul>
            <p>
              IndexedDB - встроенная база данных типа ключ-значение, мощнее localStorage.<br />
              Интерфейс для IndexedDB основан на событиях IndexedDB имеет встроенный механизм версионирования схемы, который отсутствует в серверных базах данных.<br />
              IndexedDB работает на стороне клиента (в браузере) и у нас нет прямого доступа к данным.<br />
              При публикации новой версии приложения возможно обновлять базу данных.
            </p>
            <ul>
              <li>подключить обёртку над промисами (idb).</li>
              <li>открыть базу данных: idb.openDb(name, version, onupgradeneeded).</li>
              <li>создание хранилищ объектов и индексов в обработчике onupgradeneeded.</li>
              <li>обновление версии - либо сравнивая номера версий, либо проверить что есть, а что нет.</li>
              <li>создать транзакцию db.transaction('books') - можно указать readwrite.</li>
              <li>получить хранилище объектов transaction.objectStore('books').</li>
              <li>для поиска по ключу вызвать метод непосредственно у хранилища объектов.</li>
              <li>для поиска по любому полю объекта нужно создать индекс.</li>
            </ul>
          </details>
          <details> 
            <summary>DOM</summary>
            <p>
              Document Object Model (DOM) - объектная модель документа, представляет всё содержимое страницы в виде объектов.<br />
              Document - интерфейс доступа к узлам, его реализует объект document - объект DOM, входная точка в DOM.
            </p>
            <ul>
              <li>Object &lt;- EventTarget &lt;- Node &lt;- Document.</li>
              <li>html-документы представлены в браузере в виде дерева DOM.</li>
              <li>веб-воркер — это JavaScript, который работает в фоновом режиме, независимо от других скриптов, не влияя на производительность страницы.</li>
            </ul>
            <p>Node - абстрактный класс, обеспечивает базовую функциональность для всех узлов, объекты класса Node никогда не создаются, но от него наследуются.</p>
            <ul>
              <li>когда браузер загружает страницу, он читает (парсит) HTML и генерирует DOM-узлы.</li>
              <li>DOM-узлы - это обычные JS объекты, реализация соответствующего класса. DOM-элемент - это JS объект тэга.</li>
              <li>каждый DOM-узел принадлежит своему классу, классы формируют иерархию.</li>
              <li>для наследования используют классы, основанные на прототипах, весь набор свойств и методов является результатом наследования.</li>
            </ul>
            <pre><code>// получить объект html со всем его содержимым
document.documentElement;

// получить объект head со всем его содержимым
document.head;

// получить объект body со всем его содержимым
document.body;

// ширина видимой части документа
document.documentElement.clientWidth;

// высота видимой части документа
document.documentElement.clientHeight;

// ширина и высота всего документа, включая прокрученную часть
let scrollWidth = Math.max(
  document.body.scrollWidth, document.documentElement.scrollWidth,
  document.body.offsetWidth, document.documentElement.offsetWidth,
  document.body.clientWidth, document.documentElement.clientWidth,
);
let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight,
);

// запретить или разрешить прокрутку
// добавляет overflow = "hidden" в аттрибут style тега body
document.body.style.overflow = "hidden";

// добавляет класс в тег body, потом нужно добавить в класс css-свойство overflow = "hidden"
document.body.classList.toggle('scroll-lock');  

// для прокрутки страницы из JS её DOM должен быть полностью построен
document.body.style.overflow = "hidden"

// вернёт самый глубоко вложенный элемент по координатам (х, у).
// для координат вне окна возвращает null
document.elementFromPoint(x, y)

// добавит html на страницу до завершения её загрузки
document.write(html)

// создал тег div
const elem = document.createElement(`div`);

// создал текстовый узел
const newText = document.createTextNode(`Новый текст`);</code></pre>
            <table> 
              <caption>для изменения элементов или проверки DOM-дерева можем использовать инструменты разработчика в браузере</caption>
              <tbody> 
                <tr>
                  <td>Text       </td>
                  <td>для текстовых узлов. Содержат текст.</td>
                </tr>
                <tr>
                  <td>Comment    </td>
                  <td>для узлов-комментариев. Иногда в них можно включить информацию, которая не будет показана, но будет доступна в DOM для чтения JS</td>
                </tr>
                <tr>
                  <td>Element    </td>
                  <td>для узлов-элементов (HTML-тегов), обеспечивает навигацию на уровне тегов и служит базой для классов SVGElement, XMLElement, HTMLElement</td>
                </tr>
                <tr>
                  <td>HTMLElement</td>
                  <td>базовый класс для всех остальных HTML-тегов, от него  элементы</td>
                </tr>
                <tr>
                  <td>HTMLInputElement наследует HTMLElement</td>
                  <td>класс для тега input</td>
                </tr>
                <tr>
                  <td>HTMLBodyElement наследует HTMLElement</td>
                  <td>класс для тега body</td>
                </tr>
                <tr>
                  <td>HTMLAnchorElement наследует HTMLElement</td>
                  <td>класс для тега a и т.д.</td>
                </tr>
              </tbody>
            </table>
            <p>html атрибут - у каждого тега свои атрибуты: атрибуты написанные в HTML, автоматически становятся свойствами DOM-узла</p>
            <table> 
              <tbody> 
                <tr>
                  <td>value</td>
                  <td>значение для input, select и textarea (HTMLInputElement, HTMLSelectElement, ...)</td>
                </tr>
                <tr>
                  <td>href</td>
                  <td>адрес ссылки "href" для a href="..." (HTMLAnchorElement)</td>
                </tr>
                <tr>
                  <td>id</td>
                  <td>значение атрибута "id" для всех элементов (HTMLElement)</td>
                </tr>
              </tbody>
            </table>
            <p>
              для свойства DOM-узла регистр имеет значение, для атрибута тега - нет
              лучше использовать свойства DOM-узла, атрибуты используем тогда, когда нужны именно атрибуты
            </p>
            <p>
              Нестандартный атрибут если он начинается с data-, то нужно использовать dataset.<br />
              Атрибут из нескольких слов data-order-state это свойство dataset.orderState.
            </p>
            <pre><code>// получил объект body со всем его содержимым
const body = document.body;

// установил в аттрибут data-size значение 1024
body.dataset.size = "1024";

// 1024
alert(document.body.dataset.size);

< body data-about = "Elephants"></ body>
// Elephants
alert(document.body.dataset.about);</code></pre>
            <p>скрипт должен дождаться пока загрузятся стили</p>
            <pre><code>// такие скрипты блокируют DOMContentLoaded
< script> ... </ script>
< script src="/../../"> ... </ script>

// такие скрипты не блокируют DOMContentLoaded
document.createElement('script')
< script async> ... </ script>
< script defer src="/../../"> ... </ script></code></pre>
            <p>динамически загружаемые скрипты по умолчанию ведут себя как async</p>
            <pre><code>// отмена async-поведения
script.async = false;
let script = document.createElement('script');
script.src = "путь/к/скрипту";
document.body.append(script);</code></pre>
            <table>
              <tbody> 
                <tr>
                  <td>async</td>
                  <td>скрипты выполняются по загрузке, DOMContentLoaded не имеет значения</td>
                </tr>
                <tr>
                  <td>defer</td>
                  <td>скрипты выполняются по расположению в документе. Скрипт ждёт загрузку документа выполняется перед DOMContentLoaded</td>
                </tr>
                <tr>
                  <td>defer</td>
                  <td>работает только у скриптов с src="...", все элементы с src="..." дают события: load - при успешной загрузке и error - при ошибке</td>
                </tr>
                <tr>
                  <td>iframe</td>
                  <td>исключение: всегда даёт load, даже при ошибке</td>
                </tr>
              </tbody>
            </table>
            <p>скрипт одного сайта не может получить детали ошибки скрипта с другого сайта, нужно поставить атрибут crossorigin и специальные заголовки на удалённом сервере.</p>
            <p>фокус</p>
            <ul>
              <li>элемент получает фокус когда пользователь кликнет по нему или использует Tab.</li>
              <li>HTML-атрибут auto-focus - устанавливает фокус при загрузке страницы.</li>
              <li>document.activeElement - текущий элемент с фокусом.</li>
              <li>события focus, blur - не всплывают.</li>
              <li>события focusin / focusout - всплывают.</li>
              <li>focus(), blur() - методы.</li>
              <li>атрибут tabindex = -1 на клавишу tab не реагирует, но можно установить фокус на элемент методом.</li>
            </ul>
            <p>формы</p>
            <ul>
              <li>document.forms - живая коллекция всех форм на странице document.forms[name/index].</li>
              <li>элементы form или fieldset доступны через form.elements[name/index] или form[name/index].</li>
              <li>элементы хранят ссылку на свою форму в свойстве element.form.</li>
              <li>значения элементов формы доступны через input.value, textarea.value, select.value и т.д. либо input.checked для чекбоксов и переключателей.</li>
              <li>для select можно получить индекс выбранного пункта через: select.selectedIndex либо select.options.</li>
            </ul>
            <table> 
              <tbody> 
                <tr>
                  <td>document.querySelectorAll('form')</td>
                  <td>неживая коллекция</td>
                </tr>
                <tr>
                  <td>const form = document.forms[0]</td>
                  <td>получить форму по индексу коллекции</td>
                </tr>
                <tr>
                  <td>const form = document.forms.main</td>
                  <td>по аттрибуту тега name (name="main")</td>
                </tr>
                <tr>
                  <td>console.log(form.elements)</td>
                  <td>вывел элементы формы</td>
                </tr>
              </tbody>
            </table>
            <table>
              <caption>события изменения данных</caption>
              <tbody>
                <tr>
                  <td>change</td>
                  <td>значение изменено, срабатывает в текстовом поле при потере фокуса, в остальных полях при выборе</td>
                </tr>
                <tr>
                  <td>input</td>
                  <td>значение изменено, срабатывает немедленно при каждом изменении текстового поля</td>
                </tr>
                <tr>
                  <td>submit</td>
                  <td>отправка данных формы, при form.submit() - форма отправится при потере фокуса</td>
                </tr>
                <tr>
                  <td>cut</td>
                  <td>при вырезании</td>
                </tr>
                <tr>
                  <td>copy</td>
                  <td>при копировании</td>
                </tr>
                <tr>
                  <td>paste</td>
                  <td>при вставке</td>
                </tr>
              </tbody>
            </table>
            <p>свойство event.clipboardData даёт доступ для cut/copy/paste на чтение/запись в буфер</p>
            <ul>
              <li>при нажатии на кнопку input type='submit' (input type='image') или Enter в текстовом поле, генерируется событие click.</li>
              <li>при отправке формы генерируется событие submit.</li>
              <li>событие submit используется для проверки формы перед её отправкой на сервер или для отмены отправки и обработки её с помощью JS.</li>
              <li>form.submit() позволяет отправить форму из JS, используют для создания и отправки собственных форм на сервер, при этом событие submit не генерируется.</li>
            </ul>
            <p>свойства DOM</p><img src="./assets/img/contimg/metrics.png" alt="" loading="lazy"/>
            <table> 
              <tbody> 
                <tr>
                  <td>const elem = document.elementFromPoint(x, y);</td>
                  <td>узнать какой элемент находится по указанным координатам (координаты относительно окна браузера)</td>
                </tr>
                <tr>
                  <td>elem.attributes</td>
                  <td>коллекция всех аттрибутов</td>
                </tr>
                <tr>
                  <td>elem.hidden = true/false;</td>
                  <td>скрыть или показать объект</td>
                </tr>
                <tr>
                  <td>elem.offsetParent;</td>
                  <td>родительский элемент, относительно которого позиционирован elem</td>
                </tr>
                <tr>
                  <td>elem.offsetLeft;</td>
                  <td>отступ слева от родительского элемента elem.offsetParent</td>
                </tr>
                <tr>
                  <td>elem.offsetTop;</td>
                  <td>отступ сверху от родительского элемента elem.offsetParent</td>
                </tr>
                <tr>
                  <td>elem.offsetWidth;</td>
                  <td>общая ширина elem</td>
                </tr>
                <tr>
                  <td>elem.offsetHeight;</td>
                  <td>общая высота elem</td>
                </tr>
                <tr>
                  <td>elem.clientTop; element.clientLeft;</td>
                  <td>отступы внутренней части elem от внешней</td>
                </tr>
                <tr>
                  <td>elem.clientWidth; element.clientHeight;</td>
                  <td>размеры элемента без рамок и полосы прокрутки</td>
                </tr>
                <tr>
                  <td>elem.scrollWidth; element.scrollHeight;</td>
                  <td>размеры элемента без рамок и полосы прокрутки, с учетом прокрученной (невидимой) области элемента</td>
                </tr>
                <tr>
                  <td>elem.scrollLeft; element.scrollTop;</td>
                  <td>размеры прокрученной сверху части элемента, считается от верхнего левого угла</td>
                </tr>
                <tr>
                  <td>elem.getBoundingClientRect();</td>
                  <td>получить координаты относительно окна браузера</td>
                </tr>
                <tr>
                  <td>elem.getBoundingClientRect().top + window.pageYOffset;</td>
                  <td>получить координаты относительно документа</td>
                </tr>
              </tbody>
            </table>
            <p>К scrollLeft/scrollTop можно применять scrollBy, scrollTo, scrollIntoView, остальное только для чтения.  </p><br>
            <p>
              Если элемент, или любой его родитель, имеет display:none или отсутствует в документе, то все его метрики равны нулю (или null если это offsetParent).<br />
              Лучше использовать свойства-метрики т.к. CSS-свойства width/height зависят от другого свойства - box-sizing, которое определяет CSS-ширину/высоту.<br />
              Изменение box-sizing сломает код.<br />
              CSS-свойства width/height могут быть равны auto.
            </p>
            <table>
              <tbody> 
                <tr>
                  <td>elem.className</td>
                  <td>строковое значение, заменяет всю строку с классами</td>
                </tr>
                <tr>
                  <td>elem.classList</td>
                  <td>объект с методами для управления одним классом</td>
                </tr>
                <tr>
                  <td>elem.classList.add/remove("class")</td>
                  <td>добавить/удалить класс</td>
                </tr>
                <tr>
                  <td>elem.classList.toggle("class")</td>
                  <td>добавит класс если его нет, иначе удалит</td>
                </tr>
                <tr>
                  <td>elem.classList.contains("class")</td>
                  <td>проверка наличия класса, возвращает true/false</td>
                </tr>
                <tr>
                  <td>elem.style.backgroundColor</td>
                  <td>background-color</td>
                </tr>
                <tr>
                  <td>elem.style.zIndex</td>
                  <td>z-index</td>
                </tr>
                <tr>
                  <td>elem.style.borderLeftWidth</td>
                  <td>border-left-width</td>
                </tr>
                <tr>
                  <td>elem.style.width = "100px"</td>
                  <td>style = "width: 100px"</td>
                </tr>
                <tr>
                  <td>elem.style.display = "";</td>
                  <td> удалить elem.style.display</td>
                </tr>
                <tr>
                  <td>elem.style.cssText</td>
                  <td>вся строка стилей атрибута style</td>
                </tr>
                <tr rowspan="3">
                  <td>getComputedStyle(elem, [pseudo])</td>
                  <td>возвращает объект для чтения окончательных стилей с учетом всех классов, после применения CSS и вычисления окончательных значений. Без аргумента означает сам элемент.</td>
                </tr>
                <tr>
                  <td></td>
                  <td>elem - элемент, значения для которого нужно получить</td>
                </tr>
                <tr>
                  <td></td>
                  <td>pseudo - если нужен псевдоэлемент ::before</td>
                </tr>
              </tbody>
            </table>
            <p>document.cookie предоставляет доступ к куки</p>
            <ul>
              <li>операция записи изменяет только те куки, которые было указано.</li>
              <li>имя и значение куки должны быть закодированы.</li>
              <li>одно куки вмещает до 4 kb данных, количество куки зависит от браузера.</li>
            </ul>
            <table>
              <caption>Настройки куки</caption>
              <tbody> 
                <tr>
                  <td>path = /</td>
                  <td>по умолчанию текущий путь, делает куки видимыми только по указанному пути и ниже</td>
                </tr>
                <tr>
                  <td>domain = site.com</td>
                  <td>по умолчанию куки видно только на текущем домене, если явно указан домен, то куки видно и на поддоменах</td>
                </tr>
                <tr>
                  <td>expires или max-age</td>
                  <td>устанавливает дату истечения срока действия, без них куки умрёт при закрытии браузера</td>
                </tr>
                <tr>
                  <td>secure</td>
                  <td>делает куки доступными только при использовании HTTPS</td>
                </tr>
                <tr>
                  <td>somesite</td>
                  <td>запрещает браузеру отправлять куки с запросами, поступающими извне, помогает предотвратить XSRF-атаки</td>
                </tr>
              </tbody>
            </table>
            <table>
              <caption>методы DOM</caption>
              <tbody> 
                <tr>
                  <td>console.log(elem)</td>
                  <td>выводит элемент в виде DOM-дерева</td>
                </tr>
                <tr>
                  <td>console.dir(elem)</td>
                  <td>выводит элемент в виде DOM-объекта и список его свойств</td>
                </tr>
                <tr>
                  <td>elem.nodeType</td>
                  <td>тип DOM-узла, только для чтения, содержит числовое значение: 1- элементы, 3 - текстовые и т.д</td>
                </tr>
                <tr>
                  <td>elem.nodeName/tagName</td>
                  <td>возвращает название тега, только для чтения, для узлов - неэлементов описывает, что за узел</td>
                </tr>
                <tr>
                  <td>elem.hasAttribute(name)       </td>
                  <td>проверить наличие аттрибута name</td>
                </tr>
                <tr>
                  <td>elem.getAttribute(name)       </td>
                  <td>получить значение аттрибута name</td>
                </tr>
                <tr>
                  <td>elem.setAttribute(name, value)</td>
                  <td>создать аттрибут (name) и установить в него значение (value)</td>
                </tr>
                <tr>
                  <td>elem.removeAttribute(name)    </td>
                  <td>удалить атрибут name</td>
                </tr>
                <tr>
                  <td>elem.getBoundingClientRect()  </td>
                  <td>координаты относительно окна браузера</td>
                </tr>
                <tr>
                  <td>elem.scrollIntoView(top);     </td>
                  <td>
                    прокрутит страницу до элемента elem<br />
                    Если top = true, то элемент будет вверху страницы, если top = false, то элемент будет внизу страницы.
                  </td>
                </tr>
                <tr>
                  <td>const elemClassNames = elem.className;</td>
                  <td>получил все классы объекта element</td>
                </tr>
                <tr>
                  <td>elem.className = "red";</td>
                  <td>заменил все классы на класс red</td>
                </tr>
                <tr>
                  <td>elem.classList.add('active');</td>
                  <td>добавить класс</td>
                </tr>
                <tr>
                  <td>elem.classList.remove('active');</td>
                  <td>удалить класс</td>
                </tr>
                <tr>
                  <td>elem.classList.toggle('active');</td>
                  <td>добавить класс если его нет, а если есть, то удалить</td>
                </tr>
                <tr>
                  <td>elem.classList.contains('active');</td>
                  <td>проверить наличие класса, возвращает true or false</td>
                </tr>
                <tr>
                  <td>elem.style.color = "red";</td>
                  <td>получить доступ к атрибуту style HTML-тега и задать цвет</td>
                </tr>
                <tr>
                  <td>elem.style.color = "";</td>
                  <td>удалить css-свойство из атрибута style HTML-тега</td>
                </tr>
                <tr>
                  <td>console.log(elem.style.marginBottom);</td>
                  <td>вывод в консоль значение css-свойства атрибута style HTML-тега</td>
                </tr>
                <tr>
                  <td>elem.style.marginLeft = "20px";</td>
                  <td>значения задавать всегда с единицами измерения</td>
                </tr>
                <tr>
                  <td>const paddingLeft = parseInt(elemStyle.paddingLeft);</td>
                  <td>перевести значение из строки в число</td>
                </tr>
                <tr>
                  <td>elem.style.cssText = `margin-bottom: 30px; color: red;`;</td>
                  <td>записать несколько css-свойств в атрибут style, перезаписывает style полностью</td>
                </tr>
              </tbody>
            </table>
            <p>устаревшие методы (возвращают node)</p>
            <ul>
              <li>parent.appendChild(node).</li>
              <li>parent.insertBefore(node, nextSibling).</li>
              <li>parent.removeChild(node).</li>
              <li>parent.replaceChild(newElem, node).</li>
            </ul>
            <table> 
              <caption>манипуляции узлами</caption>
              <tbody> 
                <tr>
                  <td>node.append(...nodes or strings)</td>
                  <td>вставляет в node в конец</td>
                </tr>
                <tr>
                  <td>node.prepend(...nodes or strings)</td>
                  <td>вставляет в node в начало</td>
                </tr>
                <tr>
                  <td>node.before(...nodes or strings)</td>
                  <td>вставляет прямо перед node</td>
                </tr>
                <tr>
                  <td>node.after(...nodes or strings)</td>
                  <td>вставляет сразу после node</td>
                </tr>
                <tr>
                  <td>node.replaceWith(...nodes or strings)</td>
                  <td>заменяет node</td>
                </tr>
                <tr>
                  <td>node.remove()</td>
                  <td>удаляет node</td>
                </tr>
                <tr>
                  <td>elem.cloneNode(deep)</td>
                  <td>клонирует элемент, если deep == true, то со всеми дочерними элементами</td>
                </tr>
                <tr>
                  <td>elem.beforebegin()</td>
                  <td>вставляет html прямо перед elem</td>
                </tr>
                <tr>
                  <td>elem.afterbegin()</td>
                  <td>вставляет html в elem в начало</td>
                </tr>
                <tr>
                  <td>elem.beforeend()</td>
                  <td>вставляет html в elem в конец</td>
                </tr>
                <tr>
                  <td>elem.afterend()</td>
                  <td>вставляет html сразу после elem</td>
                </tr>
                <tr>
                  <td>elem.insertAdjacentText()</td>
                  <td>вставляет текстовые строки</td>
                </tr>
                <tr>
                  <td>elem.insertAdjacentElement()</td>
                  <td>вставляет элементы</td>
                </tr>
                <tr>
                  <td>elem.remove();</td>
                  <td>удаление объекта</td>
                </tr>
                <tr>
                  <td>elem.before(newElement);</td>
                  <td>вставил newElement перед elem</td>
                </tr>
                <tr>
                  <td>elem.after(newElement);</td>
                  <td>вставил newElement после elem</td>
                </tr>
                <tr>
                  <td>elem.prepend(newElement);</td>
                  <td>вставил newElement в начало внутри объекта elem</td>
                </tr>
                <tr>
                  <td>elem.append(newElement);</td>
                  <td>вставил newElement в конец внутри объекта elem</td>
                </tr>
                <tr>
                  <td>elem.append(newElement, `Новый текст`);</td>
                  <td>можно вставлять через запятую, но теги вставляются как текст</td>
                </tr>
                <tr>
                  <td>elem.insertAdjacentHTML('pos', `ins`);</td>
                  <td>позволяет вставить в DOM что угодно</td>
                </tr>
                <tr>
                  <td>getComputedStyle();</td>
                  <td>работает только для чтения</td>
                </tr>
                <tr>
                  <td>const elemStyle = getComputedStyle(elem);</td>
                  <td>получил вычисленные стили элемента</td>
                </tr>
                <tr>
                  <td>console.log(elemStyle.fontSize);</td>
                  <td>вывел вычисленное значение размера шрифта</td>
                </tr>
                <tr>
                  <td>const elemBeforeStyle = getComputedStyle(elem, "::before");</td>
                  <td>получил стили псевдоэлемента</td>
                </tr>
                <tr>
                  <td>console.log(elemBeforeStyle.backgroundColor);</td>
                  <td>вывел цвет фона, который реализован с помощью ::before</td>
                </tr>
                <tr>
                  <td>pos</td>
                  <td>место вставки по отношению к textElement  </td>
                </tr>
                <tr>
                  <td>beforebegin</td>
                  <td>вставить перед textElement  </td>
                </tr>
                <tr>
                  <td>afterbegin</td>
                  <td>вставить в начало textElement  </td>
                </tr>
                <tr>
                  <td>beforeend</td>
                  <td>вставить в конец textElement  </td>
                </tr>
                <tr>
                  <td>afterend</td>
                  <td>вставить после textElement  </td>
                </tr>
                <tr>
                  <td>ins</td>
                  <td>то что вставляем, позволяет вставить теги</td>
                </tr>
              </tbody>
            </table>
            <pre><code>// получить объект html со всем его содержимым
document.documentElement;

// получить объект head со всем его содержимым
document.head;

// получить объект body со всем его содержимым
document.body;

// ширина видимой части документа
document.documentElement.clientWidth;

// высота видимой части документа
document.documentElement.clientHeight;

// ширина и высота всего документа, включая прокрученную часть
let scrollWidth = Math.max(
  document.body.scrollWidth, document.documentElement.scrollWidth,
  document.body.offsetWidth, document.documentElement.offsetWidth,
  document.body.clientWidth, document.documentElement.clientWidth,
);
let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight,
);

// запретить или разрешить прокрутку
// добавляет overflow = "hidden" в аттрибут style тега body
document.body.style.overflow = "hidden";

// добавляет класс в тег body, потом нужно добавить в класс css-свойство overflow = "hidden"
document.body.classList.toggle('scroll-lock');  

// для прокрутки страницы из JS её DOM должен быть полностью построен
document.body.style.overflow = "hidden"

// вернёт самый глубоко вложенный элемент по координатам (х, у).
// для координат вне окна возвращает null
document.elementFromPoint(x, y)

// добавит html на страницу до завершения её загрузки
document.write(html)

// создал тег div
const elem = document.createElement(`div`);

// создал текстовый узел
const newText = document.createTextNode(`Новый текст`);</code></pre>
            <ul>
              <li>outerHTML - полный HTML элемента, заменяет elem во внешнем контексте.</li>
              <li>innerHTML - внутреннее HTML-содержимое элемента, с innerHTML вставка происходит 'как HTML', со всеми HTML-тегами.</li>
              <li>textContent - текст внутри элемента: HTML за вычетом всех тегов, помещает текст в элемент, все спецсимволы и теги интерпретируются как текст.</li>
            </ul>
            <pre><code>< div id="elem">Привет < span>сказочный</ span> Мир</ div>
const elem = document.getElementById('elem');

// < div id="elem">Привет < span>сказочный</ span> Мир</ div>
console.log(elem.outerHTML);

// Привет < span>сказочный</ span> Мир
console.log(elem.innerHTML);

// Привет сказочный Мир
console.log(elem.textContent);</code></pre>
            <p>nodeValue и data - содержимое узла-неэлемента (текст, комментарий).</p>
            <pre><code>< p>Привет</ p>
// Комментарий
  
let comment = text.nextSibling;
// выведет "Комментарий"
alert(comment.data);</code></pre>
            <p>JS может прочитать if из свойства data и обработать инструкции</p>
            <pre><code>// if isAdmin
alert("Добро пожаловать, Админ!");
// if</code></pre>
            <p>MutationObserver - встроенный объект, наблюдающий за DOM-элементом и запускающий колбэк в случае изменений</p>
            <pre><code>// создать наблюдатель
let observer = newMutationObserver(callback);

// прикрепить наблюдателя к DOM-узлу
observer.observe(node, config);

// остановить наблюдение
observer.disconnect();

// получить список необработанных изменений, до выполнения колбэка для них
observer.takeRecords();</code></pre>
            <p>
              Range - общий, объект для управления диапазоном, лежит в основе выделения - пара граничных точек: начало и конец диапазона.<br />
              Выделение в документе представлено объектом Selection, который можно получить
            </p>
            <pre><code>document.getSelection()</code></pre>
            <p>основные свойства выделения</p>
            <table>
              <tbody>
                <tr>
                  <td>anchorNode</td>
                  <td>узел начала выделения</td>
                </tr>
                <tr>
                  <td>anchorOffset</td>
                  <td>смещение в anchorNode, где начинается выделение</td>
                </tr>
                <tr>
                  <td>focusNode</td>
                  <td>узел окончания выделения</td>
                </tr>
                <tr>
                  <td>focusOffset</td>
                  <td>смещение в focusNode, где выделение заканчивается</td>
                </tr>
                <tr>
                  <td>inCollapsed</td>
                  <td>true, если диапазон выделения пуст или не существует</td>
                </tr>
                <tr>
                  <td>rangeCount</td>
                  <td>количество диапазонов в выделении</td>
                </tr>
              </tbody>
            </table>
          </details>
          <details> 
            <summary>DOM-navigation</summary><img src="./assets/img/contimg/навигация%20DOM.png" alt="" loading="lazy"/>
            <ul>
              <li>дочерние узлы (дети) - непосредственные дети-элементы узла.</li>
              <li>потомки - все элементы, внутри данного, включая детей, их детей и т.д..</li>
              <li>коллекция childNodes содержит список всех детей, включая текст.</li>
              <li>соседи - узлы, у которых один и тот же родитель: body - следующий или правый сосед head, head - предыдущий или левый сосед body.</li>
              <li>коллекция - это псевдомассив: можно перебирать с помощью for( of ) {} и forEach() {}.</li>
              <li>изменять элемент коллекции как в массиве не получится, только через специальные методы.</li>
              <li>живая коллекция - содержит в себе всегда актуальную информацию с учетом изменений в дереве DOM.</li>
            </ul><img src="./assets/img/contimg/querySelector.png" alt="" loading="lazy"/>
            <pre><code>elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length-1] === elem.lastChild
</code></pre>
            <table> 
              <caption>const bodyElement = document.body;</caption>
              <tbody> 
                <tr>
                  <td>bodyElement.hasChildNodes()</td>
                  <td>проверить есть ли дочерние узлы у объекта true or false</td>
                </tr>
                <tr>
                  <td>bodyElement.previousSibling;</td>
                  <td>предыдущий соседний узел</td>
                </tr>
                <tr>
                  <td>bodyElement.nextSibling;</td>
                  <td>следующий соседний узел</td>
                </tr>
                <tr>
                  <td>bodyElement.parentNode;</td>
                  <td>родительский узел</td>
                </tr>
                <tr>
                  <td>bodyElement.firstChild;</td>
                  <td>первый узел</td>
                </tr>
                <tr>
                  <td>bodyElement.lastChild;</td>
                  <td>последний узел</td>
                </tr>
                <tr>
                  <td>bodyElement.childNodes;</td>
                  <td>получаем коллекцию всех дочерних узлов</td>
                </tr>
                <tr>
                  <td>bodyElement.children;</td>
                  <td>получаем коллекцию всех дочерних элементов (тегов)</td>
                </tr>
                <tr>
                  <td>bodyElement.firstElementChild;</td>
                  <td>первый элемент</td>
                </tr>
                <tr>
                  <td>bodyElement.lastElementChild;</td>
                  <td>последний элемент</td>
                </tr>
                <tr>
                  <td>bodyElement.previousElementSibling;</td>
                  <td>предыдущий соседний элемент</td>
                </tr>
                <tr>
                  <td>bodyElement.nextElementSibling;</td>
                  <td>следующий соседний элемент</td>
                </tr>
                <tr>
                  <td>bodyElement.parentElement;</td>
                  <td>родительский элемент</td>
                </tr>
              </tbody>
            </table>
            <table>
              <caption>поиск элемента</caption>
              <tbody> 
                <tr>
                  <td>elem.closest(css)</td>
                  <td>ищет ближайшего предка, по css-селектору</td>
                </tr>
                <tr>
                  <td>elem.matches(css)</td>
                  <td>проверяет соответствует ли элемент css селектору, возвращает true or false</td>
                </tr>
                <tr>
                  <td>elemA.contains(elemB)</td>
                  <td>вернет true если elemB находится внутри elemA или elemA == elemB</td>
                </tr>
                <tr>
                  <td>elem.querySelector(CSS);</td>
                  <td>вернёт первый попавшийся элемент по CSS-селектору без учета контекста</td>
                </tr>
                <tr>
                  <td>elem.querySelectorAll(CSS);</td>
                  <td>вернёт статичную коллекцию элементов внутри elem, по CSS-селектору (.class, tag, #id, и т.д.)</td>
                </tr>
                <tr>
                  <td>document.getElementById(id);</td>
                  <td>вернёт элемент по id, ищет только в document</td>
                </tr>
                <tr>
                  <td>document.getElementsByName(атрибут name);</td>
                  <td>возвращает живую коллекцию, ищет только в document</td>
                </tr>
                <tr>
                  <td>document.getElementsByTagName(tag);</td>
                  <td>вернёт живую коллекцию, по тегу или "*"</td>
                </tr>
                <tr>
                  <td>document.getElementsByClassName(class)</td>
                  <td>вернёт живую коллекцию, по class</td>
                </tr>
                <tr>
                  <td>const textElement = document.querySelector('.someClass__text');</td>
                  <td>получил объект</td>
                </tr>
                <tr>
                  <td>const textElementContent = textElement.innerHTML;</td>
                  <td>получил содержимое объекта как есть</td>
                </tr>
                <tr>
                  <td>textElement.innerHTML = `Новое содержимое объекта`;</td>
                  <td>заменил содержимое объекта</td>
                </tr>
                <tr>
                  <td>const textElement = document.querySelector('.someClass__text');</td>
                  <td>получил объект</td>
                </tr>
                <tr>
                  <td>const textElementContent = textElement.outerHTML;</td>
                  <td>получил содержимое объекта и сам объект</td>
                </tr>
                <tr>
                  <td>textElement.outerHTML = `< p>Новое содержимое объекта< /p>`;</td>
                  <td>заменил сам объект</td>
                </tr>
                <tr>
                  <td>const textElement = document.querySelector('.someClass__text');</td>
                  <td>получил объект</td>
                </tr>
                <tr>
                  <td>const textElementContent = textElement.textContent;</td>
                  <td>получил содержимое объекта без тегов</td>
                </tr>
                <tr>
                  <td colspan="2">теги вставляются как текст, позволяет записывать получаемый текст безопасно</td>
                  <td></td>
                </tr>
                <tr>
                  <td>textElement.textContent = `< p>Новое содержимое объекта< /p>`;</td>
                  <td>заменил содержимое объекта</td>
                </tr>
                <tr>
                  <td>const textElement = document.querySelector('.someClass__text');</td>
                  <td>получил объект с классом .someClass__text</td>
                </tr>
                <tr>
                  <td>const getComment = textElement.nextSibling;</td>
                  <td>получил следующий объект - комментарий</td>
                </tr>
                <tr>
                  <td>console.log(getComment.data);</td>
                  <td>вывел текст комментария в консоль</td>
                </tr>
                <tr>
                  <td>getComment.data = `Новый текст`;</td>
                  <td>заменил текст комментария</td>
                </tr>
              </tbody>
            </table>
          </details>
          <details> 
            <summary>EventTarget</summary>
            <p>
              EventTarget - это абстрактный класс, который обеспечивает поддержание DOM-узлами событий.<br />
              Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его как первый аргумент (event) функции-обработчику.<br />
              Событию можно назначить функцию-обработчик, которая сработает, как только событие произошло.<br />
              В DOM-свойстве один обработчик на один тип события, так как одно имя - одно свойство.<br />
              В случае событий, отправленных сервером (SSE), обновления приходят автоматически.
            </p>
            <table> 
              <caption>объект события
                <tr>
                  <td>event.type</td>
                  <td>тип события, например "click"</td>
                </tr>
                <tr>
                  <td>event.target</td>
                  <td>объект, на котором сработал обработчик</td>
                </tr>
                <tr>
                  <td>event.currentTarget</td>
                  <td>объект, которому назначен обработчик</td>
                </tr>
                <tr>
                  <td>event.clientX/event.clientY</td>
                  <td>координаты курсора для событий мыши в момент клика относительно окна</td>
                </tr>
                <tr>
                  <td>event.stopPropagation();</td>
                  <td>остановка всплытия</td>
                </tr>
                <tr>
                  <td>event.defaultPrevented</td>
                  <td>равно true если событие по умолчанию отменено, иначе false</td>
                </tr>
                <tr>
                  <td>console.log(event)</td>
                  <td>посмотреть все детали события</td>
                </tr>
              </caption>
            </table>
            <table> 
              <caption>события клавиатуры</caption>
              <tbody> 
                <tr>
                  <td>keydown</td>
                  <td>происходит при нажатии клавиши</td>
                </tr>
                <tr>
                  <td>keyup</td>
                  <td>при отпускании клавиши</td>
                </tr>
                <tr>
                  <td>event.code</td>
                  <td>код нажатой клавиши ("KeyA", "ArrowLeft" и т.д.)</td>
                </tr>
                <tr>
                  <td>event.key</td>
                  <td>клавиша с учетом регистра и раскладки клавиатуры символ ("A", "a" и т.д.)</td>
                </tr>
                <tr>
                  <td>event.repeat</td>
                  <td>вернет true при срабатывании повтора на зажатой клавише</td>
                </tr>
              </tbody>
            </table>
            <p>нажатие клавиши всегда генерирует клавиатурное событие, кроме клавиши Fn.  </p>
            <pre><code>window.addEventListener('scroll', function() {
  document.getElementById('showScroll').innerHTML = pageYOffset + 'px';
});
</code></pre>
            <table> 
              <caption>прокрутка</caption>
              <tbody> 
                <tr>
                  <td>scroll</td>
                  <td>событие прокрутки позволяет реагировать на прокрутку страницы или элемента</td>
                </tr>
                <tr>
                  <td>scrollY</td>
                  <td>количество прокрученных пикселей по вертикали</td>
                </tr>
                <tr>
                  <td>scrollX</td>
                  <td>количество прокрученных пикселей по горизонтали</td>
                </tr>
              </tbody>
            </table>
            <pre><code>document.addEventListener("DOMContentLoaded", () => {alert("DOM готов!");});

// window.addEventListener('load', (event) => {}
window.onload = function() {
  alert('Страница и все ресурсы загружены');
};
</code></pre>
            <table>
              <caption>события загрузки</caption>
              <tbody> 
                <tr>
                  <td>событие DOMContentLoaded</td>
                  <td>браузер загрузил HTML, построил DOM-дерево, но внешние ресурсы ещё не загружены срабатывает на объекте document</td>
                </tr>
                <tr>
                  <td>событие load</td>
                  <td>свойство window.onload - страница и все ресурсы загружены</td>
                </tr>
                <tr>
                  <td>событие error</td>
                  <td>свойство window.onerror - позволяет "поймать" ошибки в скрипте</td>
                </tr>
                <tr>
                  <td>событие beforeunload</td>
                  <td>
                    свойство window.unload - пользователь покидает страницу, если отменить событие, то браузер спросит хочет ли пользователь уйти можно сделать сетевой запрос, поручить браузеру собрать статистику, вывести пользователю предупреждение о несохраненных данных в форме.  
                    
                  </td>
                </tr>
              </tbody>
            </table>
            <table> 
              <caption>текущее состояние загрузки документа - document.readyState</caption>
              <tbody> 
                <tr>
                  <td>loading</td>
                  <td>документ загружается</td>
                </tr>
                <tr>
                  <td>interactive</td>
                  <td>документ прочитан, происходит перед DOMContentLoaded</td>
                </tr>
                <tr>
                  <td>complete</td>
                  <td>документ и все ресурсы загружены, происходит перед window.onload</td>
                </tr>
                <tr>
                  <td>document.readyStateChange</td>
                  <td>отслеживать изменения, также работает для ресурсов</td>
                </tr>
              </tbody>
            </table>
            <p>
              Методы - самый гибкий и используемый способ назначить обработчик.<br />
              Не используй setAttribute для обработчиков.
            </p>
            <pre><code>// обработчик события, аттрибут тега.
onclick="JScode"

const button = document.querySelector('.button');
// нет возможности повесить на одно событие несколько обработчиков
button.onclick = function () {};

function showClick() {}
// нет возможности повесить на одно событие несколько обработчиков
button.onclick = showClick;

// можно назначить обработчик несколько раз
button.addEventListener("click", function (e) {});

function func(e) {}
button.addEventListener("click", func);
</code></pre>
            <table>
              <caption>Способы назначения обработчиков событий</caption>
              <tbody>
                <tr>
                  <td>onclick="..."</td>
                  <td>атрибут HTML</td>
                </tr>
                <tr>
                  <td>elem.onclick = function</td>
                  <td>DOM-свойство</td>
                </tr>
                <tr>
                  <td>elem.onclick = null</td>
                  <td>убрать обработчик</td>
                </tr>
                <tr>
                  <td>elem.addEventListener(event, handler, [options])</td>
                  <td>метод для добавления слушателя</td>
                </tr>
                <tr>
                  <td>elem.removeEventListener(event, handler, [options])</td>
                  <td>удалить слушателя, handler обязательно тат-же</td>
                </tr>
                <tr>
                  <td>event</td>
                  <td>имя события, например "click"</td>
                </tr>
                <tr>
                  <td>handler</td>
                  <td>ссылка на функцию обработчик</td>
                </tr>
                <tr>
                  <td>options</td>
                  <td>дополнительный объект со свойствами:</td>
                </tr>
                <tr>
                  <td>once</td>
                  <td>если true, тогда обработчик будет удалён после выполнения</td>
                </tr>
                <tr>
                  <td>capture</td>
                  <td>фаза, на которой должен сработать обработчик (всплытие/погружение) (false/true)</td>
                </tr>
                <tr>
                  <td>passive</td>
                  <td>если true, то обработчик не вызовет preventDefault(), браузер не будет ждать выполнения всех обработчиков, а сразу выполнит действия по умолчанию, например прокрутку.</td>
                </tr>
              </tbody>
            </table>
            <p>Событие должно всплывать - низкоуровневые обработчики не должны вызывать event.stopPropagation().</p>
            <pre><code>// отмена действий браузера по умолчанию для addEventListener
event.preventDefault();
button.addEventListener("click", func, {"passive": true});

// отмена действий браузера по умолчанию для onclick
link.onclick = function () {return false;}

< a href="/" onclick = "event.preventDefault()">здесь</ a></code></pre>
          </details>
          <details> 
            <summary>Всплытие и погружение</summary>
            <p>целевой элемент event.target - самый глубоко вложенный элемент, над которым произошло событие</p>
            <ul>
              <li>погружение - событие движется вниз от корня документа к event.target.</li>
              <li>по пути событие вызывает обработчики, поставленные через addEventListener(..., true), где true - сокращенно {capture: true}.</li>
              <li>вызывает обработчики на целевом элементе.</li>
              <li>всплытие - событие движется вверх от event.target к корню документа.</li>
              <li>по пути событие вызывает обработчики, поставленные через атрибут и addEventListener без третьего аргумента или третий аргумент: false.</li>
            </ul>
            <p>Каждый обработчик имеет доступ к свойствам события event</p>
            <ul>
              <li>event.target - самый глубокий элемент, на котором произошло событие.</li>
              <li>event.currentTarget(=this) - элемент, на котором в данный момент сработал обработчик.</li>
              <li>event.eventPhase - не какой фазе он сработал: (погружение = 1, фаза цели = 2, всплытие = 3).</li>
            </ul>
            <p>Делегирование - вешаем прослушку на родителя</p>
            <ul>
              <li>всплытие и погружение являются основой для делегирования событий.</li>
              <li>вешаем обработчик на контейнер.</li>
              <li>в обработчике проверяем целевой элемент event.target.</li>
              <li>если событие произошло на нужном элементе, то обрабатываем его.</li>
            </ul>
            <p>Генерировать встроенные события в случаях</p>
            <ul>
              <li>явный грубый хак, чтобы заставить работать сторонние библиотеки, если нет другого способа.</li>
              <li>скриптом нажать на кнопку для автоматического тестирования.</li>
              <li>при создании встроенных событий использовать конструкторы встроенных событий (newMouseEvent('click') и др.).</li>
              <li>для пользовательских событий применять конструктор CustomEvent.</li>
              <li>onsome_event - для встроенных событий.</li>
              <li>addEventListener - для генерируемых.</li>
              <li>event.isTrusted - true для событий от пользователя и false для генерирующих.</li>
              <li>event.detail - передать информацию в объекте события.</li>
            </ul>
            <pre><code>// создать объект события
let event = newEvent(name, [options]);
// запускает объект события на элементе
elem.dispatchEvent(event);</code></pre>
            <p>Базовый конструктор Event(name, options) принимает обязательное имя события и options - объект с тремя свойствами</p>
            <ul>
              <li>bubbles: true - чтобы событие всплывало.</li>
              <li>cancelable: true - если нужно, чтобы работал event.preventDefault().</li>
              <li>composed: true/false - если true, то событие будет всплывать наружу за пределы Shadow DOM.</li>
              <li>по умолчанию все три свойства - false:</li>
            </ul>
          </details>
          <details> 
            <summary>События мыши</summary>
            <ul>
              <li>click - кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами - при касании).</li>
              <li>contextmenu - происходит, когда кликнули на элемент правой кнопкой мыши.</li>
              <li>mouseover/mouseout - когда мышь наводится на/покидает элемент.</li>
              <li>mousedown/mouseup - когда нажали/отжали кнопку мыши на элементе.</li>
              <li>mousemove - при движении мыши.</li>
            </ul>
            <p>
              Комплексные события состоят из простых, обработчики событий вызываются в следующем порядке: mousedown -> mouseup -> click.<br />
              Свойство события мыши which - какая кнопка мыши нажата:
            </p>
            <ul>
              <li>event.which == 1 - левая кнопка.</li>
              <li>event.which == 2 - средняя кнопка.</li>
              <li>event.which == 3 - правая кнопка.</li>
            </ul>
            <p>
              Клавиши - модификаторы (true если нажаты): altKey, ctrKey и metaKey (Mac).<br />
              В Мас обычно Cmd вместо ctrl, поэтому лучше проверить: if(e.metaKey || e.ctrlKey).<br />
              Координаты относительно окна: clientX, clientY.<br />
              Координаты относительно документа: pageX/pageY.<br />
              Запрет копирования
            </p>
            <pre><code>< div oncopy = "alert('Копирование запрещено!'); return false"></code></pre>
            <p>
              При быстром движении мыши события не будут возникать на промежуточных элементах.<br />
              Браузер периодически проверяет позицию курсора и при изменении генерирует событие mousemove.<br />
              Если был mouseover, то будет и mouseout.<br />
              События mouseover/out и mouseenter/leave имеют дополнительное свойство relatedTarget.
            </p>
            <table> 
              <caption>Для события mouseover</caption>
              <tbody> 
                <tr>
                  <td>event.target</td>
                  <td>это элемент, на который курсор пришёл/ушёл.</td>
                </tr>
                <tr>
                  <td>event.relatedTarget</td>
                  <td>это элемент, с которого курсор пришёл/ушёл (target -> relatedTarget)</td>
                </tr>
                <tr>
                  <td>event.relatedTarget равно null</td>
                  <td>указатель мыши пришёл из-за или ушёл за пределы окна.</td>
                </tr>
              </tbody>
            </table>
            <p>
              В любой момент времени указатель может быть только над одним элементом - над самым глубоко вложенным.<br />
              События mouseover/out возникают, когда происходит переход с родительского элемента на потомка, всплывают, можно использовать делегирование.<br />
              События mouseenter/leave не всплывают и генерируются, когда курсор переходит или уходит на элемент в целом (без учёта потомков).<br />
              
              Базовый алгоритм Drag'n'Drop
            </p>
            <ul>
              <li>object.mousedown -&gt; document.mousemove -&gt; object.mouseup (обязательно отменить браузерный ondragstart).</li>
              <li>при mousedown - готовим элемент к перемещению (если нужно создаём его копию).</li>
              <li>в начале перетаскивания запоминаем начальное смещение указателя относительно элемента(shiftX/shiftY) и сохраняем его при перетаскивании.</li>
              <li>при mousemove - передвигаем элемент на новые координаты путём смены left/top и position: absolute.</li>
              <li>выявляем потенциальные цели переноса под указателем с помощью document.elementFromPoint.</li>
              <li>при mouseup - остановить перенос элемента и произвести окончание Drag'n'Drop.</li>
              <li>на mouseup завершить перенос: изменить данные, переместить элементы.</li>
            </ul>
            <p>
              События указателя (Pointer events) одновременно обрабатывают действия мыши, касания пера.<br />
              Содержат свойства мыши и дополнительно свои:
            </p>
            <ul>
              <li>pointerId - идентификатор указателя, вызвавшего событие, генерируется браузером, позволяет обрабатывать несколько указателей (стилус и мультитач).</li>
              <li>pointerType - тип указывающего устройства. Строка с одним из значений: 'mouse', 'pen' или 'touch'.</li>
              <li>isPrimary - равно true для основного указателя (первый палец в мультитач).</li>
            </ul>
            <p>
              При обработке переносов и сложных касаний нужно отменить действие браузера и ставить touch-events: none в CSS для элементов.<br />
              Можно перенаправить (захватить) все события указателя на определённый элемент до наступления события pointerup/pointercancel.<br />
              Два связанных с захватом события:
            </p>
            <ul>
              <li>getpointercapture - элемент использует setPointerCapture для включения захвата.</li>
              <li>lostpointercapture - освобождение от захвата явно с помощью releasePointerCapture или автоматически при pointerup/pointercancel.</li>
            </ul>
            <p>События указателя - мыши</p>
            <ul>
              <li>pointerdown - mousedown.</li>
              <li>pointerup - mouseup.</li>
              <li>pointermove - mousemove.</li>
              <li>pointerover - mouseover.</li>
              <li>pointerenter - mouseenter.</li>
              <li>pointerleave - mouseleave.</li>
              <li>pointercancel.</li>
              <li>getpointercapture.</li>
              <li>lostpointercapture.</li>
            </ul>
          </details>
          <details> 
            <summary>Примеры</summary>
            <h2>Анимация</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Tasks< /title>
  < script>
    document.addEventListener('DOMContentLoaded', function() {
      const h1 = document.querySelector('h1');
      h1.style.animationPlayState = 'paused';
      document.querySelector('button').onclick = () => {
        if (h1.style.animationPlayState === 'paused') {
          h1.style.animationPlayState = 'running';
        } else {
          h1.style.animationPlayState = 'paused';
        }
      }
    });
  < /script>
  < style>
    body {
      font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
    }
    @keyframes move {
      0% {
        left: 0%;
      }
      50% {
        left: 50%;
      }
      100% {
        left: 0%;
      }
    }
    h1 {
      position: relative;
      animation-name: move;
      animation-duration: 2s;
      animation-fill-mode: forwards;
      animation-iteration-count: infinite;
    }
  < /style>
< /head>
< body>
  < button>Click Here!< /button>
  < h1>Welcome!< /h1>
< /body>
< /html>
</code></pre>
            <h2>Цвета</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Colors< /title>

  < script>
    document.addEventListener('DOMContentLoaded', function() {
      document.querySelectorAll('button').forEach(button => {
        button.onclick = function() {
          document.querySelector('#hello').style.color = button.dataset.color;
        }
      })
    });
  < /script>

  < style>
    body {
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
    }
  < /style>
< /head>
< body>
  < h1 id="hello">Hello!< /h1>
  < button data-color="red">Red< /button>
  < button data-color="blue">Blue< /button>
  < button data-color="green">Green< /button>
< /body>
< /html>
</code></pre>
            <h2>Цвета выбор</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Colors1< /title>

  < script>
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelector('select').onchange = function() {
        document.querySelector('#hello').style.color = this.value;
      }
    });
  < /script>

  < style>
    body {
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
    }
  < /style>
< /head>
< body>
  < h1 id="hello">Hello!< /h1>
  < select name="" id="">
    < option value="red">Red< /option>
    < option value="blue">Blue< /option>
    < option value="green">Green< /option>
  < /select>
< /body>
< /html>
</code></pre>
            <h2>Счётчик</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Counter< /title>
  < script>
    let counter = 0;

    function count() {
      counter++;
      document.querySelector('h1').innerHTML = counter;

      if (counter % 10 === 0) {
        alert(`Count is now ${counter}`);
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      document.querySelector('button').onclick = count;
    });
  < /script>
< /head>
< body>
  < h1>0< /h1>
  < button>Count< /button>
< /body>
< /html>
</code></pre>
            <h2>Счётчик хранилище</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Counter< /title>
  < script>
    let counter = 0;

    function count() {
      counter++;
      document.querySelector('h1').innerHTML = counter;
    }

    document.addEventListener('DOMContentLoaded', function() {
      document.querySelector('button').onclick = count;

      setInterval(count, 1000);
    });
  < /script>
  < style>
    body {
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
    }
  < /style>
< /head>
< body>
  < h1>0< /h1>
  < button>Count< /button>
< /body>
< /html>
</code></pre>
            <h2>Счётчик локал</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Counter< /title>
  < script>
    if (!localStorage.getItem('counter')) {
      localStorage.setItem('counter', 0);
    }

    function count() {
      let counter = localStorage.getItem('counter');
      counter++;
      document.querySelector('h1').innerHTML = counter;
      localStorage.setItem('counter', counter);
    }

    document.addEventListener('DOMContentLoaded', function() {
      document.querySelector('h1').innerHTML = localStorage.getItem('counter');
      document.querySelector('button').onclick = count;
    });
    
  < /script>
  < style>
    body {
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
    }
  < /style>
< /head>
< body>
  < h1>0< /h1>
  < button>Count< /button>
< /body>
< /html>
</code></pre>
            <h2>Форм</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Form1< /title>

  < script>
    document.addEventListener('DOMContentLoaded', function() {
      document.querySelector('form').onsubmit = function() {
        const name = document.querySelector('#name').value;
        alert(`Hello, ${name}!`);
      };
    });
  < /script>

  < style>
    body {
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
    }
  < /style>
< /head>
< body>
  < h1>Hello!< /h1>
  < form action="">
    < input autofocus id="name" placeholder="Name" type="text">
    < input type="submit">
  < /form>
< /body>
< /html>
</code></pre>
            <h2>Привет</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Hello< /title>
  < script>
    function hello() {
      const heading = document.querySelector('h1');
      if (heading.innerHTML === 'Hello!') {
        heading.innerHTML = 'Goodbye!';
      } else {
        heading.innerHTML = 'Hello!';
      }
    }
  < /script>
< /head>
< body>
  < h1>Hello!< /h1>
  < button onclick="hello()">Click here< /button>
< /body>
< /html>
</code></pre>
            <h2>Посты</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Posts< /title>

  < script>
    // Start with first post
    let counter = 1;

    //Load posts 20 at a time
    const quantity = 20;

    // When DOM loads, render the first 20 posts
    document.addEventListener('DOMContentLoaded', load);

    window.onscroll = () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
        load();
      }
    };

    document.addEventListener('click', event => {
      const element = event.target;
      if (element.className === 'hide') {
        element.parentElement.style.animationPlayState = 'running';
        element.parentElement.addEventListener('animationed', () => {
          element.parentElement.remove();
        });
      }
    });

    // Load next set of posts
    function load() {
      
      // Set start and end post numbers, and update counter
      const start = counter;
      const end = start + quantity - 1;
      counter = end + 1;

      //Get new posts and add posts
      fetch(`/posts?start=${start}&end=${end}`)
      .then(response => response.json())
      .then(data => {
        data.posts.forEach(add_post);
      })
    };

    // Add a new post with given contents to DOM
    function add_post(contents) {

      // Create new post
      const post = document.createElement('div');
      post.className = 'post';
      post.innerHTML = `${contents} < button class="hide">Hide< /button>`;

      // Add post to DOM
      document.querySelector('#posts').append(post);
    };
  < /script>

  < style>
    body {
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
      padding-bottom: 50px;
    }

    @keyframes hide {
      0% {
        opacity: 1;
        height: 100%;
        line-height: 100%;
        padding: 20px;
        margin-bottom: 10px;
      }

      75% {
        opacity: 0;
        height: 100%;
        line-height: 100%;
        padding: 20px;
        margin-bottom: 10px;
      }

      100% {
        opacity: 0;
        height: 0px;
        line-height: 0px;
        padding: 0px;
        margin-bottom: 0px;
      }
    }

    .hide {
      float: right;
    }

    .post {
      background-color: greenyellow;
      padding: 20px;
      margin-bottom: 10px;
      animation-name: hide;
      animation-duration: 2s;
      animation-fill-mode: forwards;
      animation-play-state: paused;
    }
  < /style>
< /head>
< body>
  < div id="posts">< /div>
< /body>
< /html>
</code></pre>
            <h2>Валюта</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Tasks< /title>

  < script>
    document.addEventListener('DOMContentLoaded', function() {

      document.querySelector('form').onsubmit = function() {
        fetch('https://api.exchangeratesapi.io/latest?base=USD')
        .then(response => response.json())
        .then(data => {
          const currency = document.querySelector('#currency').value.toUpperCase();
          const rate = data.rates[currency];
          if (rate !== undefined) {
            document.querySelector('#result').innerHTML = `1 USD is equal to ${rate.toFixed(3)} ${currency}.`;
          } else {
            document.querySelector('#result').innerHTML = 'Invalid currency.';
          }
          
        })
        .catch(error => {
          console.log('Error:', error);
        });

        return false;
      }
      
    });
  < /script>

  < style>
    body {
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
    }
  < /style>
< /head>
< body>
  < form>
    < input id="currency" placeholder="Currency" type="text">
    < input type="submit" value="Convert">
  < /form>
  < div id="result">< /div>
< /body>
< /html>
</code></pre>
            <h2>Прокрутка</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Tasks< /title>

  < script>
    window.onscroll = () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight) {
        document.querySelector('body').style.background = 'green';
      } else {
        document.querySelector('body').style.background = 'white';
      }
    }
  < /script>
< /head>
< body>
  < div>
    Lorem ipsum, dolor sit amet consectetur adipisicing elit. Nihil laudantium cumque consequatur exercitationem deleniti corporis, eius, dicta ad molestias voluptatum nesciunt vel animi dolorum architecto debitis consequuntur, minima nostrum ipsa dolor quidem eligendi necessitatibus atque labore similique. Neque commodi doloribus mollitia sint rerum est, sit ratione sunt inventore, sapiente minima enim eum. Nisi odio laborum, quos quibusdam, delectus quaerat quisquam velit aliquam repudiandae ad ipsa, voluptates doloremque harum dolores pariatur fugit debitis quis? Quae unde eos ipsam quam est explicabo vitae mollitia, aspernatur provident magnam velit dignissimos corporis quibusdam deleniti obcaecati praesentium sint accusantium, perferendis autem optio ex fuga animi? Distinctio culpa quos quaerat eum, neque saepe, cum fugiat placeat ducimus asperiores sint. Iste libero maxime dolores deleniti magnam enim sequi iusto soluta nihil? Incidunt quibusdam ipsum itaque nobis quam commodi, iste optio voluptatibus alias quae ullam, cum quas vitae tenetur sunt! Nisi odit voluptatem error deleniti dignissimos explicabo nostrum libero iste, quod nemo itaque voluptate officiis impedit sed placeat ut natus facilis labore veniam expedita temporibus? Quisquam maxime optio debitis repellat illo hic unde incidunt dicta reprehenderit, necessitatibus doloribus consectetur nesciunt aspernatur nostrum sed. Dicta deserunt cum voluptatibus consequuntur architecto error repellat sequi, obcaecati voluptas at provident suscipit tenetur hic est, minima qui a autem reprehenderit ducimus aliquid tempora, veritatis voluptates et fugit. Ut iste doloremque eaque id eligendi veniam repellendus beatae maiores eius a quia explicabo repellat dolore ad, voluptates obcaecati quasi sequi nisi ducimus saepe! Est magnam totam sapiente quae, nemo tenetur porro earum velit. Quis, ipsum expedita et dolorem aspernatur sequi sunt nesciunt eligendi impedit! Tempora culpa consectetur laborum odio quia dignissimos iste nulla itaque quod sit vitae non quibusdam saepe eligendi expedita architecto, unde commodi nihil. Ratione voluptas tempora maxime sit nam ut optio eum, veritatis deserunt sed ad laboriosam officia earum neque eius obcaecati? Incidunt veniam explicabo qui quo aliquam, quibusdam enim? Delectus necessitatibus assumenda natus ea quisquam temporibus aut repudiandae fugit nihil quidem aliquam excepturi voluptatibus eligendi, fugiat aliquid corporis inventore ad non. In porro veritatis nisi, iure numquam minus itaque accusantium praesentium perferendis quas qui magnam eveniet voluptatum, est provident recusandae maiores quisquam amet vero, cumque beatae asperiores! Laborum asperiores magni neque vitae nostrum ipsam ducimus, accusamus quam non pariatur dolore hic, ad blanditiis nulla recusandae perspiciatis! Officia autem ullam soluta quisquam quas temporibus nulla assumenda, alias ipsam nesciunt aperiam omnis optio debitis accusantium tempore. Distinctio, molestias nesciunt itaque modi, iste eligendi fuga laudantium quod asperiores corporis officiis, dolores sint blanditiis necessitatibus vero atque architecto explicabo veniam. Eveniet exercitationem repellendus repudiandae, ipsa laudantium, quos pariatur nihil similique debitis libero, dolore fugiat molestias at nobis dicta consectetur. In illum repellendus fugiat ducimus praesentium id qui odit ab. Maiores animi magnam culpa recusandae laborum nisi perspiciatis, blanditiis quo! Placeat non quia autem voluptatem, adipisci vitae cupiditate, quod minus numquam dolore voluptatum reprehenderit? Deserunt rerum delectus aliquam ex est, soluta impedit quasi officia expedita suscipit tenetur sapiente ipsa laboriosam officiis eum voluptatibus esse numquam autem perferendis nisi eveniet dolores incidunt? Illum modi officiis omnis pariatur beatae quae ipsam. Incidunt voluptatem reprehenderit alias. Dolor ratione saepe unde atque adipisci cum numquam alias? Neque, expedita consequuntur quam sit ducimus animi molestiae fuga reprehenderit alias illo. Asperiores provident reiciendis laudantium quam sunt maxime sed voluptate similique vitae? Eligendi, tempore ad reprehenderit, deserunt illo ipsam placeat molestias excepturi itaque sunt distinctio aliquam nemo! Molestias velit totam nihil officiis sequi sunt dolores dignissimos, iusto eaque nam illo fuga quisquam autem exercitationem. Pariatur dolor porro libero vero nisi reprehenderit odio quibusdam facere, voluptas, unde dolore aperiam! Veniam deserunt, tempore alias enim repudiandae soluta magni? Ea, molestias blanditiis atque hic eum expedita corporis, molestiae officiis dolor sequi at recusandae ullam quos perferendis vel exercitationem impedit perspiciatis provident nemo quisquam laudantium, labore saepe nihil delectus! Repudiandae modi voluptate quo praesentium autem. Rem maiores voluptate suscipit ducimus porro itaque, labore maxime nostrum corrupti laborum perspiciatis dolor repudiandae quod amet quidem corporis earum quis. Distinctio possimus quasi deserunt debitis libero? Assumenda sed placeat cum iusto, mollitia quisquam sint, doloremque rem voluptates, in explicabo. Dolorum incidunt qui, numquam perspiciatis sapiente saepe perferendis nostrum esse, praesentium ipsa, accusamus ullam voluptas natus error doloremque illo tempora a nihil obcaecati sit ratione quos. Minus dolores nisi odit ut quasi? Adipisci tempora quos aperiam aut tempore numquam nisi praesentium non sed eaque autem velit voluptas porro magni facilis, voluptates quaerat rerum voluptatum iure quod doloremque libero temporibus cum quas. Impedit voluptatibus dolorem aspernatur voluptate necessitatibus molestias aperiam, perspiciatis ipsa, quidem cupiditate vero similique error eligendi amet animi est nobis culpa tempore quisquam cum distinctio. Error esse molestiae expedita perspiciatis maxime. Sint dolores nulla culpa corrupti sequi iure vero suscipit excepturi, cum praesentium placeat odit impedit pariatur eveniet nesciunt nemo nihil nostrum ex libero, saepe maxime asperiores debitis ea veritatis? Ratione, reiciendis sunt! Assumenda odit omnis totam sint est, facere vel laborum ipsa dignissimos non nesciunt suscipit pariatur veniam sed neque ab voluptatem minima. Fugit soluta deserunt mollitia illum voluptate voluptatem amet adipisci et, eius quaerat maiores in laboriosam veniam, possimus saepe recusandae rem velit labore cum iusto quo cupiditate natus. Accusamus perferendis voluptatem aliquam odio incidunt qui necessitatibus magnam placeat vitae molestias rerum voluptatum dolore reiciendis mollitia, totam deserunt cumque enim ipsam a. Consequatur nisi, ab assumenda, ad odit delectus culpa quidem voluptatem officia quos adipisci. Quibusdam dolorem libero architecto facere repudiandae, distinctio aspernatur pariatur sequi consequuntur. Porro facilis, deserunt nesciunt beatae animi, voluptas maiores, numquam hic vel dicta assumenda fugit cum ratione cumque reiciendis. Aliquam, sit. Commodi ratione beatae laborum ex, vero optio quo fugiat blanditiis sed eos, iste magnam explicabo veniam culpa mollitia, facere rerum! Delectus, molestiae quae tempore sapiente libero cupiditate nemo cumque fugiat nisi aut doloribus obcaecati! Saepe rerum vero aut dolores praesentium atque qui numquam nesciunt, in repudiandae harum nulla iste! Sequi dolorem velit nobis. Ipsa eius animi obcaecati, ut neque reiciendis rerum quae placeat autem inventore, esse nobis consectetur expedita quo deleniti eos! Aliquam corporis corrupti magni, facilis enim voluptate. Ut quos sequi aspernatur fugiat assumenda quod voluptates, odio cum asperiores dolores at placeat obcaecati blanditiis nihil corrupti, nesciunt error doloremque aliquid! Voluptate, voluptatum voluptas numquam inventore magni repellat hic est optio minima praesentium libero repudiandae minus expedita fugit animi tempore labore dignissimos tempora consequuntur nobis omnis. Amet aspernatur architecto, omnis sed praesentium, eaque porro velit hic labore reiciendis harum ad veniam dolore deserunt soluta enim officiis nemo necessitatibus nulla quasi ipsam perferendis ea. Ducimus nesciunt aliquid velit fuga pariatur quisquam saepe. Repellat sit dolore deleniti eos. Earum laborum at optio rem itaque, quia in atque ut dolorem quas sapiente dolore, placeat, voluptatem possimus reiciendis cum facere nemo fugit autem amet tempore. Numquam laborum eligendi quia exercitationem quidem in cumque reprehenderit, quae ab harum beatae totam minus cum temporibus aliquam quasi distinctio. At deleniti nemo quod, quas est praesentium reprehenderit optio, atque, non voluptatum modi repudiandae ad inventore autem iste! Harum obcaecati, facere illo commodi accusantium sint iure impedit perferendis molestias adipisci alias rerum laborum asperiores! Hic culpa voluptatem nulla eaque facilis sapiente, facere nam aut libero vero sunt. Architecto eum eos autem voluptates magnam quod. Est libero autem aspernatur ab ratione ipsum fuga dolorum laborum, odio, consequuntur totam facilis! Dignissimos consequatur nostrum earum tempore perferendis suscipit similique? Eius, iste provident molestiae at incidunt, et veritatis, qui reprehenderit facilis unde vel inventore! Quia animi nulla, voluptates nam ratione magni assumenda necessitatibus harum? Quos enim eos error, cupiditate laudantium accusamus tenetur laborum temporibus explicabo, quidem ad. Labore corporis nesciunt in explicabo impedit vitae quam, inventore, quas voluptas voluptatibus architecto eum aperiam nobis consequuntur nemo, deleniti cupiditate illo repellendus repellat aspernatur provident officiis? A libero blanditiis placeat perspiciatis rerum corrupti ipsa vitae reprehenderit, earum excepturi maxime voluptate debitis obcaecati et. Error, quod suscipit, corrupti laborum in qui esse eveniet sit omnis totam rerum commodi soluta aliquam id sunt excepturi tempore, asperiores molestias est recusandae blanditiis accusantium eum numquam. Odio delectus, suscipit totam ad officia consequatur iste quam nemo, ut magnam porro voluptatem corporis eius vitae eos ipsam atque debitis! Repellendus corrupti minus illo porro iste beatae, est rerum culpa officiis omnis pariatur nobis voluptatem fugiat earum voluptatibus inventore, nam voluptates nulla dicta animi rem ut a. Fugit, temporibus? Aperiam, beatae. Pariatur at inventore debitis cumque. Error perspiciatis nesciunt, ea sequi in nostrum magnam rerum consequatur, placeat inventore sit omnis culpa quos quo accusantium molestias quisquam consectetur. Itaque repellat ipsum, eaque ab voluptates harum cupiditate nemo, ea perspiciatis assumenda sed? Ullam harum inventore excepturi quisquam dolores nisi temporibus error vitae ipsam repudiandae assumenda, quidem quam dolorem sequi sunt. Temporibus nam error, ipsam, commodi illum impedit assumenda consequuntur, ad reprehenderit animi pariatur. Ad non ex alias accusantium illo, dolor voluptatem rerum iure excepturi doloremque architecto consectetur id commodi impedit consequuntur quis. Quibusdam autem maiores iure adipisci rem? Illum, voluptas. Soluta incidunt voluptate dolorem voluptates nemo veniam sequi sunt esse cum, quia, dolorum, quod amet? Explicabo nostrum repudiandae aspernatur molestias amet laborum, cupiditate totam, non dolor tenetur reiciendis odit enim, pariatur quidem! Explicabo tempora aperiam fugiat? Architecto, assumenda harum fuga quia, aliquid suscipit veritatis deserunt, nostrum cumque unde ad?
  < /div>
< /body>
< /html>
</code></pre>
            <h2>Секции</h2>
            <pre><code>< !doctype html>
< html lang="en">
  < head>
    < meta charset="UTF-8" />
    < meta name="viewport" content="width=device-width, initial-scale=1.0" />
    < title>Sections< /title>

    < script>
      window.onpopstate = function (event) {
        showSection(event.state.section);
      };

      function showSection(section) {
        fetch(`/sections/${section}`)
          .then((response) => response.text())
          .then((text) => {
            document.querySelector("#content").innerHTML = text;
          });
      }

      document.addEventListener("DOMContentLoaded", function () {
        document.querySelectorAll("button").forEach((button) => {
          button.onclick = function () {
            const section = this.dataset.section;
            history.pushState({ section: section }, "", `section${section}`);
            showSection(section);
          };
        });
      });
    < /script>

    < style>
      body {
        font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
        color: #fff;
        background-color: #262c37;
      }
    < /style>
  < /head>
  < body>
    < h1>Hello!< /h1>
    < button data-section="1">Section 1< /button>
    < button data-section="2">Section 2< /button>
    < button data-section="3">Section 3< /button>
    < div id="content">
      Lorem ipsum dolor sit amet consectetur, adipisicing elit. Quia officiis
      est corrupti repudiandae alias doloribus facere labore eius fuga neque
      pariatur voluptate animi harum, inventore, praesentium incidunt vel nam.
      Repellendus quos harum at soluta officiis impedit molestias ipsam velit.
      Eaque beatae sit odio rem mollitia, sequi architecto neque ab alias
      adipisci aspernatur aut fugit facilis! Nemo explicabo eligendi repellat,
      voluptate eius blanditiis dicta molestias odit aperiam? Perferendis
      blanditiis eos quod ipsam deserunt maiores dolorum iure earum veniam
      obcaecati nam porro asperiores sint ipsa, doloremque dolorem itaque illum
      exercitationem id quidem. Laboriosam dolor quam, libero eius recusandae
      veniam aperiam at suscipit odio eaque temporibus minima itaque minus harum
      tempore placeat eveniet. Maxime, officiis perspiciatis vel odit recusandae
      fugiat voluptatem doloremque eaque minima quam ullam nam architecto
      molestias totam voluptas cum quisquam soluta adipisci sint facilis
      excepturi quo temporibus laborum? Quis corrupti cupiditate accusamus totam
      libero hic. Rem voluptatibus ut natus quaerat?
    < /div>
  < /body>
< /html>
</code></pre>
            <h2>Задачи</h2>
            <pre><code>< !DOCTYPE html>
< html lang="en">
< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Tasks< /title>

  < script>
    document.addEventListener('DOMContentLoaded', function() {

      //By default, submit button is disabled
      document.querySelector('#submit').disabled = true;

      document.querySelector('#task').onkeyup = () => {
        if (document.querySelector('#task').value.length > 0) {
          document.querySelector('#submit').disabled = false;
        } else {
          document.querySelector('#submit').disabled = true;
        }
        
      }

      document.querySelector('form').onsubmit = () => {
        const task = document.querySelector('#task').value;
        
        const li = document.createElement('li');
        li.innerHTML = task;

        document.querySelector('#tasks').append(li);

        document.querySelector('#task').value = '';
        

        // Stop form from submitting
        return false;
      }
    });
  < /script>

  < style>
    body {
      font-family: Arial, "Helvetica Neue", Helvetica, sans-serif;
      color: #fff;
      background-color: #262c37;
    }
  < /style>
< /head>
< body>
  < h1>Tasks< /h1>
  < ul id="tasks">< /ul>
  < form>
    < input id="task" placeholder="New Task" type="text">
    < input id="submit" type="submit">
  < /form>
< /body>
< /html>
</code></pre>
          </details>
        </details>
        <details> 
          <summary>TS</summary>
          <table> 
            <caption>Установка</caption>
            <tbody>
              <tr>
                <td>npm i typescript -g</td>
                <td>установить typescript</td>
              </tr>
              <tr>
                <td>tsc --init</td>
                <td>создать tsconfig.json</td>
              </tr>
              <tr>
                <td>tsc -w</td>
                <td>скомпилировать, -w - следить за изменениями</td>
              </tr>
              <tr>
                <td>tsc --noEmitOnError -w</td>
                <td>скомпилировать если нет ошибок, -w - следить за изменениями</td>
              </tr>
            </tbody>
          </table>
          <table> 
            <caption>В папке build создать index.html и подключить main.js</caption>
            <tbody> 
              <tr>
                <td>"rootDir": "./src"</td>
                <td>в tsconfig.json раскомментировать и указать папку разработки</td>
              </tr>
              <tr>
                <td>"outDir": "./build/js"</td>
                <td>в tsconfig.json раскомментировать и указать папку сборки</td>
              </tr>
              <tr>
                <td>"include": [ "src" ]</td>
                <td>добавить внизу tsconfig.json, чтобы автоматически компилировать только из папки src</td>
              </tr>
              <tr>
                <td>"noEmitOnError"</td>
                <td>если раскомментировать, то при наличии ошибок компилировать не будет</td>
              </tr>
            </tbody>
          </table>
          <h2>base ts</h2>
          <pre><code>type Address = {
  street: string
  city: string
  country: string
}

type Person = {
  name: string
  age: number
  isStudent: boolean

  // вложенный объект Address, ? - может быть или не быть
  address?: Address
}

let person1: Person = {
  name: "Joe",
  age: 42,
  isStudent: true,
}

let person2: Person = {
  name: "Jill",
  age: 66,
  isStudent: false,
  address: {
    street: "123 Main",
    city: "Anytown",
    country: "USA"
  }
}

// для массива из коробки тип указывать не обязательно
let ages: number[] = [100, 101]

// можно и так
let age = [100, 101]

type Person = {
  name: string
  age: number
  isStudent: boolean
}

let person1: Person = {
  name: "Joe",
  age: 42,
  isStudent: true,
}

let person2: Person = {
  name: "Jill",
  age: 66,
  isStudent: false,
}

// для массива значений пользовательского типа, тип указывать обязательно
let people: Person[] = [person1, person2]

// либо
let peoples: Array< Person> = [person1, person2]


// myName: string
let myName: string = "Bob"

// myName1: "Bob"  -  Literal types
let myName1: "Bob" = "Bob"

// myName2: "Bob"
const myName2 = "Bob"

// Union type
type UserRole = "guest" | "member" | "admin"

// может быть только либо "guest" либо "member" либо "admin"
let userRole: UserRole = "admin"

// либо вложенный
type User = {
  username: string,
  role: "guest" | "member" | "admin"
}

type UserRole1 = {
  user: User
}

let u: UserRole1 = {
  user: {
    username: "alice",

    // может быть только либо "guest" либо "member" либо "admin"
    role: "member"
  }
}

type User1 = {
  username: string
  role: UserRole
}

const users: User1[] = [
  { username: "john doe", role: "member" },
  { username: "jane doe", role: "admin" },
  { username: "guest_user", role: "guest" }
]

// функция возвращает тип User1
function fetchUser(username: string): User1 {
  const user = users.find(user => user.username === username)

  if (!user) {
    throw new Error(`User with ${username} not found`);
  }

  return user
}


// type any позволяет любой тип - отключает типизацию typescript
let value: any = 1
value.toUpperCase()
value = "Hi"
value.map()


// utility Types - берет тип и возвращает с изменениями
type User2 = {
  id: number
  username: string
  role: "member" | "contributor" | "admin"
}

// сделал копию User2, где все свойства опциональные (могут быть или не быть)
type UpdateUser2 = Partial< User2>

const users2: User2[] = [
  { id: 1, username: "john_doe", role: "member" },
  { id: 2, username: "jane_smith", role: "contributor" },
  { id: 3, username: "alice_jones", role: "admin" },
  { id: 4, username: "charlie_brown", role: "member" }
]

let nextUserId = 1

function updateUser(id: number, updates: UpdateUser2) {
  const foundUser = users2.find(user => user.id === id)

  if (!foundUser) {
    console.error("User not found!")
    return
  }

  Object.assign(foundUser, updates)
}

updateUser(1, { username: "new_john_doe" });
updateUser(4, { role: "contributor" });


// Omit< User2, "id"> - это User2, но без свойства id; "id" | "username" - без id и username
function addNewUser(newUser: Omit< User2, "id">): User2 {
  const user: User2 = {
    id: nextUserId++,
    ...newUser
  }
  users2.push(user)
  return user
}

addNewUser({ username: "joe_schmoe", role: "member" })


// generics
const gameScores = [14, 21, 33, 42, 59]
const favoriteThings = [
  "raindrops on roses",
  "whiskers on kittens",
  "bright copper kettles",
  "warm woolen mittens"
]
const voters = [
  { name: "Alice", age: "42" },
  { name: "Bob", age: 77 }]
</code></pre>
          <ul>
            <li>&lt;T&gt; - generic, показывает что будет какой-то тип, а T[] - показывает что этот тип - элемент массива</li>
            <li>полезно для обработки массивов с разными типами элементов одной функцией</li>
            <li>без generic пришлось бы писать отдельную функцию для каждого массива, т.к. тип элементов у массивов разный</li>
          </ul>
          <pre><code>function getLastItem< T>(array: T[]): T {
  return array[array.length - 1]
}
</code></pre>
          <h2>lessons ts</h2>
          <p>lesson ts 1 types</p>
          <pre><code>let username = 'Dave'
console.log(username)

let a: number = 12

// js компилируется и будет работать, но для ts исправить на let b: number = 6
let b: string = '6'
let c: number = 2

console.log(a / b)

console.log(c * b)
</code></pre>
          <p>lesson ts 2 any | union</p>
          <pre><code>let myName: string = 'Dave'
let meaningOfLife: number;
let isLoading: boolean;
let album: any;

myName = 'John'
meaningOfLife = 42
isLoading = true
album = 5150

// если не указать тип, то по умолчанию будет тип any
const sum = (a: number, b: string) => {
  return a + b
}

// union type - значения могут быть string или number
let postId: string | number
let isActive: number | boolean

let re: RegExp = /\w+/g
</code></pre>
          <p>lesson ts 3 objects: array, tuple, Enums</p>
          <pre><code>// stringArr: string[]
let stringArr = ['one', 'hey', 'Dave']

// guitars: ( string | number )[]
let guitars = ['Strat', 'Les Paul', 5150]

// mixedData ( string | number | boolean )[]
let mixedData = ['EVH', 1984, true]

stringArr[0] = 'John'
stringArr.push('hey')

guitars[0] = 1984
guitars.unshift('Jim')

// test: any[]
let test = []
let bands: string[] = []
bands.push('Van Halen')

// Tuple - более строгий чем array, указывает тип каждого элемента отдельно
let myTuple: [string, number, boolean] = ['Dave', 42, true]

// mixed: ( string | number | boolean )[]
let mixed = ['John', 1, false]

myTuple[1] = 42

// Objects
let myObj: object

// array is object
myObj = []
console.log(typeof myObj)
myObj = bands
myObj = {}

// exampleObj: { prop1: string, prop2: boolean }
const exampleObj = {
  prop1: 'Dave',
  prop2: true,
}

exampleObj.prop1 = 'John'

// Интерфейс - это как класс, а type - это как псевдоним для группы стандартных типов
// interface Guitarist {...} тоже самое type Guitarist = {...}
interface Guitarist {

  // ? - может быть или не быть, т.е. string | undefined
  name?: string,
  active: boolean,
  albums: (string | number)[]
}

let evh: Guitarist = {
  name: 'Eddie',
  active: false,

  // number and string
  albums: [1984, 5150, 'OU812']
}

let jp: Guitarist = {
  active: true,

  // только string без number
  albums: ['I', 'II', 'IV']
}

const greetGuitarist = (guitarist: Guitarist) => {
  if (guitarist.name) {

    // guitarist.name?.toUpperCase() - если с ?, то без if(...)
    return `Hello ${guitarist.name.toUpperCase()}!`
  }
  return 'Hello!'
}

console.log(greetGuitarist(jp))

// Enums 
// "Unlike most TypeScript features, Enums are not a type-level addition to JavaScript but something added to the language and runtime."

enum Grade {
  // по умолчанию первый элемент = 0, далее по нарастающей А будет = 4. Если U = 1, то А будет = 5
  U = 1,
  D,
  C,
  B,
  A,
}

console.log(Grade.U)
</code></pre>
          <p>lesson ts 4 literal types, type aliases, interface, functions, never, parameters (optional, default, rest)</p>
          <pre><code>// Type Aliases 
type stringOrNumber = string | number

type stringOrNumberArray = (string | number)[]

type Guitarist = {
  name?: string,
  active: boolean,
  albums: stringOrNumberArray
}

type UserId = stringOrNumber



// Literal types
let myName: 'Dave'

let userName: 'Dave' | 'John' | 'Amy'
userName = 'Amy'



// functions
const add = (a: number, b: number): number => {
  return a + b
}

// void - ничего не возвращает
const logMsg = (message: any): void => {
  console.log(message)
}

logMsg('Hello!')
logMsg(add(2, 3))

let subtract = function (c: number, d: number): number {
  return c - d
}



// Type Alias for function
type mathFunction = (a: number, b: number) => number

// можно и так, но interface лучше использовать для классов, а type alias для стандартных типов и функций
// interface mathFunction {
//     (a: number, b: number): number
// }

let multiply: mathFunction = function (c, d) {
  return c * d
}

logMsg(multiply(2, 2))




// у type alias и interface optional parameters работают, а default param value не работают

// optional parameters 
const addAll = (a: number, b: number, c?: number): number => {
  if (typeof c !== 'undefined') {
    return a + b + c
  }
  return a + b
}

// default param value
const sumAll = (a: number = 10, b: number, c: number = 2): number => {
  return a + b + c
}

logMsg(addAll(2, 3, 2))       // 7
logMsg(addAll(2, 3))          // 5
logMsg(sumAll(2, 3))          // 7
logMsg(sumAll(undefined, 3))  // 15

// Rest Parameters, ... - rest operator
const total = (a: number, ...nums: number[]): number => {
  return a + nums.reduce((prev, curr) => prev + curr)
}

logMsg(total(10, 2, 3))  // 15

// type never - означает что нужно выбрасывать ошибку
const createError = (errMsg: string): never => {
  throw new Error(errMsg)
}

// функция ничего не возвращает const infinite = (): void
const infinite = () => {
  let i: number = 1
  while (true) {
    i++

    // если без if (i > 100) break, то будет бесконечный цикл, тогда const infinite = (): never
    if (i > 100) break
  }
}

// custom type guard 
const isNumber = (value: any): boolean => {
  return typeof value === 'number'
    ? true : false
}

// use of the never type 
const numberOrString = (value: number | string): string => {
  if (typeof value === 'string') return 'string'
  if (isNumber(value)) return 'number'

  // на случай если не number и не string
  return createError('This should never happen!')
}
</code></pre>
          <p>lesson ts 5 Type Assertion (Type Casting)</p>
          <pre><code>// index.html
< !DOCTYPE html>
< html lang="en">
  < head>
    < meta charset="UTF-8" />
    < meta http-equiv="X-UA-Compatible" content="IE=edge" />
    < meta name="viewport" content="width=device-width, initial-scale=1.0" />
    < title>Copyright</ title>
    < style>
      body {
        margin: 0;
        min-height: 100vh;
        background-color: #000;
        display: grid;
        place-content: center;
        font-size: 3rem;
        color: #fff;
      }
    </ style>
    < script src="js/copyright.js" defer></ script>
  </ head>

  < body>
    < p>Copyright &copy; < span id="year"></ span></ p>
  </ body>
</ html>

// copyright.ts

// Original JS code
// const year = document.getElementById("year")
// const thisYear = new Date().getFullYear()
// year.setAttribute("datetime", thisYear)
// year.textContent = thisYear

// 1st variation: (Beginner)
// let year: HTMLElement | null
// year = document.getElementById("year")
// let thisYear: string
// thisYear = new Date().getFullYear().toString()
// if (year) {
//     year.setAttribute("datetime", thisYear)
//     year.textContent = thisYear
// }

// 2nd variation: (with Type Assertion)

// обозначаю что это за элемент в файле index.html 
const year = document.getElementById("year") as HTMLSpanElement

// new Date().getFullYear() даёт number, поэтому перевожу в string
const thisYear: string = new Date().getFullYear().toString()
year.setAttribute("datetime", thisYear)
year.textContent = thisYear


// main.ts
type One = string
type Two = string | number
type Three = 'hello'

// convert to more or less specific 
let a: One = 'hello'

// less specific 
let b = a as Two

// more specific
let c = a as Three

// d: string = 'world'
let d = < One>'world'

// e: string | number = 'world'
let e = < string | number>'world'

const addOrConcat = (a: number, b: number, c: 'add' | 'concat'): number | string => {
  if (c === 'add') return a + b
  return '' + a + b
}

// addOrConcat может вернуть number | string, as string - говорит что будет string
// as string - type assertion
let myVal: string = addOrConcat(2, 2, 'concat') as string

// Be careful! TS sees no problem - but a string is returned
let nextVal: number = addOrConcat(2, 2, 'concat') as number

//10 as string
// error
// two type assertion (double casting or force casting)
(10 as unknown) as string

// The DOM 

// const img: HTMLImageElement | null, ! - not null; const img: HTMLImageElement
const img = document.querySelector('img')!

// без as HTMLImageElement, будет какой-то html элемент const myImg: HTMLElement | null
const myImg = document.getElementById('#img') as HTMLImageElement

// не работает в файлах ts для react
const nextImg = < HTMLImageElement>document.getElementById('#img')

img.src
myImg.src
</code></pre>
          <p>lesson ts 6 Classes</p>
          <pre><code>class Coder {

  // ! - мне не нужна инициализация переменной, я знаю что делаю
  secondLang!: string

  constructor(
    // указываю модификаторы доступа public, private, protected, чтобы не объявлять переменные ещё раз вне конструктора
    // name свойство объявлено, доступно, только для чтения, тип string
    public readonly name: string,

    // music свойство объявлено, доступно, изменяемо, тип string
    public music: string,

    // age свойство объявлено, доступно в пределах класса, изменяемо, тип number
    private age: number,

    // lang свойство объявлено, доступно в классе и в наследниках класса, изменяемо, тип string
    // 'Typescript' - значение по умолчанию
    protected lang: string = 'Typescript'
  ) {
    // инициализация свойств
    this.name = name
    this.music = music
    this.age = age
    this.lang = lang
  }

  public getAge() {
    return `Hello, I'm ${this.age}`
  }
}

// не требует указать параметр для свойства lang, т.к. у него есть значение по умолчанию
const Dave = new Coder('Dave', 'Rock', 42)
console.log(Dave.getAge())

// ошибка, свойство private - доступ только внутри класса
// console.log(Dave.age)

// ошибка, свойство protected - доступ только внутри класса и в его наследниках
// console.log(Dave.lang)

// наследник расширяет класс родителя, берет то что есть у родителя и добавляет или меняет своим
class WebDev extends Coder {
  constructor(
    public computer: string,
    name: string,
    music: string,
    age: number,
  ) {
    // super() обязательно при наследовании класса - беру у родителя свойства, свойство lang имеет значение по умолчанию, можно не инициализировать
    super(name, music, age)
    this.computer = computer
  }

  // добавил функцию
  public getLang() {

    // у наследника есть доступ к protected свойству родителя (lang)
    return `I write ${this.lang}`
  }
}

// Sara - сущность типа WebDev
const Sara = new WebDev('Mac', 'Sara', 'Lofi', 25)
console.log(Sara.getLang())

// нет доступа вне класса к private свойству
// console.log(Sara.age)

// нет доступа вне класса и наследника к protected свойству
// console.log(Sara.lang)
/////////////////////////////////////

interface Musician {
  // интерфейс с двумя свойствами и методом
  name: string,
  instrument: string,
  play(action: string): string
}

// реализует интерфейс
class Guitarist implements Musician {
  name: string
  instrument: string

  constructor(name: string, instrument: string) {
    this.name = name
    this.instrument = instrument
  }

  play(action: string) {
    return `${this.name} ${action} the ${this.instrument}`
  }
}

const Page = new Guitarist('Jimmy', 'guitar')

// Jimmy strums the guitar
console.log(Page.play('strums'))
//////////////////////////////////////

class Peeps {

  // static используется только внутри класса и не применяется в объектах и наследниках этого класса
  static count: number = 0

  static getCount(): number {
    return Peeps.count
  }

  public id: number

  constructor(public name: string) {
    this.name = name

    // ++Peeps.count - первый id = 1, Peeps.count++ - первый id = 0
    this.id = ++Peeps.count
  }
}

// создал сущности Peeps типа
const John = new Peeps('John')
const Steve = new Peeps('Steve')
const Amy = new Peeps('Amy')

// 1
console.log(Amy.id)

// 2
console.log(Steve.id)

// 3
console.log(John.id)

// 3 - количество инициализаций сущностей класса Peeps
console.log(Peeps.count)
//////////////////////////////////

class Bands {
  private dataState: string[]

  constructor() {
    this.dataState = []
  }

  // get - ключевое слово гетера, получить значение private dataState
  public get data(): string[] {
    return this.dataState
  }

  // set - ключевое слово сетера, записать значение в private dataState
  public set data(value: string[]) {
    if (Array.isArray(value) && value.every(el => typeof el === 'string')) {
      this.dataState = value

      // return пустой, т.к. сетер не может возвращать значение, return чтобы выйти из if ()
      return
    } else throw new Error('Param is not an array of strings')
  }
}

const MyBands = new Bands()
MyBands.data = ['Neil Young', 'Led Zep']
console.log(MyBands.data)
MyBands.data = [...MyBands.data, 'ZZ Top']
console.log(MyBands.data)

// must be string data
MyBands.data = ['Van Halen', 5150]
</code></pre>
          <p>lesson ts 7 Index Signatures & keyof Assertions</p>
          <pre><code>// Index Signatures - когда нужен динамический доступ к значению свойства

// создать интерфейс с Index Signature без указания ключей
// interface TransactionObj {
//     readonly [index: string]: number
// }

// указать какие ключи должны быть обязательно, в сущностях типа TransactionObj можно добавлять свои ключи типа number
interface TransactionObj {

  // Index Signature - все ключи типа string и значения типа number, только для чтения
  readonly [index: string]: number
  Pizza: number,
  Books: number,
  Job:   number
}

const todaysTransactions: TransactionObj = {
  Pizza: -10,
  Books: -5,
  Job: 50,
}

// -10
console.log(todaysTransactions.Pizza)

// -10
console.log(todaysTransactions['Pizza'])

let prop: string = 'Pizza'

// динамический доступ к значению свойства (переменная в качестве индекса)
console.log(todaysTransactions[prop])

const todaysNet = (transactions: TransactionObj): number => {
  let total = 0
  for (const transaction in transactions) {

    // динамический доступ к значению свойства в цикле (переменная в качестве индекса)
    total += transactions[transaction]
  }
  return total
}

console.log(todaysNet(todaysTransactions))

// ошибка - свойства TransactionObj только для чтения
//todaysTransactions.Pizza = 40

// ошибки нет, но вернёт undefined - такого ключа нет
console.log(todaysTransactions['Dave'])

///////////////////////////////////

// keyof Assertions

interface Student {
  //[key: string]: string | number | number[] | undefined
  name: string,
  GPA: number,
  classes?: number[]
}

const student: Student = {
  name: "Doug",
  GPA: 3.5,
  classes: [100, 200]
}

// console.log(student.test)

for (const key in student) {

  // если нет Index Signature, то keyof Assertions - as keyof Student
  console.log(`${key}: ${student[key as keyof Student]}`)
}

Object.keys(student).map(key => {
  // я не знаю какого типа ключи у объекта student, поэтому указываю сам объект как тип - typeof student
  console.log(student[key as keyof typeof student])
})

// определяю тип ключей при передаче параметров функции
const logStudentKey = (student: Student, key: keyof Student): void => {
  console.log(`Student ${key}: ${student[key]}`)
}

logStudentKey(student, 'name')

/////////////////////////////////

// interface Incomes {
//     [key: string]: number
// }

type Streams = 'salary' | 'bonus' | 'sidehustle'

// Record<> ключи из Streams и тип значения number, это Index Signature когда нужно указать варианты ключей, а не просто их тип
type Incomes = Record< Streams, number>

const monthlyIncomes: Incomes = {
  salary: 500,
  bonus: 100,
  sidehustle: 250
}

for (const revenue in monthlyIncomes) {

  // если нет Index Signature, то keyof Assertions - as keyof Incomes
  console.log(monthlyIncomes[revenue as keyof Incomes])
}
</code></pre>
          <p>lesson ts 8 Generics</p>
          <pre><code>// когда функция может работать с объектами разных типов и ты не знаешь заранее какой будет тип у используемого объекта, нужен плейсхолдер для указания типа объекта в будущем
const echo = < T>(arg: T): T => arg

//////////////////////////////////

// проверяет тип переданного параметра, если тип object, то вернёт true
const isObj = <T>(arg: T): boolean => {
  return (typeof arg === 'object' && !Array.isArray(arg) && arg !== null)
}

console.log(isObj(true))                // false
console.log(isObj('John'))              // false
console.log(isObj([1, 2, 3]))           // false
console.log(isObj({ name: 'John' }))    // true
console.log(isObj(null))                // false

///////////////////////////////////

const isTrue = <T>(arg: T): { arg: T, is: boolean } => {

  // проверяю, что это Array и он не пустой
  if (Array.isArray(arg) && !arg.length) {
    return { arg, is: false }
  }

  // проверяю, что это объект и он не пустой
  if (isObj(arg) && !Object.keys(arg as keyof T).length) {
    return { arg, is: false }
  }

  //!!arg - дважды поменяет на противоположное boolean, т.е. если = 0 или false, то сначала станет true, потом false, а если = какое то значение или true, то сначала станет false, потом true
  return { arg, is: !!arg }
}

console.log(isTrue(false))               // false
console.log(isTrue(0))                   // false
console.log(isTrue(true))                // true
console.log(isTrue(1))                   // true
console.log(isTrue('Dave'))              // true
console.log(isTrue(''))                  // false
console.log(isTrue(null))                // false
console.log(isTrue(undefined))           // false
console.log(isTrue({}))                  // modified false, объект есть, но он пустой
console.log(isTrue({ name: 'Dave' }))    // true
console.log(isTrue([]))                  // modified false, массив есть, но он пустой
console.log(isTrue([1, 2, 3]))           // true
console.log(isTrue(NaN))                 // false
console.log(isTrue(-0))                  // false

////////////////////////////////////

// тоже самое, но через интерфейс
// const isTrue = < T>(arg: T): { arg: T, is: boolean } заменил на const checkBoolValue = < T>(arg: T): BoolCheck< T>

interface BoolCheck< T> {
  value: T,
  is: boolean,
}

const checkBoolValue = < T>(arg: T): BoolCheck< T> => {
  if (Array.isArray(arg) && !arg.length) {
    return { value: arg, is: false }
  }
  if (isObj(arg) && !Object.keys(arg as keyof T).length) {
    return { value: arg, is: false }
  }
  return { value: arg, is: !!arg }
}

//////////////////////////////////////


interface HasID {
  id: number
}

// < T extends HasID> - любой переданный объект user должен иметь свойство id типа number
const processUser = < T extends HasID>(user: T): T => {
  // process the user with logic here 
  return user
}

console.log(processUser({ id: 1, name: 'Dave' }))

// ошибка - не указано свойство id
//console.log(processUser({ name: 'Dave'}))

///////////////////////////////////////


const getUsersProperty = < T extends HasID, K extends keyof T>(users: T[], key: K): T[K][] => {
  return users.map(user => user[key])
}

const usersArray = [
  {
    "id": 1,
    "name": "Leanne Graham",
    "username": "Bret",
    "email": "Sincere@april.biz",
    "address": {
      "street": "Kulas Light",
      "suite": "Apt. 556",
      "city": "Gwenborough",
      "zipcode": "92998-3874",
      "geo": {
        "lat": "-37.3159",
        "lng": "81.1496"
      }
    },
    "phone": "1-770-736-8031 x56442",
    "website": "hildegard.org",
    "company": {
      "name": "Romaguera-Crona",
      "catchPhrase": "Multi-layered client-server neural-net",
      "bs": "harness real-time e-markets"
    }
  },
  {
    "id": 2,
    "name": "Ervin Howell",
    "username": "Antonette",
    "email": "Shanna@melissa.tv",
    "address": {
      "street": "Victor Plains",
      "suite": "Suite 879",
      "city": "Wisokyburgh",
      "zipcode": "90566-7771",
      "geo": {
        "lat": "-43.9509",
        "lng": "-34.4618"
      }
    },
    "phone": "010-692-6593 x09125",
    "website": "anastasia.net",
    "company": {
      "name": "Deckow-Crist",
      "catchPhrase": "Proactive didactic contingency",
      "bs": "synergize scalable supply-chains"
    }
  },
]

// соберёт в массив значения свойства email каждого user из usersArray
console.log(getUsersProperty(usersArray, "email"))

// соберёт в массив значения свойства username каждого user из usersArray
console.log(getUsersProperty(usersArray, "username"))

///////////////////////////////////////

class StateObject< T> {
  private data: T

  constructor(value: T) {
    this.data = value
  }

  get state(): T {
    return this.data
  }

  set state(value: T) {
    this.data = value
  }
}

// инициализация value = John, у свойства data тип string - сработал constructor
const store = new StateObject("John")

// сработал get - получил значение John
console.log(store.state)

// сработал set - записал значение "Dave"
store.state = "Dave"

// ошибка - у свойства data тип string
//store.state = 12

// сработал constructor - инициализация value = 15, у свойства data тип union[], т.е. (string | number | boolean)[]
const myState = new StateObject<(string | number | boolean)[]>([15])

// сработал set - записал значение ['Dave', 42, true]
myState.state = ['Dave', 42, true]

// сработал get - получил значение John
console.log(myState.state)
</code></pre>
          <p>lesson ts 9 Utility Types</p>
          <pre><code>// Utility Types 

// Partial - берём часть свойств

interface Assignment {
  studentId: string,
  title: string,
  grade: number,
  verified?: boolean,
}

const updateAssignment = (assign: Assignment, propsToUpdate: Partial< Assignment>): Assignment => {
  return { ...assign, ...propsToUpdate }
}

const assign1: Assignment = {
  studentId: "compsci123",
  title: "Final Project",
  grade: 0,
}

/**
* взял сущность assign1 и обновил одно её свойство grade
*/
console.log(updateAssignment(assign1, { grade: 95 }))
const assignGraded: Assignment = updateAssignment(assign1, { grade: 95 })


// Required and Readonly 

/**
* Required - требует все свойства Assignment и опциональные тоже
*/
const recordAssignment = (assign: Required< Assignment>): Assignment => {
  // send to database, etc. 
  return assign
}

/**
* Readonly - нельзя перезаписать значения свойств полученного объекта
* добавляю в assignVerified свойство verified: true, т.к. в assignGraded его не было
*/ 
const assignVerified: Readonly< Assignment> = { ...assignGraded, verified: true }

// NOTE: assignVerified won't work with recordAssignment!
// Why? Try it and see what TS tells you :)

// verified: true - обязательно, т.к. у assignGraded нет свойства verified,
// а Required< Assignment> функции recordAssignment требует все свойства Assignment
recordAssignment({ ...assignGraded, verified: true })

// Record
// Record< string, string> - ключи и значения будут типа string
const hexColorMap: Record< string, string> = {
  red: "FF0000",
  green: "00FF00",
  blue: "0000FF",
}

type Students = "Sara" | "Kelly"
type LetterGrades = "A" | "B" | "C" | "D" | "U"

// ключи выбирать из Students, а значения выбирать из LetterGrades
const finalGrades: Record< Students, LetterGrades> = {
  Sara: "B",
  Kelly: "U"
}

interface Grades {
  assign1: number,
  assign2: number,
}

const gradeData: Record< Students, Grades> = {
  Sara: { assign1: 85, assign2: 93 },
  Kelly: { assign1: 76, assign2: 15 },
}

// Pick and Omit - работает с интерфейсами

// выбрал из интерфейса Assignment свойства studentId и grade для нового типа AssignResult
type AssignResult = Pick< Assignment, "studentId" | "grade">

// AssignResult имеет два свойства, тип который объявлен в Assignment
const score: AssignResult = {
  studentId: "k123",
  grade: 85,
}

// создал тип AssignPreview из интерфейса Assignment без свойств grade и verified
type AssignPreview = Omit< Assignment, "grade" | "verified">

const preview: AssignPreview = {
  studentId: "k123",
  title: "Final Project",
}

// Exclude and Extract - работает с union types
// создать тип adjustedGrade из union type LetterGrades без варианта "U"
type adjustedGrade = Exclude< LetterGrades, "U">

// создать тип highGrades из union type LetterGrades, выбрав только варианты "A" и "B"
type highGrades = Extract< LetterGrades, "A" | "B">

// Nonnullable 
type AllPossibleGrades = 'Dave' | 'John' | null | undefined

// создать union тип NamesOnly из union типа AllPossibleGrades без null и undefined
type NamesOnly = NonNullable< AllPossibleGrades>

// ReturnType 

//type newAssign = { title: string, points: number }

const createNewAssign = (title: string, points: number) => {
  return { title, points }
}

// NewAssign создал тип со свойствами и типами свойств, которые объявлены в функции createNewAssign как параметры, если изменить функцию createNewAssign, то NewAssign обновится автоматически
*/
type NewAssign = ReturnType< typeof createNewAssign>

// { title: "Utility Types", points: 100 }
const tsAssign: NewAssign = createNewAssign("Utility Types", 100)
console.log(tsAssign)

// Parameters - получить параметры из функции в виде tuple
// type AssignParams = [title: string, points: number]
type AssignParams = Parameters< typeof createNewAssign>

const assignArgs: AssignParams = ["Generics", 100]

const tsAssign2: NewAssign = createNewAssign(...assignArgs)

// { title: "Generics", points: 100 }
console.log(tsAssign2)

// Awaited - helps us with the ReturnType of a Promise 

interface User {
  id: number,
  name: string,
  username: string,
  email: string,
}

const fetchUsers = async (): Promise< User[]> => {

  const data = await fetch(
    'https://jsonplaceholder.typicode.com/users'
  ).then(res => {
    return res.json()
  }).catch(err => {
    if (err instanceof Error) console.log(err.message)
  })
  return data
}

// ReturnType - вернёт тип функции fetchUsers, т.е. Promise< User[]>
// Awaited - вернёт тип результата, который вернёт функция fetchUsers, т.е. User[]
type FetchUsersReturnType = Awaited< ReturnType< typeof fetchUsers>>

// выведет массив объектов user, полученных функцией fetchUsers
fetchUsers().then(users => console.log(users))
</code></pre>
          <p>pizza project</p>
          <pre><code>type Pizza = {
  id: number
  name: string
  price: number
}

type Order = {
  id: number,
  pizza: Pizza,
  status: "ordered" | "completed"
}

let cashInRegister = 100
let nextOrderId = 1
let nextPizzaId = 1

const menu: Pizza[] = [
  { id: nextPizzaId++, name: "Margherita", price: 8 },
  { id: nextPizzaId++, name: "Pepperoni", price: 10 },
  { id: nextPizzaId++, name: "Hawaiian", price: 10 },
  { id: nextPizzaId++, name: "Veggie", price: 9 },
]
const orderQueue: Order[] = []

function addNewPizza(pizzaObj: Omit<Pizza, "id">): Pizza {
  const newPizza = {
    id: nextPizzaId++,
    ...pizzaObj
  }
  menu.push(newPizza)
  return newPizza
}

function placeOrder(pizzaName: string): Order | undefined {
  const selectedPizza = menu.find(pizzaObj => pizzaObj.name === pizzaName)
  if (!selectedPizza) {
    console.error(`${pizzaName} does not exist in the menu`)
    return
  }
  cashInRegister += selectedPizza.price
  const newOrder: Order = { id: nextOrderId++, pizza: selectedPizza, status: "ordered" }
  orderQueue.push(newOrder)
  return newOrder
}

function addToArray<T>(array: T[], item: T): T[] {
  array.push(item)
  return array
}

addToArray(menu, { id: nextPizzaId++, name: "Chicken Bacon Ranch", price: 12 })

// уточняю тип < Order>, чтобы был выбор варианта status только установленный в типе Order
addToArray< Order>(orderQueue, { id: nextPizzaId++, pizza: menu[2], status: "completed" })

function completeOrder(orderId: number): Order | undefined {
  const order = orderQueue.find(order => order.id === orderId)
  if (!order) {
    console.error(`${orderId} does not exist in the orderQueue`)
    return
  }
  order.status = "completed"
  return order
}

// функция может вернуть значение или выдать ошибку
function getPizzaDetail(identifier: string | number): Pizza | undefined {
  if (typeof identifier === "string") {
    return menu.find(pizza => pizza.name.toLowerCase() === identifier.toLowerCase())
  } else if (typeof identifier === "number") {
    return menu.find(pizza => pizza.id === identifier)
  } else {
    throw new TypeError("Parameter `identifier` must be either a string or a number")
  }
}

addNewPizza({ name: "Chicken Bacon Ranch", price: 12 })
addNewPizza({ name: "BBQ Chicken", price: 12 })
addNewPizza({ name: "Spicy Sausage", price: 11 })

placeOrder("Chicken Bacon Ranch")
completeOrder(1)
</code></pre>
          <p>todo project</p>
          <pre><code>// model/ListItem.ts
export interface Item {
  id: string,
  item: string,
  checked: boolean,
}

export default class ListItem implements Item {

  // подчеркивание - это неписанное соглашение для названия переменной, которая используется только в пределах класса, приватная переменная, инициализация в объявлении параметров, поэтому тело конструктора {} пустое
  constructor(
    private _id: string = '',
    private _item: string = '',
    private _checked: boolean = false,
  ) { }

  get id(): string {
    return this._id
  }

  set id(id: string) {
    this._id = id
  }

  get item(): string {
    return this._item
  }

  set item(item: string) {
    this._item = item
  }

  get checked(): boolean {
    return this._checked
  }

  set checked(checked: boolean) {
    this._checked = checked
  }
}

// model/FullList.ts
import ListItem from './ListItem'

interface List {

  // состояние списка
  list: ListItem[],
  load(): void,
  save(): void,
  clearList(): void,
  addItem(itemObj: ListItem): void,
  removeItem(id: string): void,
}

export default class FullList implements List {

  // этот класс singleton, т.к. по нему будет создан всего один объект, т.к. в программе всего один список поэтому инициализация объекта автоматически доступна static instance и сразу вызывает конструктор этого класса new FullList(), конструктор приватный, чтобы не было другого способа его вызвать
  static instance: FullList = new FullList()

  // определить _list: ListItem[] согласно интерфейса и инициализировать [] состояние списка в параметре конструктора
  private constructor(private _list: ListItem[] = []) { }

  get list(): ListItem[] {
    return this._list
  }

  load(): void {

    // получить из localStorage список, сохранённых под именем myList, полученный список присвоить переменной storedList, список может быть получен (storedList: string) или нет (storedList: null), если список не получен (storedList: null), то выйти из функции
    const storedList: string | null = localStorage.getItem("myList")

    // typeguard
    if (typeof storedList !== "string") return
    const parsedList: { _id: string, _item: string, _checked: boolean }[] = JSON.parse(storedList)

    // перебрать полученный список - массив записей-объектов
    // itemObj - запись из списка, объект, который содержит свойства _id, _item и _checked, согласно интерфейса
    // из свойств объекта сиздать объект-запись конструктором из файла model/ListItem.ts
    // добавить запись в автоматически доступный объект списка FullList.instance для рендера в templates/ListTemplate.ts

    parsedList.forEach(itemObj => {
      const newListItem = new ListItem(itemObj._id, itemObj._item, itemObj._checked)
      FullList.instance.addItem(newListItem)
    })
  }

  // сохраняю список в localStorage браузера под именем myList
  save(): void {
    localStorage.setItem("myList", JSON.stringify(this._list))
  }

  clearList(): void {

    // обнулить состояние списка
    this._list = []

    // сохранить список в localStorage
    this.save()
  }

  addItem(itemObj: ListItem): void {
    this._list.push(itemObj)
    this.save()
  }

  removeItem(id: string): void {
    this._list = this._list.filter(item => item.id !== id)
    this.save()
  }
}

// templates/ListTemplate.ts
import FullList from "../model/FullList"

interface DOMList {
  ul: HTMLUListElement,
  clear(): void,
  render(fullList: FullList): void,
}

export default class ListTemplate implements DOMList {

  // объявил переменную ul типа HTMLUListElement
  ul: HTMLUListElement

  static instance: ListTemplate = new ListTemplate()

  private constructor() {

    // инициализация - найти по id элемент в разметке и присвоть его переменной ul
    this.ul = document.getElementById("listItems") as HTMLUListElement
  }

  // удалил всё внутри ul
  clear(): void {
    this.ul.innerHTML = ''
  }

  // рендерить список
  render(fullList: FullList): void {
    this.clear()

    // перебрать список и для каждого элемента списка создать элемент li
    // fullList.list - т.к. в объекте fullList есть свойство list с нашей информацией, т.е. список записей
    // свойство list из конструктора класса FullList
    fullList.list.forEach(item => {
      const li = document.createElement("li") as HTMLLIElement
      li.className = "item"

      // создал чек-бокс, item.id и item.checked - срабатывает гетер класса ListItem
      const check = document.createElement("input") as HTMLInputElement
      check.type = "checkbox"
      check.id = item.id
      check.checked = item.checked
      li.append(check)

      // слушать клики по чек-боксу, переключать его и сохранять в localStorage
      check.addEventListener('change', () => {
        item.checked = !item.checked
        fullList.save()
      })

      // вывести текст записи
      const label = document.createElement("label") as HTMLLabelElement
      label.htmlFor = item.id
      label.textContent = item.item
      li.append(label)

      // создать кнопку удаления записи
      const button = document.createElement("button") as HTMLButtonElement
      button.className = 'button'
      button.textContent = 'X'
      li.append(button)

      // слушать клик по кнопке удаления
      // вызвать функцию удаления из model/FullList.ts: удалит запись и сохранит список без записи в localStorage
      // перерендерить список без удаленной записи
      button.addEventListener('click', () => {
        fullList.removeItem(item.id)
        this.render(fullList)
      })

      this.ul.append(li)
    })
  }
}

// main.ts
import './css/style.css'
import FullList from './model/FullList'
import ListItem from './model/ListItem'
import ListTemplate from './templates/ListTemplate'

const initApp = (): void => {
  const fullList = FullList.instance
  const template = ListTemplate.instance

  // Add listener to new entry form submit
  const itemEntryForm = document.getElementById("itemEntryForm") as HTMLFormElement

  itemEntryForm.addEventListener("submit", (event: SubmitEvent): void => {
    event.preventDefault()

    // Get the new item value
    const input = document.getElementById("newItem") as HTMLInputElement
    const newEntryText: string = input.value.trim()
    if (!newEntryText.length) return

    // calculate item ID
    const itemId: number = fullList.list.length
      ? parseInt(fullList.list[fullList.list.length - 1].id) + 1
      : 1

    // create new item
    const newItem = new ListItem(itemId.toString(), newEntryText)
    // Add new item to full list
    fullList.addItem(newItem)
    // Re-render list with new item included
    template.render(fullList)
  })

  // Add listener to "Clear" button
  const clearItems = document.getElementById("clearItemsButton") as HTMLButtonElement

  // обнулить список в localStorage и убрать из разметки
  clearItems.addEventListener('click', (): void => {
    fullList.clearList()
    template.clear()
  })

  // load initial data
  fullList.load()
  // initial render of template
  template.render(fullList)
}

document.addEventListener("DOMContentLoaded", initApp) 

// index.html
< !DOCTYPE html>
< html lang="en">

< head>
  < meta charset="UTF-8">
  < meta http-equiv="X-UA-Compatible" content="IE=edge">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>My List</ title>
  < link rel="stylesheet" href="/src/css/style.css">
  < script type="module" src="/src/main.ts" defer></ script>
</ head>

< body>
  < main>
    < h1 class="offscreen">My List</ h1>

    < section class="newItemEntry">
      < h2 class="offscreen">New Item Entry</ h2>
      < form class="newItemEntry__form" id="itemEntryForm">
        < label for="newItem" class="offscreen">Enter a new to do item</ label>
        < input class="newItemEntry__input" id="newItem" type="text" maxlength="40" autocomplete="off" placeholder="Add item" />
        < button id="addItem" class="button newItemEntry__button" title="Add new item" aria-label="Add new item to list">
          +
        </ button>
      </ form>
    </ section>

    < section class="listContainer">
      < header class="listTitle">
        < h2 id="listName">List</ h2>
        < button id="clearItemsButton" class="button listTitle__button" title="Clear the list" aria-label="Remove all items from the list">
          Clear
        </ button>
      </ header>
      < hr />
      < ul id="listItems">

      // эта разметка уже не нужна, т.к. создаётся в ts динамически
        < li class="item">
          < input type="checkbox" id="1">
          < label for="1">eat</ label>
          < button class="button">X</ button>
        </ li>
        < li class="item">
          < input type="checkbox" id="2">
          < label for="2">sleep</ label>
          < button class="button">X</ button>
        </ li>
        < li class="item">
          < input type="checkbox" id="3">
          < label for="3">code</ label>
          < button class="button">X</ button>
        </ li>
      </ ul>
    </ section>
  </ main>
</ body>

</ html>

// main css
// style.css
@import url("https://fonts.googleapis.com/css2?family=Poppins&display=swap");

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

.offscreen {
  position: absolute;
  left: -10000px;
}

input,
button {
  font: inherit;
}

html {
  font-family: "Poppins", sans-serif;
}

body {
  min-height: 100vh;
  background-color: #333;
  color: #fff;
  padding: 1rem;
  display: flex;
  flex-direction: column;
}

main {
  flex-grow: 1;
  margin: auto;
  width: 100%;
  max-width: 800px;
  display: flex;
  flex-flow: column nowrap;
}

section {
  border: 1px solid whitesmoke;
  border-radius: 10px;
  padding: 0.5rem;
}

.button {
  border-radius: 10px;
  min-width: 48px;
  min-height: 48px;
}

.button:hover {
  cursor: pointer;
}

.newItemEntry {
  position: sticky;
  top: 0;
  margin-bottom: 1rem;
}

.newItemEntry__form {
  display: flex;
  gap: 0.25rem;
  font-size: 1.5rem;
}

.newItemEntry__input {
  width: calc(100% - (0.25rem + 48px));
  flex-grow: 1;
  border: 2px solid whitesmoke;
  border-radius: 10px;
  padding: 0.5em;
}

.newItemEntry__button {
  background-color: transparent;
  color: whitesmoke;
  border: 3px dashed whitesmoke;
  padding: 0.75em;
}

.newItemEntry__button:hover,
.newItemEntry__button:focus {
  color: limegreen;
}

.listContainer {
  font-size: 1.5rem;
  flex-grow: 1;
  display: flex;
  flex-flow: column;
  gap: 1rem;
}

.listTitle {
  display: flex;
  justify-content: space-between;
  align-items: flex-end;
}

.listTitle__button {
  background-color: transparent;
  color: whitesmoke;
  padding: 0.25em;
}

.listItems {
  flex-grow: 1;
  display: flex;
  flex-flow: column nowrap;
  list-style-type: none;
}

.item {
  display: flex;
  align-items: center;
  padding-top: 1em;
  gap: 1em;
}

.item > input[type="checkbox"] {
  text-align: center;
  min-width: 2.5rem;
  min-height: 2.5rem;
  cursor: pointer;
}

.item > input[type="checkbox"]:checked + label {
  text-decoration: line-through;
}

.item > label {
  flex-grow: 1;
  word-break: break-all;
}

.item > button:hover,
.item > button:focus {
  color: red;
}

@media (min-width: 768px) {
  section {
    padding: 1rem;
  }
  .newItemEntry__form {
    gap: 0.5rem;
  }
}</code></pre>
        </details>
      </main>
      <menu class="menu">
        <button id="search"><img src="./assets/img/search.svg" alt="search" loading="lazy"/></button>
        <button id="home"><img src="./assets/img/q.svg" alt="home" loading="lazy"/></button>
        <button id="dropup"><img src="./assets/img/menu.svg" alt="menu" loading="lazy"/></button>
      </menu>
    </div>
  </body>
</html>