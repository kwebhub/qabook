<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="format-detection" content="telephone=no">
    <meta name="robots" content="noindex, nofollow">
    <meta name="robots" content="none">
    <meta name="robots" content="noimageindex, nofollow">
    <link rel="icon" type="image/svg+xml" href="./assets/favicon.svg">
    <link rel="stylesheet" type="text/css" href="./assets/style.css">
    <title>qabook</title>
    <script defer type="module" src="./assets/js/main.js"></script>
  </head>
  <body>
    <nav class="dropup"><a href="./process.html">Process</a><a href="./docs.html">Docs</a><a href="./layout.html">Layout</a><a href="./web.html">Web</a><a href="./langs.html">Langs</a><a href="#!">Project</a><a href="./job.html">Job</a>
    </nav>
    <div class="search">
      <form class="search__content">
        <input type="text" placeholder="search...">
        <button class="search-btn" type="submit"><img src="./assets/img/search.svg" alt="" loading="lazy"/>
        </button>
        <button class="search-reset" type="reset"><img src="./assets/img/close.svg" alt="" loading="lazy"/>
        </button>
      </form>
    </div>
    <button class="close"><img src="./assets/img/close.svg" alt="" loading="lazy"/>
    </button>
    <div class="container">
      <header><nav class="breadcrumbs" id="breadcrumbs-container"></nav>
      </header>
      <main>
        <h2>Internet (Интернет)</h2>
        <ul>
          <li>Всемирная система объединённых компьютерных сетей для хранения, обработки и передачи информации.</li>
          <li>Сеть сетей, которая объединяет в себе компьютеры, маршрутизаторы и сервера.</li>
          <li>Очень большая сеть компьютеров, которые взаимодействую друг с другом.</li>
          <li>Интернет - это инфраструктура, а ВЭБ - это сервис, построенный на основе этой инфраструктуры.</li>
        </ul>
        <p>Всемирная паутина (World Wide Web) — распределённая система, предоставляющая доступ к связанным между собой документам, расположенным на различных компьютерах, подключённых к сети Интернет.</p>
        <p>Веб-служба, веб-сервис (web service) — идентифицируемая уникальным веб-адресом (URL-адресом) программная система со стандартизированными интерфейсами, а также HTML-документ сайта, отображаемый браузером пользователя.</p>
        <details>
          <summary>Браузер</summary>
          <h2>Браузер</h2>
          <p>Браузер - это программа, которая позволяет искать информацию в интернете, просматривать сайты, скачивать и загружать файлы.</p>
          <ul>
            <li>Это среднее звено между пользователем и интернетом.</li>
            <li>Пользователь вводит в адресную строку браузера адрес сайта.</li>
            <li>Браузер ищет сервер по IP-адресу. Сервер - это программа.</li>
            <li>Сначала он ищет в кэше роутера, операционной системе или в истории подключений.</li>
            <li>Потом смотрит в DNS.</li>
            <li>Найдя нужный IP-адрес, браузер устанавливает соединение с сервером с помощью протокола TCP/IP.</li>
            <li>Для установки соединения используется процесс 'рукопожатие' (handshaking).</li>
            <li>Браузер отправляет HTTP запрос на сервер для отображения страницы.</li>
            <li>Запрос обрабатывается вэб-сервером.</li>
          </ul>
          <p>После этого сервер отправляет браузеру ответ с данными:</p>
          <ul>
            <li>файлы cookie</li>
            <li>способ кэширования</li>
            <li>контент страницы</li>
          </ul>
          <p>Браузер обрабатывает ответ и отображает запрашиваемый контент (рендеринг).</p><img src="./assets/img/contimg/cookie.png" alt="" loading="lazy"/>
          <h2>Cookie</h2>
          <p>
            Это маленький файл, который сохраняется в браузере клиента и содержит информацию про пользователя.<br />
            Когда клиент обращается к серверу браузер автоматически включает куки в запрос.<br />
            Это позволяет серверу идентифицировать пользователя и сохранить про него данные (язык, местонахождение, настройки).
            
          </p>
        </details>
        <details>
          <summary>Net</summary>
          <h2>Net</h2>
          <p>
            Internet, Ethernet, WI-FI, WLAN, IP, MAC, Маска подсети, VLAN</br>
            OSI и TCP/IP - уровни и типы данных: сегменты, датаграммы, пакеты, биты, кадры</br>
            OSI (Open Systems Interconnection) - эталонная модель: модель взаимодействия открытых систем:
          </p>
          <ul>
            <li>эталонная модель организации компьютерных сетей</li>
            <li>юридический стандарт организации ISO</li>
            <li>7 уровней организации сети и их назначение</li>
            <li>протоколы не включены в модель</li>
            <li>не используется на практике, удобна для описания компьютерных сетей</li>
          </ul>
          <table>
            <caption>Уровни OSI</caption>
            <thead>
              <tr>
                <th>Уровень</th>
                <th>Единица</th>
                <th>Оборудование</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Прикладной</td>
                <td>Сообщение</td>
                <td>На хосте</td>
              </tr>
              <tr>
                <td>Представления</td>
                <td>Сообщение</td>
                <td>На хосте</td>
              </tr>
              <tr>
                <td>Сеансовый</td>
                <td>Сообщение</td>
                <td>На хосте</td>
              </tr>
              <tr>
                <td>Транспортный</td>
                <td>Сегмент/Дейтаграмма</td>
                <td>На хосте</td>
              </tr>
              <tr>
                <td>Сетевой</td>
                <td>Пакет</td>
                <td>Маршрутизатор</td>
              </tr>
              <tr>
                <td>Канальный</td>
                <td>Кадр</td>
                <td>Коммутатор, точка доступа Wi-Fi</td>
              </tr>
              <tr>
                <td>Физический</td>
                <td>Бит</td>
                <td>Концентратор, репитор</td>
              </tr>
            </tbody>
          </table>
          <p>Физический уровень - основная задача это передача битов по физическому каналу связи, т.е. перевод битов в сигналы и обратно. Бит - 0 или 1. Сигналы передаются по:</p>
          <ul>
            <li>перепады напряжения для меди</li>
            <li>импульсы для оптоволокна</li>
            <li>электромагнитное излучение для радиосвязи</li>
          </ul>
          <p>Передача потока бит по среде передачи данных:</p>
          <ul>
            <li>не вникает в смысл передаваемой информации</li>
            <li>единица передачи информации - бит (...01100111001...)</li>
          </ul>
          <p>Скорость канала:</p>
          <ul>
            <li>Пропускная способность (бит/с) - количество передачи данных за единицу времени.</li>
            <li>Задержка - сколько времени пройдёт пока сообщение от отправителя дойдёт до получателя.</li>
            <li>Количество ошибок - если возникают часто, то сетевое оборудование должно иметь инструменты их исправления, если редко, то ошибки можно исправлять на более высоких уровнях.</li>
          </ul>
          <p>Типы каналов связи:</p>
          <ul>
            <li>Симплексный - передача только в одну сторону.</li>
            <li>Дуплексный - передача данных в обе стороны одновременно.</li>
            <li>Полудуплексный - передача данных в обе стороны по очереди.</li>
          </ul>
          <p>Кабель - ошибки редко:</p>
          <ul>
            <li>Витая пара - скрученные для уменьшения помех медные кабели.</li>
            <li>Оптический кабель - тонкие световоды объединяются в один кабель.</li>
          </ul>
          <p>Беспроводные технологии - ошибки часто:</p>
          <ul>
            <li>Радиоволны - GSM 900 МГц лицензируется, Wi-Fi 2,4 ГГц и 5 ГГц без лицензий.</li>
            <li>Спутниковые каналы.</li>
          </ul>
          <table>
            <caption>Представление информации</caption>
            <tbody>
              <tr>
                <td>Медные провода</td>
                <td>кодирование</td>
                <td>прямоугольные импульсы</td>
              </tr>
              <tr>
                <td>Оптоволокно, беспроводная среда</td>
                <td>модуляция</td>
                <td>синусоидальные волны</td>
              </tr>
            </tbody>
          </table>
          <p>Канальный уровень:</p>
          <ul>
            <li>определяет начало/конец сообщения в потоке бит</li>
            <li>обнаруживает и исправляет ошибки</li>
            <li>управляет доступом к среде передачи данных (одномоментно передаёт только один.)</li>
            <li>физическая адресация (МАС)</li>
          </ul>
          <p>Сетевой уровень:</p>
          <ul>
            <li>создание составной сети и согласование различий в сетях</li>
            <li>адресация (сетевые и глобальные адреса)</li>
            <li>определение маршрута пересылки пакетов в составной сети (маршрутизация)</li>
          </ul>
          <p>Транспортный уровень:</p>
          <ul>
            <li>передача данных между процессами на хостах</li>
            <li>управляет надёжностью (защищённый от ошибок канал с гарантированным порядком следования сообщений)</li>
            <li>сквозной уровень от отправителя к получателю</li>
          </ul>
          <p>Сеансовый уровень:</p>
          <ul>
            <li>создаёт сеансы связи</li>
            <li>управляет диалогом (очерёдностью передачи сообщений)</li>
            <li>управляет маркерами (не допускает одновременно выполнять критические операции)</li>
            <li>синхронизация (метки в сообщениях для возобновления передачи в случае сбоя связи)</li>
            <li>на практике сеансовый уровень в сетях не используется</li>
          </ul>
          <p>Уровень представления:</p>
          <ul>
            <li>согласование форматов представления символов и чисел</li>
            <li>шифрование и дешифрование</li>
          </ul>
          <p>Прикладной уровень - приложения:</p>
          <ul>
            <li>web-страницы</li>
            <li>соц.сети</li>
            <li>видео и аудио связь</li>
            <li>почта</li>
            <li>доступ к файлам и т.д.</li>
          </ul>
          <p>
            TCP/IP - произошло от TCP и IP.<br />
            Набор правил, который позволяет обрабатывать сквозную передачу данных.<br />
            Сюда входит: формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.
          </p>
          <table>
            <caption>TCP/IP - модель протокола</caption>
            <thead>
              <tr>
                <th>TCP/IP</th>
                <th>Протоколы в заголовках сообщений</th>
                <th>Задачи</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Application</td>
                <td>HTTP (передача данных в формате HTML)</td>
                <td>Показ пользователю, кодирование, шифрование, управление сеансами</td>
              </tr>
              <tr>
                <td>Transport</td>
                <td>TCP (порт приложения, контроль доставки)</td>
                <td>Установка соединения между устройствами в разных сетях</td>
              </tr>
              <tr>
                <td>Internet</td>
                <td>IP (нахождение устройства по ip-адресу)</td>
                <td>Межсетевой маршрут от отправителя к получателю</td>
              </tr>
              <tr>
                <td>Network access</td>
                <td>Ethernet (общение между сетевыми картами в одной сети)</td>
                <td>Управление устройствами внутри сети</td>
              </tr>
            </tbody>
          </table>
          <p>Классификация и топология сетей: звезда, шина, кольцо</p>
          <p>URI</p>
          <ul>
            <li>URI (Uniform Resource Indicator) - унифицированный идентификатор ресурса: включает в себя URL, URN и другие способы указания ресурса.</li>
            <li>URI данных - это не URL или URN, содержит данные, например: data:Hello%20World.</li>
            <li>URL (Uniform Resource Locator) — унифицированный указатель ресурса) - адрес, который выдан уникальному ресурсу в интернете. Такими ресурсами могут быть html-страница, css-файл, изображение и т.д.</li>
            <li>URN (Uniform Resource Name) - унифицированное имя ресурса: является уникальным именем объекта и включает в себя название пространства имен и идентификатора в этом пространстве.</li>
            <li>URC (Uniform Resource Characteristic) - единая характеристика ресурса: содержит метаинформацию о ресурсе / описание ресурса, например: view-source: http://example.com/</li>
          </ul><img src="./assets/img/contimg/URI.png" alt="" loading="lazy"/>
          <table>
            <caption>Виды идентификаторов ресурсов</caption>
            <thead> 
              <tr>
                <th>Имя</th>
                <th>Описание</th>
                <th>Пример</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td><a href="http://docs.oasis-open.org/xri/2.0/specs/xri-syntax-V2.0.html">XRI</a></td>
                <td>Обобщенный URI для унификации многообразия идентификаторов</td>
                <td>xri://broadview.library.example.com/(urn:isbn:0-395-36341-1)</td>
              </tr>
              <tr>
                <td><a href="https://ru.wikipedia.org/wiki/Internationalized_Resource_Identifier">IRI</a></td>
                <td>URI с локализацией для удобства использования в не англоговорящих странах</td>
                <td>http://ru.wikipedia.org/wiki/Кириллица</td>
              </tr>
              <tr>
                <td><a href="https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3">URI</a></td>
                <td>Единый идентификатор ресурса</td>
                <td>mailto:John.Doe@example.com</td>
              </tr>
              <tr>
                <td><a href="https://en.wikipedia.org/wiki/URL">URL</a></td>
                <td>Единый локатор ресурса. Указывает на место, где ресурс расположен</td>
                <td>file://C:\UserName.HostName\Projects\Wikipedia_Articles\URI.xml</td>
              </tr>
              <tr>
                <td><a href="https://en.wikipedia.org/wiki/Uniform_Resource_Name">URN</a></td>
                <td>Единое имя ресурса. Независимо от его расположения</td>
                <td>urn:isbn:0451450523</td>
              </tr>
              <tr>
                <td><a href="http://sti15.com/bib/formats/urc.html">URC</a></td>
                <td>Единая характеристика ресурса. Содержит метаинформацию о ресурсе / описание ресурса</td>
                <td>URN:IANA:626:oit:cs:ftp-and-telnet; URL:http://www.gatech.edu/oit/cs/ftp-and-telnet.html;</td>
              </tr>
              <tr>
                <td><a href="https://ru.wikipedia.org/wiki/PURL">PURL</a></td>
                <td>Постоянный URL. Защищает от перемещения ресурса (404)</td>
                <td>http://purl.russian-books.com/WarAndPeace/chapter12.html</td>
              </tr>
              <tr>
                <td><a href="https://www.paulirish.com/2010/the-protocol-relative-url/">PRURL</a></td>
                <td>URL, способный определить схему по контексту использования</td>
                <td>//domain.com/img/logo.png</td>
              </tr>
              <tr>
                <td><a href="https://en.wikipedia.org/wiki/CURIE">CURIE</a></td>
                <td>Compact URI. Сокращенное представление URI</td>
                <td>[isbn:0393315703]</td>
              </tr>
            </tbody>
          </table><img src="./assets/img/contimg/XRI.png" alt="" loading="lazy"/>
          <p>
            ISP (internet service provider) — поставщик интернет-услуги (иногда просто провайдер) — организация, предоставляющая услуги доступа к сети Интернет и иные связанные с Интернетом услуги.<br />
            Хостинг (hosting) — услуга по предоставлению ресурсов для размещения информации на сервере, постоянно находящемся в сети (обычно Интернет).<br />
            Это комбинация программных и аппаратных технологий, позволяющая разместить в интернете сайт, приложение, базу данных и их составные компоненты, требующие постоянного нахождения в онлайне.
          </p>
          <ul>
            <li>Два основных термина: хостинг-сервер и хостинг-провайдер.</li>
            <li>Сервер - компьютер, на котором хранятся файлы сайта или приложения. Работает 24/7.</li>
            <li>Хостинг-провайдер - компания, обслуживающая сервер и создающая ПО для него.</li>
            <li>Процессор, оперативная память и дисковое пространство сервера передаются клиенту в пользование за плату.</li>
          </ul>
          <p>Сетевое оборудование: сетевая карта, маршрутизатор, точка доступа, коммутатор, ретранслятор, витая пара, оптоволокно.</p>
          <p>Клиент-серверная архитектура: взаимодействие сервера, клиента и БД - что происходит при отправке запроса на сервер.</p>
          <p>Отличия идентификации, аутентификации и авторизации, виды авторизации, куки</p>
          <p>Что такое DNS, кэш и веб-сокет</p>
          <p>Домен (доменное имя) – это псевдоним для IP-адреса понятный для человека, состоящий из набора символов и цифр.</p>
          <ul>
            <li>Каждое доменное имя в Интернете является уникальным.</li>
            <li>Максимальная длина доменного имени (между точками) – 63 символа.</li>
            <li>Общая длина имени, включая поддомены, разделительные точки и имя зоны домена, может составлять до 255 знаков.</li>
          </ul>
          <p>DNS (Domain Name System) — система доменных имён: компьютерная распределённая система для получения информации о доменах.</p>
          <ul>
            <li>Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства).</li>
            <li>Когда пользователь вводит доменное имя в браузере, браузер отправляет DNS - запрос на DNS-сервер для преобразования доменного имени в IP-адрес.</li>
            <li>DNS-сервер прослушивает порт 53.</li>
            <li>DNS - это распределённая база данных, которая сопоставляет доменные имена с IP-адресами.</li>
          </ul>
          <p>Система адресов интернета имеет иерархическую структуру:</p>
          <ul>
            <li>домены уровня страны (.us)</li>
            <li>домены верхнего уровня (.com)</li>
            <li>поддомены</li>
          </ul>
          <p>
            Протокол — документ, фиксирующий какое-либо событие, факт или договоренность.</br>
            Веб-протокол, также известный как протокол передачи данных - это набор правил, который описывает последовательность взаимодействия двух и более устройств, подключённых к одной сети.
          </p>
          <p>Протоколы:</p>
          <ul>
            <li>IPv4, IPv6</li>
            <li>ICMP, ICMPv6</li>
            <li>DHCP, DHCPv6</li>
            <li>TCP,  UDP</li>
            <li>HTTP, HTTPS</li>
            <li>SSH,  Ethernet</li>
            <li>ARP,  PPP</li>
            <li>FTP,  SFTP</li>
            <li>SMTP, POP3</li>
          </ul>
          <table>
            <caption>Характеристики протокола</caption>
            <tbody>
              <tr>
                <td>Формат сообщения</td>
                <td>зависит от типа сообщения и канала передачи</td>
              </tr>
              <tr>
                <td>Розмер сообщения</td>
                <td>зависит от канала передачи</td>
              </tr>
              <tr>
                <td>Синхронизация</td>
                <td>определяет в какой очередности и с какой скоростью узлы будут отправлять сообщения</td>
              </tr>
              <tr>
                <td>Инкапсуляция</td>
                <td>добавление к фрагменту сообщения заголовка с данными об отправиле и получете</td>
              </tr>
              <tr>
                <td>Шаблон сообщения</td>
                <td>требуется ли подтверждение о получении сообщения перед отправкой следующего или нет</td>
              </tr>
              <tr>
                <td>Кодирование</td>
                <td>биты кодируются отправителем в виде световых, электрических или электромагнитных импульсов, взависимости от среды передачи сигнала. Получатель эти импульсы декодирует в биты.</td>
              </tr>
            </tbody>
          </table>
          <h2>Ethernet</h2>
          <p>
            После преамбулы все компьютеры в сети начинают записывать передаваемый кадр в свой буфер.</br>
            Первые 6 байт кадра содержат адрес получателя:
          </p>
          <ul>
            <li>компьютер, который узнал свой адрес, продолжает записывать кадр</li>
            <li>остальные удаляют кадр из буфера</li>
          </ul>
          <p>
            Для диагностики сети удобно использовать Promiscuous mode (неразборчивый режим работы сетевого адаптера) - адаптер принимает все кадры в сети, не зависимо от МАС-адреса получателя.<br />
            Недостатки классического Ethernet:
            
          </p>
          <p>Плохая масштабируемость:</p>
          <ul>
            <li>сеть становиться неработоспособной при загрузки разделяемой среды больше чем на 30%</li>
            <li>работоспособное количество компьютеров - 30</li>
          </ul>
          <p>Низкая безопасность - данные в разделяемой среде доступны всем.</p>
          <p>Разное время доставки кадра:</p>
          <ul>
            <li>причина - коллизии</li>
            <li>плохо для трафика реального времени (аудиозвонок, видеоконференция)</li>
          </ul>
          <p>
            В распределяемой среде возможны коллизии.<br />
            В коммутируемом Ethernet соединение Точка-Точка без разделяемой среды.
            
          </p>
          <h2>IP & Port</h2>
          <p>
            Internet Protocol (IP, досл. «межсетевой протокол») - маршрутизируемый протокол сетевого уровня стека TCP/IP.<br />
            Именно IP стал тем протоколом, который объединил отдельные компьютерные сети во всемирную сеть Интернет.<br />
            Неотъемлемой частью протокола является адресация сети - IP-адрес.<br />
            <br />
            IP-адрес — уникальный сетевой адрес узла в компьютерной сети, построенной на основе стека протоколов TCP/IP.<br />
            В сети Интернет требуется глобальная уникальность адреса, в случае работы в локальной сети требуется уникальность адреса в пределах сети.<br />
            Чтобы обратиться к какому-то компьютеру, каждый компьютер, подключенный к сети, имеет свой уникальный адрес - IP-адрес.<br />
            <br />
            Каждый компьютер, подключенный к интернету, может быть доступен через публичный IP-адрес, который состоит из 32 бит для IPv4 (такие адреса обычно записываются в виде четырёх чисел от 0 до 255, разделённых точками: 173.194.121.32) или 128 бит для IPv6 (обычно записываются в виде 8 групп по 4 шестнадцатеричных числа, разделённых двоеточиями: 2027:0da8:8b73:0000:0000:8a2e:0370:1337).<br />
            <br />
            ICANN (Internet Corporation for Assigned Names and Numbers) - Корпорация по управлению доменными именами и IP-адресами.<br />
          </p><a href="https://www.icann.org">ICANN</a><br><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">Service Name and Transport Protocol Port Number Registry</a>
          <p>Сокет - комбинация исходного IP-адреса и номера порта источника, или IP-адреса и номера порта назначения.</p>
          <ul>
            <li>192.168.1.5:1099 - сокет источника</li>
            <li>192.168.1.7:80   - сокет веб сервера</li>
          </ul>
          <p>
            Netstat – это сетевая утилита, которая может использоваться для проверки соединений.<br />
            Параметр -n - отображение IP-адресов и номеров портов в числовом виде.<br />
            Порты назначаются и управляются организацией, известной как ICANN.<br />
            Порты делятся на три категории и имеют число от 1 до 65535:
          </p>
          <ul>
            <li>Хорошо известные порты – порты назначения, связанные с общими сетевыми программами, идентифицируются как хорошо известные порты. Эти порты находятся в диапазоне от 1 до 1023.</li>
            <li>Зарегистрированные порты – порты от 1024 до 49151 можно использовать в качестве портов источника или назначения. Они могут быть использованы организациями для регистрации конкретных приложений, таких как программы чата.</li>
            <li>Частные порты – порты от 49 152 до 65 535, которые часто используются как порты источника.&lt;br /&gt;Эти порты могут использоваться любыми приложениями.</li>
          </ul>
          <table>
            <caption>Команды</caption>
            <tbody>
              <tr>
                <td>ipconfig</td>
                <td>информация про IP-конфигурацию</td>
              </tr>
              <tr>
                <td>ping</td>
                <td>проверка соединения с другими IP-хостами</td>
              </tr>
              <tr>
                <td>netstat</td>
                <td>просмотр сетевых соединений</td>
              </tr>
              <tr>
                <td>tracert</td>
                <td>просмотр маршрута до места назначения</td>
              </tr>
              <tr>
                <td>nslookup</td>
                <td>информация про домен</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Команда ipconfig /all предназначена для просмотра расширенной информации, включая MAC-адреса, IP-адреса шлюза по умолчанию и DNS-серверы.</li>
            <li>Также указывается, включен ли протокол DHCP и выводятся данные адреса DHCP-сервера и информация об аренде.</li>
            <li>Если используется динамическое назначение IP-адресов, команда ipconfig /release удаляет существующие привязки адресов DHCP.</li>
            <li>Команда ipconfig /renew запрашивает текущую конфигурацию с DHCP-сервера. Хост может содержать ошибочную или устаревшую информацию о конфигурации IP, и простое обновление этой информации – это все, что нужно для восстановления соединения.</li>
          </ul>
          <p>
            TCP (Transmission Control Protocol) - протокол управления передачей.<br />
            Обмен данными, ориентированный на соединения, может использовать надежную связь, для обеспечения которой протокол уровня 4 (транспортный) посылает подтверждения о полученных данных и запрашивает повторную передачу, если данные не получены или искажены.
          </p>
          <p>
            Пакеты в TCP называются сегментами.<br />
            TCP используется в прикладных протоколах HTTP, FTP, SMTP, Telnet.<br />
            Перед отправкой сообщения по протоколу TCP соединение должно быть открыто.<br />
            Механизм TCP предоставляет поток данных с предварительной установкой соединения, осуществляет повторный запрос данных в случае потери данных и устраняет дублирование при получении двух копий одного пакета.<br />
          </p>
          <p>
            Процесс начала сеанса TCP (также называемый «*рукопожатие*» (handshake)), состоит из трёх шагов.<br />
            Клиент, который намеревается установить соединение, посылает серверу сегмент с номером последовательности и флагом SYN.
          </p>
          <ul>
            <li>Сервер получает сегмент, запоминает номер последовательности и пытается создать сокет (буфера и управляющие структуры памяти) для обслуживания нового клиента.</li>
            <li>В случае успеха сервер посылает клиенту сегмент с номером последовательности и флагами SYN и ACK, и переходит в состояние SYN-RECEIVED.</li>
            <li>В случае неудачи сервер посылает клиенту сегмент с флагом RST.</li>
          </ul>
          <p>Если клиент получает сегмент с флагом SYN, то он запоминает номер последовательности и посылает сегмент с флагом ACK.</p>
          <ul>
            <li>Если клиент одновременно получает и флаг ACK (что обычно и происходит), то он переходит в состояние ESTABLISHED.</li>
            <li>Если клиент получает сегмент с флагом RST, то он прекращает попытки соединиться.</li>
            <li>Если клиент не получает ответа в течение 10 секунд, то он повторяет процесс соединения заново.</li>
          </ul>
          <p>
            Если сервер в состоянии SYN-RECEIVED получает сегмент с флагом ACK, то он переходит в состояние ESTABLISHED.<br />
            В противном случае после тайм-аута он закрывает сокет и переходит в состояние CLOSED.
            
          </p>
          <p>
            UDP - User Datagram Protocol. В отличии от TCP, UDP - очень быстрый протокол поскольку в нём определён самый минимальный механизм необходимый для передачи данных.<br />
            Сообщения поступают в любом порядке и то, которое отправлено первым, может быть получено последним.<br />
            Доставка сообщений UDP вовсе не гарантируется, сообщение может потеряться и могут быть получены две копии одного и того же сообщения.<br />
            Такой случай возникает если для отправки сообщений в один адрес использовать два разных маршрута.<br />
            UDP не требует открывать соединение и данные могут быть отправлены сразу же как только они подготовлены.<br />
            UDP не отправляет подтверждающие сообщения, поэтому данные могут быть потеряны.
            
          </p>
          <p>
            HyperText Transfer Protocol (HTTP) — протокол передачи гипертекста: протокол прикладного уровня передачи данных.<br />
            Изначально — в виде гипертекстовых документов в формате HTML (документов, которые содержат ссылки, позволяющие переходить к другим документам).<br />
            В настоящий момент используется для передачи произвольных данных).
          </p>
          <p>Основой HTTP является технология «клиент-сервер», то есть предполагается существование потребителей (клиентов), которые инициируют соединение и посылают запрос, и поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.</p>
          <ul>
            <li>Обычно с помощью протокола HTTP осуществляется обмен данными между вэб-браузером и вэб-сервером.</li>
            <li>Благодаря протоколу HTTP обеспечивается работа всемирной паутины.</li>
            <li>Также HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как: SOAP, XML-RPC, WebDAV.</li>
            <li>В таком случае говорят, что протокол HTTP используется как транспорт.</li>
            <li>API многих программных продуктов использую HTTP для передачи данных - сами данные при этом могут иметь любой формат: XML или JSON.</li>
            <li>Как правило передача данных по протоколу HTTP осуществляется через TCP/IP-соединения.</li>
            <li>Серверное ПО при этом обычно использует TCP-порт 80, хотя может использовать и любой другой.</li>
          </ul>
          <p>
            HTTP-structure: каждое HTTP-сообщение состоит из трёх частей: Starting line, HTTP Headers, Message body.<br />
            Starting line (Стартовая строка) — определяет тип сообщения.<br />
            <br />
            Стартовая строка запроса: Method - URI - Version.
          </p>
          <ul>
            <li>Method - метод запроса.</li>
            <li>URI - путь к запрашиваемому документу.</li>
            <li>Version - версия протокола, пара разделенных точкой цифр. Например: 1.0</li>
          </ul>
          <p>Стартовая строка ответа: Version - Status Code - Reason Phrase.</p>
          <ul>
            <li>Version - версия протокола, пара разделенных точкой цифр. Например: 1.0</li>
            <li>Код состояния (Status Code) — три цифры.</li>
            <li>Код состояния является частью первой строки ответа сервера.</li>
            <li>Он представляет собой целое число из трёх цифр.</li>
            <li>Первая цифра указывает на класс состояния.</li>
          </ul>
          <p>HTTP-status:</p>
          <ul>
            <li>Informational responses (100 – 199).</li>
            <li>1xx - Информационный: информирование о процессе передачи.</li>
            <li>В HTTP/1.0 — сообщения с такими кодами должны игнорироваться.</li>
            <li>В HTTP/1.1 — клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно.</li>
            <li>Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка.</li>
            <li>Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту.</li>
          </ul>
          <ul>
            <li>Successful responses (200 – 299).</li>
            <li>2xx - Успех: информирование о случаях успешного принятия и обработки запроса клиента.</li>
            <li>В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.</li>
          </ul>
          <ul>
            <li>Redirection messages (300 – 399).</li>
            <li>3xx - Перенаправление: сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI).</li>
            <li>Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект).</li>
            <li>Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. Допускается использование фрагментов в целевом URI.</li>
          </ul>
          <ul>
            <li>Client error responses (400 – 499).</li>
            <li>4xx - Ошибка клиента: указание ошибок со стороны клиента.</li>
            <li>При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.</li>
          </ul>
          <ul>
            <li>Server error responses (500 – 599).</li>
            <li>5xx - Ошибка сервера: информирование о случаях неудачного выполнения операции по вине сервера.</li>
            <li>Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.</li>
          </ul>
          <p>
            По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента.<br />
            Пояснение (Reason Phrase) — отделённая пробелом поясняющая фраза к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.
          </p>
          <p>
            Тип HTTP-запроса (также называемый HTTP-метод) указывает серверу на то, какое действие мы хотим произвести с ресурсом.<br />
            HTTP-method:
          </p>
          <ul>
            <li>OPTIONS - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса.</li>
            <li>GET - Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс.</li>
            <li>HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.&lt;br /&gt;Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.</li>
            <li>POST - Применяется для передачи пользовательских данных заданному ресурсу.&lt;br /&gt;Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса.</li>
            <li>PUT - Применяется для загрузки содержимого запроса на указанный в запросе URI.&lt;br /&gt;Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус 201 (Created).&lt;br /&gt;Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content).</li>
            <li>PATCH - Аналогично PUT, но применяется только к фрагменту ресурса.</li>
            <li>DELETE - Удаляет указанный ресурс.</li>
            <li>TRACE  - Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.</li>
            <li>CONNECT - Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.</li>
          </ul>
          <p>HTTP Headers:</p>
          <ul>
            <li>Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение.</li>
            <li>Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA (см. RFC 822).</li>
            <li>Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.</li>
          </ul>
          <p>Message body: тело HTTP-сообщения (message-body), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом.</p>
          <p>
            HTTPS (Hypertext Transfer Protocol Secure) — защищённая версия HTTP.<br />
            Использует SSL-протокол, который активируется после установки SSL-сертификата и зашифровывает личную информацию, перед тем как передать её владельцу сайта.<br />
            В основе любого метода шифрования лежит ключ.<br />
            Ключ — это способ зашифровать или расшифровать сообщение.<br />
            В работе SSL-сертификата участвуют три ключа: публичный, приватный и сеансовый.
            
          </p>
        </details>
        <details>
          <summary>Api</summary>
          <h2>API (Application programming interface)</h2>
          <ul>
            <li>это набор функций, который группируется разработчиком по функционалу, по заказчику, по смыслу операций и т.д.</li>
            <li>это контракт, который предоставляется программой: Ко мне можно обращаться так, я сделаю это</li>
            <li>это интерфейс или правила связи между клиентом и сервером, предназначенный для упрощения создания программного обеспечения на стороне клиента</li>
            <li>это абстракция, которая описывает функциональность, без описания того, как реализована эта функциональность</li>
          </ul>
          <ul>
            <li><a href="https://www.postman.com/">Postman</a>
            </li>
          </ul>
          <ul>
            <li>RPC  - запрос на выполнение функции на сервере по имени функции с входными параметрами.</li>
            <li>REST - запрос с помощью установленных методов к ресурсу (сущности) на сервере.</li>
            <li>SOAP - формальный корпоративный подход, работает поверх любого протокола связи, даже асинхронно.</li>
          </ul>
          <p>Наиболее распространенные связки</p>
          <ul>
            <li>JSON + REST + HTTP</li>
            <li>XML  + RPC  + SOAP</li>
          </ul>
          <p>Преимущества</p>
          <ul>
            <li>API основанные на RPC прекрасно работают для действий (выполнения процедур или команд).</li>
            <li>API основанные на REST хороши для моделирования сущностей и применения CRUD (create, read, update, delete) для данных.</li>
            <li>REST vs SOAP - Простота VS Стандарты.</li>
            <li>JSON более компактный и не требует тегов закрытия как в XML.</li>
            <li>XML не может использовать массивы, как JSON.</li>
          </ul>
          <h3>RPC (Remote Procedure Call)</h3>
          <p>Удаленный вызов процедур — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (как правило, на удалённых компьютерах).</p>
          <h3>REST (Representational State Transfer)</h3>
          <p>
            Передача состояния представления — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети, который имеет набор ограничений, для проектирования по модели клиент-сервер.<br />
            Особенности архитектурного стиля:
          </p>
          <ul>
            <li>Каждая сущность должна иметь уникальный идентификатор – URI.</li>
            <li>Сущности должны быть связаны между собой.</li>
            <li>Для чтения и изменения данных должны использоваться стандартные методы.</li>
            <li>Должна быть поддержка нескольких типов ресурсов.</li>
            <li>Взаимодействие должно осуществляться без состояния.</li>
          </ul>
          <p>
            Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом для единицы данных.<br />
            Т.е. например третья книга с книжной полки будет иметь вид /book/3, а 35-я страница в этой книге — /book/3/page/35.
            
          </p>
          <h4>Запросы:  </h4>
          <p>Get: /test/demo_form.php?name1=value1&name2=value2</p>
          <ul>
            <li>параметры передаются в строке браузера</li>
            <li>может быть закеширован</li>
            <li>остаётся в истории браузера</li>
            <li>может быть сохранён в избранном</li>
            <li>нельзя передавать конфиденциальные данные</li>
            <li>максимальная длина в адресной строке 1024 символа</li>
            <li>используется только для получения данных</li>
          </ul>
          <p>POST:</p>
          <pre><code>POST /test/demo_from.php HTTP/1.1
HOST: w3schools.com
name1=value1&name2=value2</code></pre>
          <ul>
            <li>параметры передаются в теле запроса</li>
            <li>не может быть закеширован, сохранён в истории или в избранном</li>
            <li>не имеет ограничения на длину запроса</li>
            <li>можно передавать файлы</li>
          </ul>
          <h4>CRUD в REST:</h4>
          <ul>
            <li>GET /book/ — получить список всех книг</li>
            <li>GET /book/3/ — получить книгу номер 3</li>
            <li>POST /book/ — добавить книгу (данные в теле запроса)</li>
            <li>PUT /book/3 – изменить книгу (данные в теле запроса)</li>
            <li>DELETE /book/3 – удалить книгу</li>
          </ul>
          <p>Или:</p>
          <ul>
            <li>GET /book/ — получить список всех книг</li>
            <li>GET /book/3/ — получить книгу номер 3</li>
            <li>POST /book/ — добавить книгу (данные в теле запроса)</li>
            <li>POST /book/3 — изменить книгу (данные в теле запроса)</li>
            <li>POST /book/3 — удалить книгу (тело запроса пустое)</li>
          </ul>
          <h3>SOAP</h3>
          <p>
            SOAP — протокол обмена структурированными сообщениями в распределённой вычислительной среде.<br />
            Первоначально SOAP предназначался, в основном, для реализации удалённого вызова процедур (RPC).<br />
            Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур.<br />
            SOAP-сообщение представляет собой XML-документ, сообщение состоит из трех основных элементов:  
            
          </p>
          <h4>SOAP Envelope - конверт.</h4>
          <p>
            Является самым «верхним» элементом SOAP сообщения.<br />
            Содержит корневой элемент XML-документа.<br />
            Описывается с помощью элемента Envelope с обязательным пространством имен:<br />
          </p>
          <ul>
            <li><a href="http://www.w3.org/2003/05/soap-envelope">для версии 1.2</a>
            </li>
            <li><a href="http://schemas.xmlsoap.org/soap/">для версии 1.1</a>
            </li>
          </ul>
          <h4>SOAP Header - заголовок.</h4>
          <p>
            Первый прямой дочерний элемент конверта. Необязательный.<br />
            Заголовок кроме атрибутов xmlns может содержать 0 или более стандартных атрибутов:
          </p>
          <ul>
            <li>encodingStyle</li>
            <li>actor (или role для версии 1.2)</li>
            <li>mustUnderstand</li>
            <li>relay</li>
          </ul>
          <h4>SOAP Body - тело:</h4>
          <ul>
            <li>Элемент Body обязательно записывается сразу за элементом Header, если он есть в сообщении, или первым в SOAP-сообщении, если заголовок отсутствует.</li>
            <li>В элемент Body можно вложить произвольные элементы, спецификация никак не определяет их структуру.</li>
            <li>Определен только один стандартный элемент, который может быть в теле сообщения - Fault, содержащий сообщение об ошибке.</li>
            <li>Если SOAP-сервер, обрабатывая поступившее SOAP-сообщение, обнаружит ошибку, то он прекратит обработку и отправит клиенту SOAP-сообщение, содержащее один элемент Fault с сообщением об ошибке.</li>
          </ul>
          <h3>Форматы JSON / XML / WSDL</h3>
          <h4>WSDL (Web Services Definition Language) - Язык описания веб-сервисов, основан на языке XML.</h4>
          <p>Каждый документ WSDL можно разбить на следующие логические части:</p>
          <ul>
            <li>types: определение типов данных   — определение вида отправляемых и получаемых сервисом XML сообщений</li>
            <li>message: элементы данных          — сообщения, используемые web-сервисом</li>
            <li>portType: абстрактные операции    — список операций, которые могут быть выполнены с сообщениями</li>
            <li>binding: связывание сервисов      — способ, которым сообщение будет доставлено</li>
          </ul>
          <h4>XML (Extensible Markup Language]* - Расширяемый Язык Разметки.  </h4>
          <ul>
            <li>Корневой элемент и пространство имен.</li>
            <li>Разработчик сам определяет используемые теги.</li>
            <li>Не может содержать массивы.</li>
            <li>Основная цель XML - это передача данных между разными системами.</li>
            <li>Документ должен соответствовать семантическим правилам языка (схеме XML, WSDL или DTD *[Document Type Definition]*.</li>
            <li>XML обычно используют для описания чего-то.</li>
          </ul>
          <p>Сходство с HTML:</p>
          <ul>
            <li>В XML существуют открывающие, закрывающие и пустые тэги.</li>
            <li>Теги в документе могут быть вложены друг в друга.</li>
            <li>Теги начала и конца элемента являются основными используемыми в XML разметками.</li>
            <li>Тэги могут иметь любое количество атрибутов.</li>
            <li>Документы XML могут содержать ссылки на другие объекты.</li>
          </ul>
          <p>В отличии от HTML большое внимание уделяется контролю документа.</p>
          <ul>
            <li>Синтаксическая проверка.</li>
            <li>Проверка валидности документа.</li>
          </ul>
          <p>
            Существуют методы отображения XML данных, но если вы не определили способ визуализации XML документа, то в браузере он отобразится построчно, как обычный текстовый файл.<br />
            Один из методов отображения XML - указать CSS (чтобы использовать в документе нужно прописать инструкцию xml-stylesheet).
          </p>
          <pre><code>xml-stylesheet type="text/css" href="stylesheet.css"</code></pre>
          <p>Есть также много других мощных методов отображения XML, например, XSLT (Extensible Stylesheet Language Transformations), который используется для преобразование XML в другие языки такие, как HTML.</p>
          <pre><code>xml-stylesheet type="text/xsl" href="transform.xsl"</code></pre>
          <h4>JSON (JavaScript Object Note) - Описание объектов JavaScript.</h4>
          <p>
            Простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером.<br />
            Произошёл от JavaScript, но используется с любым языком программирования.
          </p>
          <ul>
            <li>Не имеет тегов.</li>
            <li>Может содержать в значениях массивы и объекты.</li>
            <li>Ключи в JSON находятся с левой стороны от двоеточия - это любая строка, например 'key'.</li>
            <li>В каждом объекте ключи уникальные.</li>
            <li>Пробелы допускаются, но лучше их заменять знаком подчеркивания.</li>
            <li>Значения находятся с правой стороны от двоеточия.</li>
            <li>Типы значений: строка, число, объект, массив, булево, null</li>
          </ul>
        </details>
        <details>
          <summary>PHP</summary>
          <h2>PHP</h2>
          <ul>
            <li>х64 Nоп Thread Safe - 64-битный СGI-вариант дистрибутива;</li>
            <li>х64 Thread Safe - 64-битный вариант для установки в качестве модуля вебсервера - Apache;</li>
          </ul>
          <p>Установка в Виндовс: Распаковать архив в необходимую папку, например C:\php. Добавить в PATH.</p>
          <pre><code>// Установка Линукс
sudo apt install -y php

// Интерактивный режим
php -a

// Локальный сервер:
php -S localhost:4000
</code></pre>
          <p>Указать локальному серверу хост в Виндовс: C:\Windows\system32\drivers\etc\hosts, Линукс: /etc/hosts</p>
          <p>Указать локальному серверу на файл с настройками php вручную:</p>
          <pre><code>// Windows
php -S 127.0.0.1:4000 -с C:\php\php.ini

// Linux
php -s 127.0.0.1:4000 -с /etc/php.ini
</code></pre>
          <p>в HTML разметке</p>
          <pre><code>< !DOCTYPE html>
< html lang="ru">
  < head>
    < title>Простейший РНР-скрипт< /title>
    < meta charset='utf-8' />
  < /head>
  < body>
    < ?php echo "Hello, world!"; ?>

    // либо
    < ?= "Hello, world!"; ?>
  < /body>
< /html>
</code></pre>
          <p>Синтаксис:</p>
          <pre><code>< ?php
echo "Hello, world!";

{
  echo "Hello, world!";
  echo 5 + 5;
  echo 5 - 2;
}
?>

< ?php
if (rand(0, 1)) {
  ?>
  < div style='color:green'><?= "Истина"; ?>< /div>
  < ?php
  } else {
  ?>
  < div style='color:red'><?= "Ложь" ?>< /div>
}
</code></pre>
          <table>
            <caption>Комментарий</caption>
            <tbody>
              <tr>
                <td>//</td>
                <td>однострочный комментарий</td>
              </tr>
              <tr>
                <td>#</td>
                <td>однострочный комментарий</td>
              </tr>
              <tr>
                <td>/* */</td>
                <td>многострочный комментарий</td>
              </tr>
              <tr>
                <td>\</td>
                <td>экранировать символ</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Кавычки</caption>
            <tbody>
              <tr>
                <td>"..."</td>
                <td>вместо переменных подставляются их значения - интерполяция</td>
              </tr>
              <tr>
                <td>'...'</td>
                <td>переменные отображаются как есть, их значения не подставляются</td>
              </tr>
              <tr>
                <td>`...`</td>
                <td>системная команда, возвращает результат выполнения терминальной команды системы: echo `ls -l`;</td>
              </tr>
            </tbody>
          </table>
          <table>
            <tbody>
              <tr>
                <td>$str = <<< METKA ... METKA;</td>
                <td>Между метками любой текст.</td>
              </tr>
              <tr>
                <td>$str = <<< `METKA`... METKA;</td>
                <td>Переменные не интерполируются.</td>
              </tr>
              <tr>
                <td>$str[0];</td>
                <td>Получить символ строки по индексу</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// масиив: ключ=>значение
$arr = [
  0         => "element",
  "surname" => "Gates",
  "name"    => "Bill"
]

/**
* mixed $var       - параметр $var типа mixed
* [mixed ...$vars] - необязательный параметр
* ...              - бесконечное количество аргументов
* : void           - ничего не возвращает
*/
unset(mixed $var, [mixed ...$vars]): void

// жесткая ссылка &, $Ь и $а имеют одно значение на двоих, ссылаются на одну и ту же область памяти
$Ь = &$а;
$right "красная";
$color = "right";

// символическая ссылка $$ обращается к значению переменной, имя которой содержит, выводит значение переменной $right ("красная")
echo $$color;

// если file.php отсутствует, то скрипт продолжит работу с предупреждением
include 'file.php'

// если file.php отсутствует, то скрипт остановится
require 'file.php'

// если file.php отсутствует, то скрипт продолжит работу с предупреждением, включает файл один раз
include_once 'file.php'

// если file.php отсутствует, то скрипт остановится, включает файл один раз
require_once 'file.php'
</code></pre>
          <p>Степень числа 10 через букву е: 346.1256 = 3.461256*10 в квадрате или 3.461256е+2, 0.00012 = 1.2е-4.  </p>
          <p>Ключевые слова class и function создают область видимости в своём блоке {}.  </p>
          <p>Элементы языка:</p>
          <ul>
            <li>ключевые слова</li>
            <li>переменные</li>
            <li>скалярные величины: скалярный - определяется полностью своим значением и не имеет направления как вектор или мнимой части как комплекс</li>
            <li>константы</li>
            <li>операторы</li>
            <li>функции</li>
            <li>классы</li>
            <li>объекты</li>
            <li>пространства имён</li>
            <li>трейты</li>
            <li>перечисления</li>
            <li>исключения</li>
          </ul>
          <p>Переменные, Константы и Типы</p>
          <ul>
            <li>Адрес ячейки оперативной памяти, где хранится значение, содержится в таблице интерпретатора и имеет имя - имя переменной.</li>
            <li>Имя переменной используется в скрипте для обращения к значению переменной в оперативной памяти.</li>
            <li>Значение переменной можно менять, т.е. присваивать переменной другое значение, т.е. напротив имени переменной в таблице интерпретатора адрес нового значения в оперативной памяти.</li>
          </ul>
          <pre><code>< ?php
$price = 3000;
$price_vip = $price + 500;

// 3900200 - допускается разделение разрядов _ для читабельности
echo 2_000_000 + 1_920_000;

// 85 - двоичное число 0b010101
echo 0b010101;

// 493 - восьмеричное число
echo 0o755;

// 16763904 - шестнадцатеричное число
echo 0xffcc00;

// Служебные переменные:
$this - указывает на текущий объект</code></pre>
          <ul>
            <li>Значения чисел для 32-битной операционной системы от -2 147 483 648 до 2 147 483 647.</li>
            <li>Значения чисел для 64-битной операционной системы от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.</li>
            <li>Если значение превышает диапазон integer, то автоматически тип становится float.</li>
            <li>Директива precision в php.ini указывает количество знаков после точки.</li>
            <li>Дескрипторы применяются при работе с файлами, базами данных, динамическими изображениями и предоставляют к ним доступ при помощи библиотечных функций.</li>
            <li>Функции обратного вызова - функции, которые принимаются как аргументы другими функциями.</li>
          </ul>
          <p>Типы</p>
          <ul>
            <li>Тип переменной - это тип значения: число, строка, массив, объект и ресурс.</li>
            <li>По типу значения интерпретатор определяет какие операторы и функции можно применять к значению.</li>
            <li>Встроенные базовые типы менять нельзя - можно создавать свои классы, которые похожи на типы.</li>
            <li>PHP - слабо типизированный язык, т.е. тип не определяется при объявлении переменной и может изменяться в зависимости от присваиваемого значения.</li>
          </ul>
          <table>
            <thead>
              <tr>
                <th>Тип</th>
                <th>Описание</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="2">Встроенные типы</td>
                <td></td>
              </tr>
              <tr>
                <td>int</td>
                <td>integer - целое число</td>
              </tr>
              <tr>
                <td>bool</td>
                <td>boolean - логический тип: true (истина) и false (ложь)</td>
              </tr>
              <tr>
                <td>float</td>
                <td>вещественное число, значения от ±2.23х10-эов до ±1.79х1О30</td>
              </tr>
              <tr>
                <td>string</td>
                <td>строковый тип, может хранить строку</td>
              </tr>
              <tr>
                <td>array</td>
                <td>массив - объединение нескольких переменных под одним именем</td>
              </tr>
              <tr>
                <td>object</td>
                <td>объект - объединяет разнотипные переменные и методы их обработки</td>
              </tr>
              <tr>
                <td>resource</td>
                <td>дескриптор, позволяющий оперировать ресурсом</td>
              </tr>
              <tr>
                <td>Relative class</td>
                <td>self, parent, and static - относительные типы классов</td>
              </tr>
              <tr>
                <td>Singleton</td>
                <td>false, true - одноэлементные типы</td>
              </tr>
              <tr>
                <td>null</td>
                <td>тип, который сигнализирует о том, что переменная не была инициализирована</td>
              </tr>
              <tr>
                <td colspan="2">Пользовательские типы</td>
                <td></td>
              </tr>
              <tr>
                <td>Interfaces</td>
                <td></td>
              </tr>
              <tr>
                <td>Classes</td>
                <td></td>
              </tr>
              <tr>
                <td>Enumerations</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="2">Псевдонимы типов</td>
                <td></td>
              </tr>
              <tr>
                <td>never</td>
                <td>возвращается при досрочном прерывании программы функцией exit() или при исключительной ситуации</td>
              </tr>
              <tr>
                <td>void</td>
                <td>отсутствие типа - используется в функциях для обозначения, что возвращаемое значение не возвращает никакого значения</td>
              </tr>
              <tr>
                <td>mixed</td>
                <td>объединение типов object,resource,array,string,float,int,bool,null, т.е. значение может иметь любой тип</td>
              </tr>
              <tr>
                <td>iterable</td>
                <td>объединение типов Traversable,array, т.е. массив или объект</td>
              </tr>
              <tr>
                <td>callable</td>
                <td>переменные этого типа содержат ссылки на функции обратного вызова</td>
              </tr>
            </tbody>
          </table>
          <p>
            Пересечение типов - значения, которые удовлетворяют не одному, а одновременно нескольким классам-типам: T&U&V.</br>
            Объединение типов - значения или одного или другого типа: T|U|V.</br>
            Явное приведение к типу:
          </p>
          <pre><code>$var = (int) $a;

// либо
$var = settype($a, 'int')
</code></pre>
          <p>Копирование значения при присваивании:</p>
          <pre><code>$a = 42;

// $a = 42; $b = 42; - у каждой переменной своё значение
$b = $a;

// $a = 24; $b = 42;
$a = 24;

// объявил класс
class MyClass {}

// создал объект
$first = new MzClass();

// скопировал из $first адрес объекта в $second, один объект на две переменные
$second = $first;</code></pre>
          <table>
            <caption>Константы: значение присваивается один раз, нет символа $ и не может быть равно null.  </caption>
            <tbody>
              <tr>
                <td>PHP_INT_МAX</td>
                <td>максимальное значение целого числа</td>
              </tr>
              <tr>
                <td>PHP_INT_SIZE</td>
                <td>количество байтов, отведенное под целое число</td>
              </tr>
              <tr>
                <td>__DIR__</td>
                <td>директория корня проекта</td>
              </tr>
              <tr>
                <td>__FILE__</td>
                <td>имя файла, в котором расположен запущенный в настоящий момент код</td>
              </tr>
              <tr>
                <td>__LINE__</td>
                <td>номер строки, которую обрабатывает в текущий момент интерпретатор</td>
              </tr>
              <tr>
                <td>__FUNCTION__</td>
                <td>имя текущей функции</td>
              </tr>
              <tr>
                <td>__CLASS__</td>
                <td>имя текущего класса</td>
              </tr>
              <tr>
                <td>PHP_VERSION</td>
                <td>версия интерпретатора PHP</td>
              </tr>
              <tr>
                <td>PHP_OS</td>
                <td>имя операционной системы, под управлением которой работает PHP</td>
              </tr>
              <tr>
                <td>PHP_EOL</td>
                <td>символ конца строки текущей платформы: UNIX - \n, Windows - \r\n</td>
              </tr>
              <tr>
                <td>true</td>
                <td>истина</td>
              </tr>
              <tr>
                <td>false</td>
                <td>ложь</td>
              </tr>
              <tr>
                <td>null</td>
                <td>null</td>
              </tr>
              <tr>
                <td>get_defined_constants (bool $categorize = false): array</td>
                <td>получить все доступные в данный момент константы</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// определить константу: имя, значение - типы значений: bool, int, float, string, array
define('PI', 3.14);
define('VALUE', 'Hello world!');

// 3.14
echo PI;

// Hello world!
echo VALUE;

// проверить существование константы: true|false
defined('VALUE')

define('START_TIME', new DateTime());

// 23-04-2022 13:42:56
echo START_TIME->format('d-m-Y H:i:s');

// Формируем случайное число от 1 до 10
$index = rand(l, 10);

// Формируем имя константы
$name = "VALUE{$index}";

// Определяем константу с динамическим именем
define($name, 1);

// Получаем значение динамической константы
echo constant($name);
</code></pre>
          <p>ООП</p>
          <ul>
            <li>У переменной тип - у объекта класс.</li>
            <li>Переменные - свойства, функции - методы.</li>
            <li>Класс - self, объект - $this.</li>
            <li>$obj-&gt;method; - вызывать метод объекта, если метод вернёт null, то будет ошибка.</li>
            <li>$obj?-&gt;method; - безопасно вызывать метод объекта, если метод вернёт null, то ошибки не будет.</li>
          </ul>
          <p>Объекты: один класс - один файл, класс и объект в разных файлах</p>
          <pre><code>$date = new DateTime();

// 14-04-2022 16:26:34
echo $date->format('d-m-Y H:i:s');

// object
echo gettype($date);

// DateTime
echo get_class($date);

// DateTime
echo $date::class;
</code></pre>
          <p>свойства класса public - везде, protected - внутри и наследники, private - только внутри</p>
          <pre><code>class MyClass {

  // либо int, либо float
  public int|float $x;

  // либо int, либо null. можно использовать ? с любым типом кроме callable
  public ?int $x;

  static - создаёт переменную в классе
  public static $static_var = 100;

  const - только для класса, создаёт константу, по умолчанию public, можно указать protected или private
  const NAME = 'cls';
}

// Использование
$obj = new MyClass;

// для использования нужно инициализировать
$obj->x = 2;

// 2
echo $obj->x;

// Использование
// 100
echo MyClass::$static_var;

// обращение к значению константы
echo MyClass::NAME

// проверка существует ли константа NAME в классе MyClass: true|false
defined(('MyClass::NAME'));
</code></pre>
          <p>Значения</p>
          <pre><code>class Greeting {

  // $hello - строка только для чтения снаружи
  public readonly string $hello;

  // присваиваю значение
  public function setter() {
    $this->hello = 'PHP';
  }
}

// Использование
$object = new Greeting;

// вызвать setter() для инициализации свойства hello
echo $object->setter();

// PHP
echo $object->hello;
</code></pre>
          <p>Конструктор инициализирует свойство при создании объекта</p>
          <pre><code>class Greeting
{
  // $hello - строка только для чтения снаружи
  public readonly string $hello;

  // присваиваю значение при создании объекта
  public function __construct() {
    $this->hello = 'PHP';
  }
}

// Использование
$object = new Greeting;

// PHP
echo $object->hello;
</code></pre>
          <p>Клонирование</p>
          <pre><code>class Point
{
  public ?int $x;
}

// Использование
$first = new Point;
$first->x = 1;

$second = $first;

// $first и $second ссылаются на один и тот же объект, изменил значение х
$second->x = 2;

// создал отдельный объект - клон объекта $first
$third = clone $first;

// изменил значение х в клоне
$third->x = 3;

// first x: 2, third x: 3
echo "first x: {$first->x}, third x: {$third->x}"

// greeting.php
class Greeting
{
  public function say(string $who): string
  {
    return "Hello, $who!";
  }
}

// greeting_say.php
require_once 'greeting.php';

// инициализация свойств
$object = new Greeting;

// Hello, PHP!
echo $object->say('PHP');

class Point
{
  private $x;
  private $y;

  public function __construct(int $x = 0, int $y = 0)
  {
    $this->x = $x;
    $this->y = $y;
  }
}

// или
class Point
{
  public function __construct(private int $x = 0, private int $y = 0) {}
}

// использование
$point = new Point(x: 3, y: 5);
</code></pre>
          <p>Статический метод - метод класса, который можно вызвать без создания объекта</p>
          <pre><code>class Greeting
{
  public static function say(string $who) {
    return "Hello, $who!";
  }
}

// Hello, PHP!
echo Greeting::say('PHP');
</code></pre>
          <p>Методы</p>
          <pre><code>// существует ли метод, вернёт массив со всеми методами объекта
get_class_methods(object|string $object_or_class): array

// существует ли свойство, вернёт массив со всеми свойствами объекта
get_object_vars(object $object): array

// существует ли метод, вернёт true|false
method_exists(object|string $object_or_class, string $method): bool

// существует ли свойство, вернёт true|false
property_exists(object|string $object_or_class, string $property): bool
</code></pre>
          <table>
            <caption>Специальные встроенные методы, выполняются автоматически</caption>
            <tbody>
              <tr>
                <td>__construct()</td>
                <td>конструктор класса, при создании объекта - во время вызова new</td>
              </tr>
              <tr>
                <td>__destruct()</td>
                <td>деструктор класса, при уничтожении объекта</td>
              </tr>
              <tr>
                <td>__autoload()</td>
                <td>загружает класс при создании его объекта</td>
              </tr>
              <tr>
                <td>__set()</td>
                <td>аксессор, при установке свойства объекта</td>
              </tr>
              <tr>
                <td>__get()</td>
                <td>аксессор, при обращении к свойству объекта</td>
              </tr>
              <tr>
                <td>__isset()</td>
                <td>при проверки свойства с помощью isset()</td>
              </tr>
              <tr>
                <td>__unset()</td>
                <td>при удалении свойства с помощью unset()</td>
              </tr>
              <tr>
                <td>__call()</td>
                <td>при попытке вызвать несуществующий метод объекта, либо для перехвата вызова метода (посредник)</td>
              </tr>
              <tr>
                <td>__toString()</td>
                <td>при интерполяции объекта в строку</td>
              </tr>
              <tr>
                <td>__set_state()</td>
                <td>экспорт объекта</td>
              </tr>
              <tr>
                <td>__clone()</td>
                <td>клонирование объекта</td>
              </tr>
              <tr>
                <td>__sleep()</td>
                <td>управлять поведением объекта при его сериализации с помощью serialize()</td>
              </tr>
              <tr>
                <td>__wakeup()</td>
                <td>управлять поведением объекта при его восстановления из сериализованного состояния с помощью unserialize()</td>
              </tr>
            </tbody>
          </table>
          <pre><code>class MinMax
{
  // перехватывает вызов любого метода
  public function __call(string $method, array $arr)
  {
    // выбираю какой метод вызвать
    switch($method) {
      case 'min':
        // min - встроенная функция PHP, доступ извне закрыт, но к __call() доступ извне есть
        return min($arr);
      case 'max':
        // max - встроенная функция PHP, доступ извне закрыт, но к __call() доступ извне есть
        return max($arr);
      default:
        // если такого названия метода нет, то null. break не нужен, т.к. return выйдет из __call()
        return null
    }
  }
}

// использование
$obj = new MinMax();
echo $obj->min(43, 18, 5, 61, 23);   // 5
echo $obj->max(43, 18, 5, 61, 23);   // 61

// тоже самое для класса
class MinMax
{
  public static function __callStatic(string $method, array $arr)
  {
    switch($method) {
      case 'min':
        return min($arr);
      case 'max':
        return max($arr);
      default:
        return null
    }
  }
}

// использование
$obj = new MinMax();
echo MinMax::min(43, 18, 5, 61, 23);   // 5
echo MinMax::max(43, 18, 5, 61, 23);   // 61

// вызов объекта в строке возможен только если его класс содержит __toString()
class Point
{
  private int $x;
  private int $y;

  public function __construct(int $x = 0, int $y = 0) {
    $this x = $x;
    $this y = $y;
  }

  public function __toString() {
    return "({$this->x}, {$this->y})";
  }
}

// использование
$point = new Point(5, 12);

// point = (5, 12)
echo "point = {$point}";


// передать метод в качестве колбэк функции
class Algorithm
{
  public function distance(array $point): float
  {
    return sqrt($point[0] ** 2 + $point[1] ** 2);
  }
}

$points = ([3, 5], [5, 3], [5, 5], [5, 0]);

// создать объект класса Algorithm и применить к элементам массива $points метод distance
$objects = array_map([new Algorithm, 'distance'], $points);

// тоже самое, но без создания объекта - сделать метод статическим
class Algorithm
{
  public static function distance(array $point): float
  {
    return sqrt($point[0] ** 2 + $point[1] ** 2);
  }
}

$points = ([3, 5], [5, 3], [5, 5], [5, 0]);

// применить метод distance класса Algorithm к элементам массива $points
$objects = array_map(['Algorithm', 'distance'], $points);
</code></pre>
          <p>Операторы PHP: любое выражение имеет значение, а значит и тип.  </p>
          <table>
            <tbody>
              <tr>
                <td>2 + 3</td>
                <td>оператор: +, операнды 2 и 3</td>
              </tr>
              <tr>
                <td>.</td>
                <td>конкатенация: соединение строк, число приводится к строке</td>
              </tr>
              <tr>
                <td>,</td>
                <td>запятая для списка значений</td>
              </tr>
              <tr>
                <td>;</td>
                <td>окончание выражения</td>
              </tr>
              <tr>
                <td>\=</td>
                <td>равно, оператор присваивания</td>
              </tr>
              <tr>
                <td>.=</td>
                <td>сокращает $str = $str . $newstring до $str .= $newstring, аналогично +=, *=, -=, /=, %=, **=</td>
              </tr>
              <tr>
                <td>+</td>
                <td>сложение, строка приводится к числу</td>
              </tr>
              <tr>
                <td>*</td>
                <td>умножение</td>
              </tr>
              <tr>
                <td>-</td>
                <td>вычитание</td>
              </tr>
              <tr>
                <td>/</td>
                <td>деление</td>
              </tr>
              <tr>
                <td>%</td>
                <td>деление по модулю: возвращает остаток от деления</td>
              </tr>
              <tr>
                <td>**</td>
                <td>возведение в степень</td>
              </tr>
              <tr>
                <td>++</td>
                <td>инкремент: увеличить на единицу, применяется только к переменным</td>
              </tr>
              <tr>
                <td>++=</td>
                <td>префиксный инкремент сначала увеличивает значение, а потом присваивает, постфиксный =++ наоборот</td>
              </tr>
              <tr>
                <td>--</td>
                <td>декремент: уменьшить на единицу, применяется только к переменным</td>
              </tr>
              <tr>
                <td>--=</td>
                <td>префиксный декремент сначала уменьшает значение, а потом присваивает, постфиксный =-- наоборот</td>
              </tr>
              <tr>
                <td>()</td>
                <td>группировка аргументов, приоритет операции</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Побитовые операторы применяются к строкам если оба операнда строки, иначе приводятся к числу</caption>
            <tbody>
              <tr>
                <td>$a & $b</td>
                <td>вернёт биты, которые есть и в $a и в $b</td>
              </tr>
              <tr>
                <td>$a | $b</td>
                <td>вернёт биты $a и $b</td>
              </tr>
              <tr>
                <td>$a ^ $b</td>
                <td>вернёт биты, которые есть либо в $a либо в $b, но не в обоих одновременно</td>
              </tr>
              <tr>
                <td>~ $a</td>
                <td>вернёт биты, которых нет в $a</td>
              </tr>
              <tr>
                <td>$a << $b</td>
                <td>на $b позиций сдвиг влево: умножить на два, знак операнда не сохраняется</td>
              </tr>
              <tr>
                <td>$a >> $b</td>
                <td>на $b позиций сдвиг вправо: разделить на два, знак операнда сохраняется</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Операторы сравнения: true|false</caption>
            <tbody>
              <tr>
                <td><</td>
                <td>меньше</td>
              </tr>
              <tr>
                <td><=</td>
                <td>меньше либо равно</td>
              </tr>
              <tr>
                <td>></td>
                <td>больше</td>
              </tr>
              <tr>
                <td>>=</td>
                <td>больше либо равно</td>
              </tr>
              <tr>
                <td>\==</td>
                <td>равенство: значения равны</td>
              </tr>
              <tr>
                <td>!=</td>
                <td>неравенства: значения не равны</td>
              </tr>
              <tr>
                <td><></td>
                <td>неравенства: значения не равны</td>
              </tr>
              <tr>
                <td>\===</td>
                <td>эквивалентности: значения и типы равны</td>
              </tr>
              <tr>
                <td>!==</td>
                <td>неэквивалентности: либо значение, либо типы не равны</td>
              </tr>
              <tr>
                <td>$x <=> $y</td>
                <td>в случае равенства вернёт 0, если $x больше $y вернёт положительное число, если $y больше $x, то вернёт отрицательное число</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Логические операторы</caption>
            <tbody>
              <tr>
                <td>&&</td>
                <td>логическое И: возвращает true если оба операнда true</td>
              </tr>
              <tr>
                <td>and</td>
                <td>логическое И: приоритет меньше чем у &&</td>
              </tr>
              <tr>
                <td>||</td>
                <td>логическое ИЛИ: возвращает true если хоть один из операндов true, если оба false, то вернёт false</td>
              </tr>
              <tr>
                <td>or</td>
                <td>логическое ИЛИ: приоритет меньше чем у ||</td>
              </tr>
              <tr>
                <td>!</td>
                <td>логическое НЕ: меняет true|false на противоположное</td>
              </tr>
            </tbody>
          </table>
          <p>Суперглобальные и другие массивы</p>
          <ul>
            <li>переменная доступная для всех контекстов - глобальная переменная global $var;</li>
            <li>глобальный массив $GLOBALS позволяет получить доступ к переменным в любом месте программы - $GLOBALS['var']</li>
            <li>global $var; это тоже самое что $var = &amp;$GLOBALS['var'], т.е. ссылка на элемент глобального массива</li>
          </ul>
          <p>Массивы</p>
          <ul>
            <li>Если индексы числа, то массив индексный.</li>
            <li>Если индексы строки, то массив ассоциативный.</li>
            <li>Если индексы и числа и строки, то массив смешанный.</li>
            <li>Многомерный массив - массив, элемент которого другой массив.</li>
          </ul>
          <pre><code>$arr = array('Hello', 'world', '!');
echo $arr[0]; // Hello
echo $arr[1]; // world
echo $arr[2]; // !

// Вывести весь массив
echo '< pre>';
print_r($arr);
echo '< pre>';

// или
$arr = [];
$arr = ['Hello', 'world', '!'];

// Задать индекс вручную
// индекс 'Hello' - 10, 'world' - 11, а '!' - 12
$arr = [10 => 'Hello', 'world', '!'];

// индекс 'Hello' - 10, 'world' - 9, а '!' - 11
$arr = [10 => 'Hello', 9 => 'world', '!'];

$arr = array_fill(первый индекс, количество элементов, значение элемента);
// создаст массив с шестью элементами 'Hello world !', с индексами начиная с 5
$arr = array_fill(5, 6, 'Hello world !');

$arr = range(начало интервала, конец интервала, шаг);
// создаст массив [0, 0.2, 0.4, 0.6, 0.8, 1]
$arr = range(0, 1, 0.2);

// ассоциативный массив
$arr = ['one' => '1', 'two' => '2'];

// многомерный массив
$arr = [
  'one' => ['first', 'second', 'third'],
  'two' => ['red', 'green', 'blue']
]

// Интерполяция массива в строку
echo "Событие произошло $arr[O] дней назад";

// ключ без кавычек
echo "Событие произошло $arr[one] дней назад";

// с кавычками
echo "Событие произошло {$arr['one']} дней назад";
echo "Событие произошло " . $arr[O][О] . " дней назад";
echo "Событие произошло {$arr[O][О]} дней назад";
</code></pre>
          <p>Конструкция list() - преобразует элементы массива в обычные переменные, работает только с числовыми массивами, нумерация индексов которых начинается с нуля.</p>
          <pre><code>$arr = [1, 2, 3];
list($one, $two, $three) = $arr;

echo Sone;    // 1
echo $two;    // 2
echo $three;  // З

// либо
[$one, $two, $three] = $arr;
</code></pre>
          <table>
            <caption>Сечение массива</caption>
            <tbody>
              <tr>
                <td colspan="2">выделяет часть массива в новый массив</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="2">array_slice(): array</td>
                <td></td>
              </tr>
              <tr>
                <td>array $array,</td>
                <td>исходный массив</td>
              </tr>
              <tr>
                <td>int $offset,</td>
                <td>индекс элемента - начало сечения</td>
              </tr>
              <tr>
                <td>?int $length = null,</td>
                <td>количество элементов нового массива, если не задан, то все до конца</td>
              </tr>
              <tr>
                <td>bool $preserve_keys = false</td>
                <td>true - сохранить ключи, false - индексировать новый массив с 0</td>
              </tr>
              <tr>
                <td colspan="2">$arr = ['a', 'b', 'c', 'd', 'e'];</td>
                <td></td>
              </tr>
              <tr>
                <td>array_slice($arr, 2);</td>
                <td>вернёт ['c', 'd', 'e']</td>
              </tr>
              <tr>
                <td>array_slice($arr, 2, -1);</td>
                <td>вернёт ['c', 'd']</td>
              </tr>
              <tr>
                <td>array_slice($arr, -2, 1);</td>
                <td>вернёт ['d']</td>
              </tr>
              <tr>
                <td>array_slice($arr, 0, 3);</td>
                <td>вернёт ['a', 'b', 'c']</td>
              </tr>
              <tr>
                <td colspan="2">заменяет часть массива</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="2">array_splice(): array</td>
                <td></td>
              </tr>
              <tr>
                <td>array $array,</td>
                <td>исходный массив</td>
              </tr>
              <tr>
                <td>int $offset,</td>
                <td>индекс элемента - начало сечения</td>
              </tr>
              <tr>
                <td>?int $length = null,</td>
                <td>количество элементов нового массива, если не задан, то все до конца</td>
              </tr>
              <tr>
                <td>mixed $replacement = []</td>
                <td>заменяет часть элементов тем, что в массиве $replacement, если пустой [], то элементы удаляются</td>
              </tr>
              <tr>
                <td colspan="2">$arr = ['a', 'b', 'c', 'd'];</td>
                <td></td>
              </tr>
              <tr>
                <td>array_splice($arr, 2);</td>
                <td>вернёт ['a', 'b'] - остальные удалены, начиная с индекса 2</td>
              </tr>
              <tr>
                <td>array_splice($arr, 1, -1);</td>
                <td>вернёт ['a', 'd'] - удалено всё, начиная с индекса 1 и без последнего индекса.</td>
              </tr>
              <tr>
                <td>array_splice($arr, 1, count($arr), 'e');</td>
                <td>вернёт ['a', 'e'] - заменил всё, начиная с индекса 1 на 'e'</td>
              </tr>
            </tbody>
          </table>
          <p>Слияние массивов</p>
          <pre><code>// оператор +. При одинаковых индексах в результат попадёт элемент из левого массива.
$fst = [1 => 'one', 2 => 'two'];
$snd = [3 => 'three', 4 => 'four'];

// [1 => 'one', 2 => 'two', 3 => 'three', 4 => 'four']
$sum = $fst + $snd;

// Объединить все элементы массивов
$fst = ['one', 'two'];
$snd = ['three', 'four', 'five'];
$sum = array_marge($fst, $snd); 
</code></pre>
          <p>Сравнение массивов</p>
          <ul>
            <li>Массивы равны == если количество элементов, ключи и значения совпадают.</li>
            <li>Массивы эквивалентны === если количество элементов, ключи, значения и типы значений совпадают.</li>
          </ul>
          <pre><code>// массивы равны, но не эквивалентны
$fst = [1 => 1, 2 => 2];
$snd = [1 => 1, 2 => '2'];

if ($fst == $snd)
  echo 'массивы равны< Ьr/>';
} else {
  echo 'массивы не равны< Ьr/>';
}

if ($fst === $snd) {
  echo 'массивы эквивалентны< Ьr/>';
} else {
  echo 'массивы не эквивалентны< Ьr/>';
}

// массивы равны и эквивалентны
$fst = [1 => 1, 2 => 2];
$snd = [1 => 1, '2' => 2];

// исключительное пересечение массивов, т.е. их отличия, вернёт массив значений, которые есть только в первом массиве.
array_diff(array $arr, array ...$arrays): array
$result = array_diff($fst, $snd);

// включительное пересечение массивов, т.е. общее, вернёт массив значений из первого массива, которые есть в остальных массивах.
array_intersect(array $arr, array ...$arrays): array
$result = array_intersect($fst, $snd);
</code></pre>
          <table>
            <caption>Поиск в массиве</caption>
            <tbody>
              <tr>
                <td colspan="2">проверить существование значения в массиве</td>
                <td></td>
              </tr>
              <tr>
                <td>in_array(): bool</td>
                <td>вернёт true если найдёт, или false если нет</td>
              </tr>
              <tr>
                <td>mixed $val,</td>
                <td>искомое значение</td>
              </tr>
              <tr>
                <td>array $arr,</td>
                <td>массив, в котором ищем</td>
              </tr>
              <tr>
                <td>bool $strict = false</td>
                <td>true - эквивалентное сравнение ===, false - равенство ==</td>
              </tr>
              <tr>
                <td>array_key_exists (string|int $key, array $array): bool</td>
                <td>проверить наличие ключа в массиве</td>
              </tr>
              <tr>
                <td colspan="2">найти ключ массива по значению</td>
                <td></td>
              </tr>
              <tr>
                <td>array_search (): int|string|false</td>
                <td>вернёт либо ключ, либо false</td>
              </tr>
              <tr>
                <td>mixed $val,</td>
                <td>значение, ключ которого ищем</td>
              </tr>
              <tr>
                <td>array $arr,</td>
                <td>массив, в котором ищем</td>
              </tr>
              <tr>
                <td>bool $strict = false</td>
                <td>true - эквивалентное сравнение ===, false - равенство ==</td>
              </tr>
            </tbody>
          </table>
          <p>Математические операции массивов</p>
          <pre><code>$arr = [
  [1, 2, 3, 4],
  [5, 6, 7, 8]
];
</code></pre>
          <table>
            <caption>количество элементов в массиве</caption>
            <tbody>
              <tr>
                <td colspan="2">count(): int</td>
                <td></td>
              </tr>
              <tr>
                <td>Countable|array $arr,</td>
                <td>массив, элементы которого считаем</td>
              </tr>
              <tr>
                <td>int $mode = COUNT_NORMAL</td>
                <td>нормальный режим подсчёта, если COUNT_RECURSIVE, то считает сумму всех элементов с вложенными массивами вместе</td>
              </tr>
              <tr>
                <td>echo count($arr);</td>
                <td>2 - у массива arr два элемента: вложенные массивы</td>
              </tr>
              <tr>
                <td>echo count($arr[0]);</td>
                <td>4 - у первого вложенного массива 4 элемента</td>
              </tr>
              <tr>
                <td>echo count($arr, COUNT_RECURSIVE);</td>
                <td>10 - 2 вложенных массива + по 4 элемента в каждом</td>
              </tr>
            </tbody>
          </table>
          <pre><code>/**
* количество уникальных значений в массиве
* возвращает массив, в котором ключи - это уникальные значения,
* а значения - это количество вхождений в массив
*/
array_count_values(array $array): array   

// сумма элементов массива
array_sum(array $array): int|float

$arr = [1, 2, 3, 4, 5];
echo array_sum($arr);   // 15

// случайный элемент индексного массива, индексы которого начинаются с 0 и не имеют перерывов в нумерации
rand(): int

// задать интервал, из которого выбрать случайное значение
rand(int $min, int max): int

$arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
$index = rand(0, count($arr) - 1);
echo $arr[$index];

// получить случайно выбранный индекс (ключ) или массив случайно выбранных индексов (ключей) элементов
// если $num больше 1, то получить массив
array_rand(array $array, int $num = 1): int|string|array

// перемешать элементы массива случайным образом
shuffle(array &$array): bool
$arr = [1, 2, 3, 4, 5];
shuffle($arr);

// [5, 4, 1, 3, 2]
print_r($arr);
</code></pre>
          <p>Сортировка массива</p>
          <pre><code>/**
* сортировка значений по возрастанию в индексном массиве
* 
* SORT_REGULAR - нормальное сравнение элементов
* SORT_NUMERIC - сравнивает элементы как числа
* SORT_STRING  - сравнивает элементы как строки
* SORT_NATURAL - сравнивает элементы как строки, используя естественный для человека порядок
* SORT_LOCAL_STRING - сравнивает элементы как строки, основываясь на текущей локали
* SORT_STRING|SORT_NATURAL - можно объединять, т.к. константы являются целыми числами
*/
sort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка значений по убыванию в индексном массиве
rsort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка значений по возрастанию в ассоциативном массиве связь ключей и значений сохраняется
asort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка значений по убыванию в ассоциативном массиве связь ключей и значений сохраняется
arsort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка ключей по возрастанию в ассоциативном массиве связь ключей и значений сохраняется
ksort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка ключей по убыванию в ассоциативном массиве связь ключей и значений сохраняется
krsort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка с применением колбэк функции
usort(array &$array, callable $callback): bool

// естественная сортировка индексном массиве
natsort(array &$array): bool
</code></pre>
          <ul>
            <li>сортировка нескольких массивов или одного многомерного массива</li>
            <li>массивы, которые передаются для сортировки должны содержать одинаковое количество аргументов</li>
            <li>сортируется только первый массив, остальные выстраиваются в соответствии с первым</li>
          </ul>
          <table>
            <tbody>
              <tr>
                <td colspan="2">array_multisort(): bool</td>
                <td></td>
              </tr>
              <tr>
                <td>array &$array1,</td>
                <td>массив для сортировки</td>
              </tr>
              <tr>
                <td>mixed $array1_sort_order = SORT_ASC,</td>
                <td>SORT_ASC - по возрастанию, SORT_DESC - по убыванию</td>
              </tr>
              <tr>
                <td>mixed $array1_sort_flags = SORT_REGULAR,</td>
                <td>флаги как в sort()</td>
              </tr>
              <tr>
                <td>mixed ...$rest</td>
                <td>остальные массивы</td>
              </tr>
            </tbody>
          </table>
          <p>Добавить/удалить элементы</p>
          <pre><code>// увеличить размер массива: вернёт копию массива $array, размер которого был увеличен до значения $length, элементами со значением $value
array_pad(array $array, int $length, mixed $value): array

$arr = [1, 2, 3];

// [1, 2, 3, 0, 0, 0]
$result = array_pad($arr, 6, 0);

// добавить элементы в конец массива
array_push(array &$array, mixed ...$values): int

// удалить последний элемент в массиве
array_pop(array &$array): mixed

// добавить элементы в начало массива
array_unshift(array &$array, mixed ...$values): int

// удалить первый элемент в массиве
array_shift(array &$array): mixed
</code></pre>
          <p>Ключи массива</p>
          <pre><code>// изменить регистр ключей CASE_UPPER, CASE_LOWER - по умолчанию
array_change_key_case(array $array, int $case = CASE_LOWER): array

// вернёт копию ассоциативного массива, в котором ключи заменены числовыми индексами
array_values(array $array): array

// вернёт копию массива, где ключи становятся значениями, а значения - ключами, из повторных значений учитывается только последнее
array_flip(array $array): array

// вернёт массив ключей_ если указано значение, то массив ключей указанного значения
array_keys(
  // массив
  array $array,

  // необязательное значение для поиска только его ключей
  mixed $val,

  // false - равенство, true - эквивалент
  bool $strict = false
  
): array
</code></pre>
          <p>Применить функцию к каждому элементу в массиве</p>
          <pre><code>// принимает функцию как параметр $callback и применяет её к элементам массива $array
// array_walk_recursive() - рекурсивный вариант функции, можно применить к вложенным массивам

array_walk(
    array|object &$array,
    callable $callback,

    // дополнительные параметры
    mixed $arg = null
): bool

// вернёт массив с изменёнными элементами
// количество параметров колбэк функции должно быть равно количеству обрабатываемых массивов
array_map(?callable $callback, array $array, array ... arrays): array

// вернёт копию массива с элементами согласно критерия фильтра
// колбэк функция $callback принимает по одному элементу массива $array
// сравнивает с критерием $mode и возвращает в функцию array_filter либо true либо false
// функция array_filter копирует в новый массив элементы массива $array, по которым колбэк функция вернула true
array_filter(array $array, ?callable $callback = null, int $mode = 0): array

// array_walk(), array_map(), array_filter() - всё вместе
array_reduce(array $array, callable $callback, mixed $initial = null): mixed
</code></pre>
          <p>Условия и циклы</p>
          <ul>
            <li>Ключевое слово break - прерывание выполнения.</li>
            <li>Ключевое слово continue - прервать текущую итерацию и перейти к следующей.</li>
          </ul>
          <p>Ветвление if</p>
          <pre><code>if (условие) {
  выражения
}

if (условие) {
  выражения
} else {
  выражения
}

if (условие) {
  выражения
} elseif (условие) {
  выражения
} else {
  выражения
}
</code></pre>
          <p>Тернарный оператор ?</p>
          <pre><code>условие ? выражение1 : выражение2
$х = isset($x) ?: 1;

// 1
echo $х;

// лучше так
// 1 - если переменная не инициализирована, то присвоит ей значение. если значение уже есть, то оставит без изменений
$х ??= 1;
</code></pre>
          <p>Конструкция switch, сравнивает выражение со значением через ==</p>
          <pre><code>switch (выражение)
{
  case значение1:
    выражения;
    break;
  case значение2:
    выражения;
    break;
  default:
    выражения;
}
</code></pre>
          <p>Конструкция match, сравнивает выражение с ключом через ===  </p>
          <ul>
            <li>возвращает первое совпавшее и прекращает поиск</li>
            <li>может быть частью операции с другими операторами и ключевыми словами</li>
            <li>точка с запятой в конце обязательно</li>
          </ul>
          <pre><code>match (выражение) {
  'key1' => 'value1',
  'key2' => 'value2'
};

// Использование
$str 'Hello, РНР! ';
$arr [1, 2, 3, 4, 5];
$obj new DateTime(); 
$arg = 'string';

// Hello, РНР!
echo match ( $arg) {
  gettype($str) => $str,
  gettype($arr) => print_r($arr),
  gettype($obj) => var_dump($obj)
};
</code></pre>
          <p>Конструкция goto: переход на метку - лучше не использовать</p>
          <pre><code>$i = О;
begin:
$i++;
echo "$i< Ьr />";
if ($i >= 10) goto finish;
goto begin;
finish:
</code></pre>
          <p>Цикл while</p>
          <pre><code>while (условие) {
  выражение;
}

$i = 5;
while ($i--):
  echo "$i< br />";
endwhile;

do {
  выражения;
} while (условие);
</code></pre>
          <p>Цикл for</p>
          <pre><code>for (начало счетчика; условие; инкремент/декремент) {
  выражения;
}

for ($i = О; $i < 5; $i++) {
  echo "$i< br/>";
}

for (;;) {} - бесконечный цикл

$numbers = ['1', '2', '3'];

// цикл вернёт 123
for ($i = О; $i < count($numbers); $i++) {
  echo $numbers[$i];
}
</code></pre>
          <p> Цикл foreach - создан специально для ассоциативных массивов</p>
          <pre><code>// вернёт
// first = 1 
// second = 2
// third = 3
$arr = [
  'first' => '1',
  'second' => '2',
  'third' => '3'
];

foreach ($arr as $index => $val) {
  echo "$index = $val < br/>";
}

// вернёт 123
$arr = [
  'first' => '1',
  'second' => '2',
  'third' => '3'
];

foreach ($arr as $val) {
  echo $val;
}

// перебрать многомерный массив через вложенный цикл
foreach ($arr as $key => $elem) {
  echo $key;
  foreach ($elem as $val) {
    echo $val;
  }
}

// либо перебрать через list()
foreach ($arr as $key => list($fst, $snd, $thd)) {
  echo $key;
  echo $fst;
  echo $snd;
  echo $thd;
}

// либо перебрать через []
foreach ($arr as $key => [$fst, $snd, $thd]) {
  echo $key;
  echo $fst;
  echo $snd;
  echo $thd;
}
</code></pre>
          <p>Функция - это набор выражений, который ведёт себя как одно выражение.</p>
          <ul>
            <li>по умолчанию функции с переменным числом параметров</li>
            <li>у каждой функции своя область видимости (контекст), которая уничтожается при выходе из функции</li>
            <li>каждый контекст - это отдельная область памяти</li>
            <li>время жизни локальной переменной - время выполнения функции, в которой она объявлена</li>
            <li>статическая переменная сохраняет своё значение до следующего вызова функции static $counter;</li>
            <li>время жизни статических и глобальных переменных - время выполнения сценария (до перезагрузки страницы)</li>
            <li>return - возвращает результат вычисления функции в вызывающую программу</li>
            <li>тип возвращаемого значения может быть любым, но можно задать принудительную проверку типа для значения и параметров</li>
            <li>можно создавать анонимные функции</li>
            <li>имя функции не зависит от регистра, CamelCase, первая буква маленькая</li>
            <li>функцию можно вызвать до её объявления</li>
            <li>переменные в определении функции function nameFunction($param) - параметры</li>
            <li>значения, передаваемые в функцию, при её вызове nameFunction(5) - аргументы, аргументы без имени - позиционные</li>
            <li>именованные аргументы позволяют связать имя параметра со значением nameFunction(param: 5)</li>
            <li>указать тип аргумента и возвращаемого значения nameFunction(int 5): int</li>
            <li>интерпретатор будет требовать указывать типы - declare(strict_types = 1);</li>
            <li>типы void, never и static только для возвращаемых значений</li>
            <li>если функция вызывает саму себя, то это рекурсивная функция</li>
            <li>вложенная функция может быть вызвана только после вызова основной функции, в которой объявлена вложенная</li>
            <li>каждая функция добавляется во внутреннюю таблицу функций PHP</li>
            <li>функция, переданная как параметр (в виде переменной) в другую функцию называется функцией обратного вызова, тип параметра - callable</li>
            <li>анонимная функция - $var = function(...$param) {}</li>
            <li>замыкание - это функция, которая запоминает состояние окружения в момент своего создания</li>
            <li>замыкание применяется только к анонимным функциям при помощи ключевого слова use</li>
            <li>use($var1, $var2) - перечислить переменные, которые должны войти в замыкание</li>
            <li>стрелочная функция - это короткая запись анонимной функции с однострочным выражением</li>
            <li>стрелочная функция всегда возвращает значение, return указывать не нужно - fn($n) =&gt; $n * $n;</li>
            <li>метод - это функция в классе или объекте</li>
          </ul>
          <p>Функция PHP</p>
          <pre><code>function nameFunction($param)
{
  // выражения
  // вернуть 0
  return 0;
}

// 0
echo nameFunction();

function simple()
{
  return [1, 2, 3];
}

$arr = simple();

// [1, 2, 3]
var_dump($arr);

// $a = 1, $b = 2, $c = 3
[$a, $b, $c] = simple();

// 3
echo simple()[2];
</code></pre>
          <p>Последовательность ...</p>
          <pre><code>// функция принимает неограниченное количество параметров, $items - массив параметров
function manyParam(...$items) {}
</code></pre>
          <p>Переменная в качестве аргумента</p>
          <pre><code>// аргумент передается по значению, т.е. внешнее значение копируется в тело функции
function getSшn($var)
{
  // изменяет значение внутри тела функции, внешнее не изменяется
  $var = $var + 5;
  return $var;
}

$new_var = 20;
echo getSшn($new_var); // 25
echo "$new_var";       // 20

// аргумент передается по ссылке, т.е. внешнее значение изменяется в теле функции
function getSшn(&$var)
{
  // изменяет значение внутри тела функции, внешнее не изменяется
  $var = $var + 5;
  return $var;
}

$new_var = 20;
echo getSшn($new_var); // 25
echo "$new_var";       // 25
</code></pre>
          <p>Встроенные функции</p>
          <pre><code>// удаляет значение переменной или элемента массива
unset()
unset($a);
unset($arr["elem"]);

// проверить существование значения переменной
isset()
$str='';

// true
if (isset($str)) {
echo 'Переменная $str существует< Ьr/>';

// Помечаем переменную $str как неинициализированную
$str = null;

// false
if (isset($str)) {
echo 'Переменная $str существует< Ьr/>';

// определить тип переменной: true | false
is_int($a);
is_double($a);
is_infinite($a);
is_nan($a);         // NAN (not a number) - недопустимое числовое значение
is_string($a);
is_numeric($a);     // рекомендовано использовать вместо is_int($a); и is_double($a);
is_bool($a);
is_scalar($a);
is_null($a);
is_array($a);
is_object($a);
gettype($a);
settype($a, 'int'); // привести переменную $a к типу int, вернёт true | false
floatval($a);       // привести переменную $a к типу float, вернёт значение
doubleval($a);      // привести переменную $a к типу double, вернёт значение
intval($a);         // привести переменную $a к типу int, вернёт значение
strval($a);         // привести переменную $a к типу str, вернёт значение

// необязательный аргумент $base говорит, что в аргументе $value восьмеричное число. По умолчанию $base = 10
intval(mixed $value, int $base = 8): int

// возвращает количество байтов оперативной памяти, занятые сценарием
memory_get_usage()
</code></pre>
          <p>Отладочные функции</p>
          <pre><code>// отладочное представление значений переменных и массивов
print_r(mixed $value, bool $return = false): string|bool

// отладочное представление значений и типов переменных и массивов
var_dump(mixed $value, mixed ... $values): void

// представление значений переменной как кусок кода программы
var_export(mixed $value, bool $return = false): ?string

// проверить наличие функции во внутренней таблице функций PHP, т.е. что она уже объявлена
function_exists(string $function): bool

// хранение функции в переменной
function hello()
{
    return 'Hello!';
}

function Ьуе()
{
    return 'Bye!';
}

$var = rand(0, 1) ? 'hello' : 'bye';

echo $var();  // вызов hello() и bye() по случайному выбору

// может ли переменная вызываться как функция
is_callable(
    mixed $val;                     // переменная, в которой может быть функция
    bool $syntax_only = false;      // необязательный
    string &$callable_name = null   // необязательный
): bool
</code></pre>
          <p>Генераторы - функции для создания собственных итераторов в цикле foreach:</p>
          <ul>
            <li>не создаёт копию массива, а использует элементы массива по одному, чем экономит память</li>
            <li>использовать слово return для возврата значения и выхода из функции генератора</li>
            <li>использовать слово yield для передачи на время потока вычисления циклу foreach и возврата обратно в функцию генератора</li>
            <li>возвращает объект</li>
          </ul>
          <table>
            <caption>генератор предоставляет функции, который позволяют обходить генератор без цикла foreach:</caption>
            <tbody>
              <tr>
                <td>send()</td>
                <td>передать значение внутрь генератора</td>
              </tr>
              <tr>
                <td>getReturn()</td>
                <td>получить из генератора значение, которое возвращается при помощи слова return</td>
              </tr>
              <tr>
                <td>current()</td>
                <td>вернуть текущее значение</td>
              </tr>
              <tr>
                <td>key()</td>
                <td>вернуть текущее значение по ключу - если в yield указан ключ</td>
              </tr>
              <tr>
                <td>next()</td>
                <td>переход в к следующей итерации, итератор однонаправленный - обратного хода нет</td>
              </tr>
              <tr>
                <td>valid()</td>
                <td>проверить работает ли генератор true|false</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>вернёт:</caption>
            <tbody>
              <tr>
                <td>первый yield</td>
                <td>foreach вызвал generator(), сработал echo 'первый yield' - вывел 'первый yield'</td>
              </tr>
              <tr>
                <td>1</td>
                <td>yield вернул управление в foreach и цифру 1, foreach вывел 1</td>
              </tr>
              <tr>
                <td>второй yield</td>
                <td>foreach вызвал generator(), сработал echo 'второй yield' - вывел 'второй yield'</td>
              </tr>
              <tr>
                <td>2</td>
                <td>yield вернул управление в foreach и цифру 2, foreach вывел 2</td>
              </tr>
              <tr>
                <td>третий yield</td>
                <td>foreach вызвал generator(), сработал echo 'третий yield' - вывел 'третий yield'</td>
              </tr>
              <tr>
                <td>3</td>
                <td>yield вернул управление в foreach и цифру 3, foreach вывел 3</td>
              </tr>
              <tr>
                <td>после третьего yield</td>
                <td>foreach вызвал generator(), сработал echo 'после третьего yield' - вывел 'после третьего yield'</td>
              </tr>
              <tr>
                <td></td>
                <td>функция generator() после echo 'после третьего yield'; ничего не содержит, поэтому возвращает null</td>
              </tr>
              <tr>
                <td>                    </td>
                <td>foreach получает null и завершает работу</td>
              </tr>
            </tbody>
          </table>
          <pre><code>function generator()
{
  echo 'первый yield';
  yield 1;
  echo 'второй yield';
  yield 2;
  echo 'третий yield';
  yield 3;
  echo 'после третьего yield';
}

foreach (generator() as $i) {
  echo $i < br/>;
}

// варианта с колбэк функцией - вернёт: 1 4 9 16 25  36
function collect(array $arr, callable $callback)
{
  foreach ($arr as $value) {
    yield $callback($value);
  }
}

$arr = [1, 2, 3, 4, 5, 6];
$collect = collect($arr, fn($e) => $e * $e);
foreach ($collect as $val) {
  echo "$val";
}

// делегирование генераторов - вызов одного генератора из другого
function square($value) {
  yield $value * $value;
}

function even_square($arr) {
  foreach ($arr as $value) {
    if ($value % 2 == 0) yield from square($value)
  }
}

$arr = [1, 2, 3, 4, 5, 6];
foreach (even_square($arr) as $ val) echo "$val ";

// использовать ключи - вернёт: 1 (first) 4 (second) 9 (third) 16 (fourth) 25 (fifth) 36 (sixth) 
function collect(array $arr, callaЫe $callback) {
  foreach ($arr as $key => $value) {
    yield $key => $callback($value);
  }
}

$arr = [
  'first' => 1,
  'second' => 2,
  'third' => 3,
  'fourth' => 4,
  'fifth' => 5,
  'sixth' => 6 
];

$collect = collect($arr, fn($e) => $е * $е);

foreach ($collect as $key => $val) {
  echo "$val ($key) ";
}
</code></pre>
          <p>Текст и HTML</p>
          <ul>
            <li>для работы с UTF-8 нужно расширение mbstring. Расскоментировать (убрать ;) extension dir = 'ext', extension=php_mЬstring.dll в php.ini.</li>
            <li>mbstring может заменять стандартные функции РНР работы со строками, это определяется в настройках mbstring.</li>
          </ul>
          <p>Строки</p>
          <pre><code>// символ из кодировкки UTF-8
// русская А
echo "\u{0410}";

// вернуть подстроку
// $length - количество символов возвращаемой подстроки, необязательный
substr(string $string, int $offset, ?int $length = null): string

$str = '04.02.2005';
// день - 04
echo 'день - ' . substr($str, 0, 2);

// вернуть позицию вхождения подстроки в строку
// $offset - позиция, с которой начинается поиск, необязательный
strpos(string $string, string $substring, int $offset = 0): int|false
echo strpos('Hello, world!', 'world'); // 7
</code></pre>
          <p>удалить пробелы и пробельные символы:</p>
          <ul>
            <li>пробел ' '</li>
            <li>перевод строки 
</li>
            <li>возврат каретки </li>
            <li>табуляция 	</li>
            <li>вертикальная табуляция </li>
            <li>нулевой байт  </li>
          </ul>
          <pre><code>// $characters - обозначить удаляемые символы, необязательный
trim(string $string, string $characters = " \n\r\t\v\x00"): string
</code></pre>
          <ul>
            <li>в строке $subject заменить подстроку $search на $replace</li>
            <li>$count - содержит количество проведенных замен</li>
            <li>str_replace() - с учётом регистра символов</li>
            <li>str_ireplace() - без учёта регистра символов</li>
          </ul>
          <pre><code>str_replace(
  array|string $search,
  array|string $replace,
  array|string $subject,
  int &$count = null
): array|string
</code></pre>
          <p>Локаль - локальные настройки: числа, валюта, формат времени и даты.</p>
          <table>
            <caption>Переменные окружения РНР для управления локалью:</caption>
            <tbody>
              <tr>
                <td>LC COLLATE</td>
                <td>правила сравнения и сортировки строк для местного алфавита</td>
              </tr>
              <tr>
                <td>LC СТУРЕ</td>
                <td>распознавать вид символа: цифра, буква, знак, верхний и нижний регистр</td>
              </tr>
              <tr>
                <td>LC МONETARY</td>
                <td>правила национального представления денежных величин</td>
              </tr>
              <tr>
                <td>LC NUМERIC</td>
                <td>правила национального представления чисел с плавающей точкой</td>
              </tr>
              <tr>
                <td>LC ТIМЕ</td>
                <td>правила национального представления даты и времени</td>
              </tr>
              <tr>
                <td>LC МESSAGES</td>
                <td>формат информационных, диагностических и интерактивных сообщений операционной системы</td>
              </tr>
              <tr>
                <td>LC ALL</td>
                <td>устанановить значения для всех приведенных выше переменных</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// узнать язык и кодировку
echo $LANG;

// вернёт текущее значение локали
echo setlocale(LC_ALL, О);

// вернёт ассоциативный массив с информацией о локали
localeconv(): array

setlocale(int $category, string $locales, string ...$rest): string|false

// установить локаль для денежных единиц
setlocale(LC_MONETARY, 'ru_RU.UТF-8');

// установка русской локали в переменной $loc
$loc = setlocale(LC_ALL, 'ru', 'ru_RU', 'rus', 'russian');
</code></pre>
          <p> Обработка HTML</p>
          <pre><code>n12br(string $string, bool $use_xhtml = true): string</code></pre>
          <ul>
            <li>функция n12br() добавляет на тег &lt; br/&gt; к каждому переводу строки 
</li>
            <li>лучше использовать str_replace()</li>
            <li>$use_xhtml = false - &lt; br&gt;</li>
            <li>$use_xhtml = true  - &lt; br/&gt;</li>
          </ul>
          <pre><code>htmlspecialchars(
    // строка для преобразования
    string $string,
    int $flags = ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401,
    ?string $encoding = null,
    bool $double_encode = true
): string
</code></pre>
          <ul>
            <li>преобразовывает HTML в безопасное представление</li>
            <li>применять всегда при обработке текстовых сообщений из формы</li>
            <li>текст будет отображён, но выполняться не будет</li>
            <li>замена спецсимволов:</li>
            <li>&amp; - &amp;amp</li>
            <li>&quot; - &amp;quot</li>
            <li>' - &amp;#039 или &amp;apos</li>
            <li>&lt; - &amp;lt</li>
            <li>&gt; - &amp;gt</li>
          </ul>
          <pre><code>< !DOCTYPE html>
< html lang="en">

< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Calculator< /title>
< /head>

< body>
  < form action="< ?php echo htmlspecialchars($_SERVER["PHP_SELF"]); ?>" method="post">
    < input type="number" name="num01" placeholder="First num">
    < select name="operator">
      < option value="add">+< /option>
      < option value="subtract">-< /option>
      < option value="multiply">*< /option>
      < option value="divide">/< /option>
    < /select>
    < input type="number" name="num02" placeholder="Second num">
    < button>Calculate< /button>
  < /form>
  < ?php
  if ($_SERVER["REQUEST_METHOD"] == "POST") {

    // Grab data from inputs
    $num01 = filter_input(INPUT_POST, "num01", FILTER_SANITIZE_NUMBER_FLOAT);
    $num02 = filter_input(INPUT_POST, "num02", FILTER_SANITIZE_NUMBER_FLOAT);
    $operator = htmlspecialchars($_POST["operator"]);

    // Error handlers
    $errors = false;
    if (empty($num01) || empty($num02) || empty($operator)) {
      echo "< p>Fill in all fealds!< /p>";
      $errors = true;
    }

    if (!is_numeric($num01) || !is_numeric($num02)) {
      echo "< p>Only write numbers!< /p>";
      $errors = true;
    }

    // Calculate the numbers if no errors
    if (!$errors) {
      $value = 0;
      switch ($operator) {
        case 'add':
          $value = $num01 + $num02;
          break;
        case 'subtract':
          $value = $num01 - $num02;
          break;
        case 'multiply':
          $value = $num01 * $num02;
          break;
        case 'divide':
          $value = $num01 / $num02;
          break;
        default:
          echo "< p>Something went wrong!< /p>";
          break;
      }
      echo "< p>Result = " . $value . "< /p>";
    }
  }
  ?>
< /body>
< /html>
</code></pre>
        </details>
        <details>
          <summary>Apache</summary>
        </details>
        <details>
          <summary>Nginx</summary>
        </details>
        <h2>Performance</h2>
        <ul>
          <li>Несколько сессий</li>
          <li>Длительные сессии</li>
          <li>Большое количество действий</li>
          <li>Большие файлы</li>
          <li>Сложные запросы</li>
          <li>Низкая скорость интернета</li>
          <li>Throttling</li>
        </ul>
        <h2>Security</h2>
        <ul>
          <li>Матрица ролей</li>
          <li>SQL – инъекции</li>
          <li>XSS</li>
          <li>HTML tags</li>
        </ul>
      </main>
      <menu class="menu">
        <button id="search"><img src="./assets/img/search.svg" alt="search" loading="lazy"/></button>
        <button id="home"><img src="./assets/img/q.svg" alt="home" loading="lazy"/></button>
        <button id="dropup"><img src="./assets/img/menu.svg" alt="menu" loading="lazy"/></button>
      </menu>
    </div>
  </body>
</html>