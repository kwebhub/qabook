<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="format-detection" content="telephone=no">
    <meta name="robots" content="noindex, nofollow">
    <meta name="robots" content="none">
    <meta name="robots" content="noimageindex, nofollow">
    <link rel="icon" type="image/svg+xml" href="./assets/favicon.svg">
    <link rel="stylesheet" type="text/css" href="./assets/style.css">
    <title>qabook</title>
    <script defer type="module" src="./assets/js/main.js"></script>
  </head>
  <body>
    <nav class="dropup"><a href="./process.html">Process</a><a href="./docs.html">Docs</a><a href="./web.html">Web</a><a href="#!">Project</a><a href="./job.html">Job</a>
    </nav>
    <div class="search">
      <form class="search__content">
        <input type="text" placeholder="search...">
        <button class="search-btn" type="submit"><img src="./assets/img/search.svg" alt="" loading="lazy"/>
        </button>
        <button class="search-reset" type="reset"><img src="./assets/img/close.svg" alt="" loading="lazy"/>
        </button>
      </form>
    </div>
    <button class="close"><img src="./assets/img/close.svg" alt="" loading="lazy"/>
    </button>
    <div class="container">
      <header><nav class="breadcrumbs" id="breadcrumbs-container"></nav>
      </header>
      <main>
        <h2>Internet (Интернет)</h2>
        <ul>
          <li>Всемирная система объединённых компьютерных сетей для хранения, обработки и передачи информации.</li>
          <li>Сеть сетей, которая объединяет в себе компьютеры, маршрутизаторы и сервера.</li>
          <li>Очень большая сеть компьютеров, которые взаимодействую друг с другом.</li>
          <li>Интернет - это инфраструктура, а ВЭБ - это сервис, построенный на основе этой инфраструктуры.</li>
        </ul>
        <p>Всемирная паутина (World Wide Web) — распределённая система, предоставляющая доступ к связанным между собой документам, расположенным на различных компьютерах, подключённых к сети Интернет.</p>
        <p>Веб-служба, веб-сервис (web service) — идентифицируемая уникальным веб-адресом (URL-адресом) программная система со стандартизированными интерфейсами, а также HTML-документ сайта, отображаемый браузером пользователя.</p>
        <details> 
          <summary>Mobile</summary>
          <h2>Native apps</h2>
          <ul>
            <li>Под нативным мы подразумеваем мобильное приложение, которое создается для определенной платформы и непосредственно устанавливается на устройство пользователя (занимая определенный объем памяти).</li>
            <li>Такие приложения пользователь загружает через магазин приложений той или иной платформы, такой как Play Store для Google и Apple App Store для iOS.</li>
            <li>Органично выглядят на телефоне.</li>
            <li>Используют все функции программного обеспечения гаджета.</li>
            <li>Имеют быстрый отклик и плавность анимаций интерфейса.</li>
            <li>Надежнее (работают стабильнее).</li>
            <li>Экономнее расходуют ресурсы телефона: батарею, память.</li>
            <li>Дорого в разработке.</li>
          </ul>
          <h2>Web apps</h2>
          <p>
            Веб приложения работают через веб-браузер на устройстве пользователя.
            Эти приложения по сути являются индивидуализированными вебсайтами, которые сделаны таким образом, чтобы выглядеть и использоваться как нативные приложения, но на самом деле они не находятся на устройстве пользователя.
          </p>
          <ul>
            <li>Приложения на веб-основе легче поддерживаются и они могут функционировать на платформе с любой ОС.</li>
            <li>Разработчики могут предлагать приложения без необходимости их утверждения какими-либо магазинами приложений.</li>
            <li>Более быстрая разработка циклов с использованием CSS, HTML и JavaScript.</li>
            <li>Нет доступа к устройству пользователя.</li>
            <li>Пользователи должны использовать их через сеть, что значительно снижает контроль безопасности.</li>
            <li>Поиск приложения может быть затруднительным, так как не существует магазина приложений с каталогом и функцией поиска в нем.</li>
          </ul>
          <h2>Hybrid apps</h2>
          <p>
            Гибридные приложения являются чем-то средним между нативными и веб-приложениями.<br />
            Фактически они создаются так, чтобы выглядеть и использоваться как нативные приложения.<br />
            Их также устанавливают на телефон пользователя и их можно найти в магазинах приложений.<br />
            Различие заключается в том, что они обязательно должны размещаться в рамках нативного приложения и созданы, чтобы работать через WebView.
          </p>
          <ul>
            <li>Запускается не из браузера, возможно независимое обновление.</li>
            <li>Скорость разработки, а, следственно, и цена значительно ниже, чем нативные приложения.</li>
            <li>Возможность распространяться через магазины приложений (в отличие от веб-приложений).</li>
            <li>Скорость и стабильность работы оставляют желать лучшего.</li>
            <li>Сложности в масштабировании и развитии проекта.</li>
            <li>Сложности и нестабильность при использовании различных модулей/функций смартфона.</li>
          </ul>
        </details>
        <details>
          <summary>Браузер</summary>
          <h2>Браузер</h2>
          <p>Браузер - это программа, которая позволяет искать информацию в интернете, просматривать сайты, скачивать и загружать файлы.</p>
          <ul>
            <li>Это среднее звено между пользователем и интернетом.</li>
            <li>Пользователь вводит в адресную строку браузера адрес сайта.</li>
            <li>Браузер ищет сервер по IP-адресу. Сервер - это программа.</li>
            <li>Сначала он ищет в кэше роутера, операционной системе или в истории подключений.</li>
            <li>Потом смотрит в DNS.</li>
            <li>Найдя нужный IP-адрес, браузер устанавливает соединение с сервером с помощью протокола TCP/IP.</li>
            <li>Для установки соединения используется процесс 'рукопожатие' (handshaking).</li>
            <li>Браузер отправляет HTTP запрос на сервер для отображения страницы.</li>
            <li>Запрос обрабатывается вэб-сервером.</li>
          </ul>
          <p>После этого сервер отправляет браузеру ответ с данными:</p>
          <ul>
            <li>файлы cookie</li>
            <li>способ кэширования</li>
            <li>контент страницы</li>
          </ul>
          <p>Браузер обрабатывает ответ и отображает запрашиваемый контент (рендеринг).</p><img src="./assets/img/contimg/cookie.png" alt="" loading="lazy"/>
          <h2>Cookie</h2>
          <p>
            Это маленький файл, который сохраняется в браузере клиента и содержит информацию про пользователя.<br />
            Когда клиент обращается к серверу браузер автоматически включает куки в запрос.<br />
            Это позволяет серверу идентифицировать пользователя и сохранить про него данные (язык, местонахождение, настройки).
            
          </p>
        </details>
        <details>
          <summary>Net</summary>
          <h2>Net</h2>
          <p>
            Internet, Ethernet, WI-FI, WLAN, IP, MAC, Маска подсети, VLAN</br>
            OSI и TCP/IP - уровни и типы данных: сегменты, датаграммы, пакеты, биты, кадры</br>
            OSI (Open Systems Interconnection) - эталонная модель: модель взаимодействия открытых систем:
          </p>
          <ul>
            <li>эталонная модель организации компьютерных сетей</li>
            <li>юридический стандарт организации ISO</li>
            <li>7 уровней организации сети и их назначение</li>
            <li>протоколы не включены в модель</li>
            <li>не используется на практике, удобна для описания компьютерных сетей</li>
          </ul>
          <table>
            <caption>Уровни OSI</caption>
            <thead>
              <tr>
                <th>Уровень</th>
                <th>Единица</th>
                <th>Оборудование</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Прикладной</td>
                <td>Сообщение</td>
                <td>На хосте</td>
              </tr>
              <tr>
                <td>Представления</td>
                <td>Сообщение</td>
                <td>На хосте</td>
              </tr>
              <tr>
                <td>Сеансовый</td>
                <td>Сообщение</td>
                <td>На хосте</td>
              </tr>
              <tr>
                <td>Транспортный</td>
                <td>Сегмент/Дейтаграмма</td>
                <td>На хосте</td>
              </tr>
              <tr>
                <td>Сетевой</td>
                <td>Пакет</td>
                <td>Маршрутизатор</td>
              </tr>
              <tr>
                <td>Канальный</td>
                <td>Кадр</td>
                <td>Коммутатор, точка доступа Wi-Fi</td>
              </tr>
              <tr>
                <td>Физический</td>
                <td>Бит</td>
                <td>Концентратор, репитор</td>
              </tr>
            </tbody>
          </table>
          <p>Физический уровень - основная задача это передача битов по физическому каналу связи, т.е. перевод битов в сигналы и обратно. Бит - 0 или 1. Сигналы передаются по:</p>
          <ul>
            <li>перепады напряжения для меди</li>
            <li>импульсы для оптоволокна</li>
            <li>электромагнитное излучение для радиосвязи</li>
          </ul>
          <p>Передача потока бит по среде передачи данных:</p>
          <ul>
            <li>не вникает в смысл передаваемой информации</li>
            <li>единица передачи информации - бит (...01100111001...)</li>
          </ul>
          <p>Скорость канала:</p>
          <ul>
            <li>Пропускная способность (бит/с) - количество передачи данных за единицу времени.</li>
            <li>Задержка - сколько времени пройдёт пока сообщение от отправителя дойдёт до получателя.</li>
            <li>Количество ошибок - если возникают часто, то сетевое оборудование должно иметь инструменты их исправления, если редко, то ошибки можно исправлять на более высоких уровнях.</li>
          </ul>
          <p>Типы каналов связи:</p>
          <ul>
            <li>Симплексный - передача только в одну сторону.</li>
            <li>Дуплексный - передача данных в обе стороны одновременно.</li>
            <li>Полудуплексный - передача данных в обе стороны по очереди.</li>
          </ul>
          <p>Кабель - ошибки редко:</p>
          <ul>
            <li>Витая пара - скрученные для уменьшения помех медные кабели.</li>
            <li>Оптический кабель - тонкие световоды объединяются в один кабель.</li>
          </ul>
          <p>Беспроводные технологии - ошибки часто:</p>
          <ul>
            <li>Радиоволны - GSM 900 МГц лицензируется, Wi-Fi 2,4 ГГц и 5 ГГц без лицензий.</li>
            <li>Спутниковые каналы.</li>
          </ul>
          <table>
            <caption>Представление информации</caption>
            <tbody>
              <tr>
                <td>Медные провода</td>
                <td>кодирование</td>
                <td>прямоугольные импульсы</td>
              </tr>
              <tr>
                <td>Оптоволокно, беспроводная среда</td>
                <td>модуляция</td>
                <td>синусоидальные волны</td>
              </tr>
            </tbody>
          </table>
          <p>Канальный уровень:</p>
          <ul>
            <li>определяет начало/конец сообщения в потоке бит</li>
            <li>обнаруживает и исправляет ошибки</li>
            <li>управляет доступом к среде передачи данных (одномоментно передаёт только один.)</li>
            <li>физическая адресация (МАС)</li>
          </ul>
          <p>Сетевой уровень:</p>
          <ul>
            <li>создание составной сети и согласование различий в сетях</li>
            <li>адресация (сетевые и глобальные адреса)</li>
            <li>определение маршрута пересылки пакетов в составной сети (маршрутизация)</li>
          </ul>
          <p>Транспортный уровень:</p>
          <ul>
            <li>передача данных между процессами на хостах</li>
            <li>управляет надёжностью (защищённый от ошибок канал с гарантированным порядком следования сообщений)</li>
            <li>сквозной уровень от отправителя к получателю</li>
          </ul>
          <p>Сеансовый уровень:</p>
          <ul>
            <li>создаёт сеансы связи</li>
            <li>управляет диалогом (очерёдностью передачи сообщений)</li>
            <li>управляет маркерами (не допускает одновременно выполнять критические операции)</li>
            <li>синхронизация (метки в сообщениях для возобновления передачи в случае сбоя связи)</li>
            <li>на практике сеансовый уровень в сетях не используется</li>
          </ul>
          <p>Уровень представления:</p>
          <ul>
            <li>согласование форматов представления символов и чисел</li>
            <li>шифрование и дешифрование</li>
          </ul>
          <p>Прикладной уровень - приложения:</p>
          <ul>
            <li>web-страницы</li>
            <li>соц.сети</li>
            <li>видео и аудио связь</li>
            <li>почта</li>
            <li>доступ к файлам и т.д.</li>
          </ul>
          <p>
            TCP/IP - произошло от TCP и IP.<br />
            Набор правил, который позволяет обрабатывать сквозную передачу данных.<br />
            Сюда входит: формирование пакетов, способ их отправки, получения, маршрутизации, распаковки для передачи программному обеспечению.
          </p>
          <table>
            <caption>TCP/IP - модель протокола</caption>
            <thead>
              <tr>
                <th>TCP/IP</th>
                <th>Протоколы в заголовках сообщений</th>
                <th>Задачи</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Application</td>
                <td>HTTP (передача данных в формате HTML)</td>
                <td>Показ пользователю, кодирование, шифрование, управление сеансами</td>
              </tr>
              <tr>
                <td>Transport</td>
                <td>TCP (порт приложения, контроль доставки)</td>
                <td>Установка соединения между устройствами в разных сетях</td>
              </tr>
              <tr>
                <td>Internet</td>
                <td>IP (нахождение устройства по ip-адресу)</td>
                <td>Межсетевой маршрут от отправителя к получателю</td>
              </tr>
              <tr>
                <td>Network access</td>
                <td>Ethernet (общение между сетевыми картами в одной сети)</td>
                <td>Управление устройствами внутри сети</td>
              </tr>
            </tbody>
          </table>
          <p>Классификация и топология сетей: звезда, шина, кольцо</p>
          <p>URI</p>
          <ul>
            <li>URI (Uniform Resource Indicator) - унифицированный идентификатор ресурса: включает в себя URL, URN и другие способы указания ресурса.</li>
            <li>URI данных - это не URL или URN, содержит данные, например: data:Hello%20World.</li>
            <li>URL (Uniform Resource Locator) — унифицированный указатель ресурса) - адрес, который выдан уникальному ресурсу в интернете. Такими ресурсами могут быть html-страница, css-файл, изображение и т.д.</li>
            <li>URN (Uniform Resource Name) - унифицированное имя ресурса: является уникальным именем объекта и включает в себя название пространства имен и идентификатора в этом пространстве.</li>
            <li>URC (Uniform Resource Characteristic) - единая характеристика ресурса: содержит метаинформацию о ресурсе / описание ресурса, например: view-source: http://example.com/</li>
          </ul><img src="./assets/img/contimg/URI.png" alt="" loading="lazy"/>
          <table>
            <caption>Виды идентификаторов ресурсов</caption>
            <thead> 
              <tr>
                <th>Имя</th>
                <th>Описание</th>
                <th>Пример</th>
              </tr>
            </thead>
            <tbody> 
              <tr>
                <td><a href="http://docs.oasis-open.org/xri/2.0/specs/xri-syntax-V2.0.html">XRI</a></td>
                <td>Обобщенный URI для унификации многообразия идентификаторов</td>
                <td>xri://broadview.library.example.com/(urn:isbn:0-395-36341-1)</td>
              </tr>
              <tr>
                <td><a href="https://ru.wikipedia.org/wiki/Internationalized_Resource_Identifier">IRI</a></td>
                <td>URI с локализацией для удобства использования в не англоговорящих странах</td>
                <td>http://ru.wikipedia.org/wiki/Кириллица</td>
              </tr>
              <tr>
                <td><a href="https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.3">URI</a></td>
                <td>Единый идентификатор ресурса</td>
                <td>mailto:John.Doe@example.com</td>
              </tr>
              <tr>
                <td><a href="https://en.wikipedia.org/wiki/URL">URL</a></td>
                <td>Единый локатор ресурса. Указывает на место, где ресурс расположен</td>
                <td>file://C:\UserName.HostName\Projects\Wikipedia_Articles\URI.xml</td>
              </tr>
              <tr>
                <td><a href="https://en.wikipedia.org/wiki/Uniform_Resource_Name">URN</a></td>
                <td>Единое имя ресурса. Независимо от его расположения</td>
                <td>urn:isbn:0451450523</td>
              </tr>
              <tr>
                <td><a href="http://sti15.com/bib/formats/urc.html">URC</a></td>
                <td>Единая характеристика ресурса. Содержит метаинформацию о ресурсе / описание ресурса</td>
                <td>URN:IANA:626:oit:cs:ftp-and-telnet; URL:http://www.gatech.edu/oit/cs/ftp-and-telnet.html;</td>
              </tr>
              <tr>
                <td><a href="https://ru.wikipedia.org/wiki/PURL">PURL</a></td>
                <td>Постоянный URL. Защищает от перемещения ресурса (404)</td>
                <td>http://purl.russian-books.com/WarAndPeace/chapter12.html</td>
              </tr>
              <tr>
                <td><a href="https://www.paulirish.com/2010/the-protocol-relative-url/">PRURL</a></td>
                <td>URL, способный определить схему по контексту использования</td>
                <td>//domain.com/img/logo.png</td>
              </tr>
              <tr>
                <td><a href="https://en.wikipedia.org/wiki/CURIE">CURIE</a></td>
                <td>Compact URI. Сокращенное представление URI</td>
                <td>[isbn:0393315703]</td>
              </tr>
            </tbody>
          </table><img src="./assets/img/contimg/XRI.png" alt="" loading="lazy"/>
          <p>
            ISP (internet service provider) — поставщик интернет-услуги (иногда просто провайдер) — организация, предоставляющая услуги доступа к сети Интернет и иные связанные с Интернетом услуги.<br />
            Хостинг (hosting) — услуга по предоставлению ресурсов для размещения информации на сервере, постоянно находящемся в сети (обычно Интернет).<br />
            Это комбинация программных и аппаратных технологий, позволяющая разместить в интернете сайт, приложение, базу данных и их составные компоненты, требующие постоянного нахождения в онлайне.
          </p>
          <ul>
            <li>Два основных термина: хостинг-сервер и хостинг-провайдер.</li>
            <li>Сервер - компьютер, на котором хранятся файлы сайта или приложения. Работает 24/7.</li>
            <li>Хостинг-провайдер - компания, обслуживающая сервер и создающая ПО для него.</li>
            <li>Процессор, оперативная память и дисковое пространство сервера передаются клиенту в пользование за плату.</li>
          </ul>
          <p>Сетевое оборудование: сетевая карта, маршрутизатор, точка доступа, коммутатор, ретранслятор, витая пара, оптоволокно.</p>
          <p>Клиент-серверная архитектура: взаимодействие сервера, клиента и БД - что происходит при отправке запроса на сервер.</p>
          <p>Отличия идентификации, аутентификации и авторизации, виды авторизации, куки</p>
          <p>Что такое DNS, кэш и веб-сокет</p>
          <p>Домен (доменное имя) – это псевдоним для IP-адреса понятный для человека, состоящий из набора символов и цифр.</p>
          <ul>
            <li>Каждое доменное имя в Интернете является уникальным.</li>
            <li>Максимальная длина доменного имени (между точками) – 63 символа.</li>
            <li>Общая длина имени, включая поддомены, разделительные точки и имя зоны домена, может составлять до 255 знаков.</li>
          </ul>
          <p>DNS (Domain Name System) — система доменных имён: компьютерная распределённая система для получения информации о доменах.</p>
          <ul>
            <li>Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства).</li>
            <li>Когда пользователь вводит доменное имя в браузере, браузер отправляет DNS - запрос на DNS-сервер для преобразования доменного имени в IP-адрес.</li>
            <li>DNS-сервер прослушивает порт 53.</li>
            <li>DNS - это распределённая база данных, которая сопоставляет доменные имена с IP-адресами.</li>
          </ul>
          <p>Система адресов интернета имеет иерархическую структуру:</p>
          <ul>
            <li>домены уровня страны (.us)</li>
            <li>домены верхнего уровня (.com)</li>
            <li>поддомены</li>
          </ul>
          <p>
            Протокол — документ, фиксирующий какое-либо событие, факт или договоренность.</br>
            Веб-протокол, также известный как протокол передачи данных - это набор правил, который описывает последовательность взаимодействия двух и более устройств, подключённых к одной сети.
          </p>
          <p>Протоколы:</p>
          <ul>
            <li>IPv4, IPv6</li>
            <li>ICMP, ICMPv6</li>
            <li>DHCP, DHCPv6</li>
            <li>TCP,  UDP</li>
            <li>HTTP, HTTPS</li>
            <li>SSH,  Ethernet</li>
            <li>ARP,  PPP</li>
            <li>FTP,  SFTP</li>
            <li>SMTP, POP3</li>
          </ul>
          <table>
            <caption>Характеристики протокола</caption>
            <tbody>
              <tr>
                <td>Формат сообщения</td>
                <td>зависит от типа сообщения и канала передачи</td>
              </tr>
              <tr>
                <td>Розмер сообщения</td>
                <td>зависит от канала передачи</td>
              </tr>
              <tr>
                <td>Синхронизация</td>
                <td>определяет в какой очередности и с какой скоростью узлы будут отправлять сообщения</td>
              </tr>
              <tr>
                <td>Инкапсуляция</td>
                <td>добавление к фрагменту сообщения заголовка с данными об отправиле и получете</td>
              </tr>
              <tr>
                <td>Шаблон сообщения</td>
                <td>требуется ли подтверждение о получении сообщения перед отправкой следующего или нет</td>
              </tr>
              <tr>
                <td>Кодирование</td>
                <td>биты кодируются отправителем в виде световых, электрических или электромагнитных импульсов, взависимости от среды передачи сигнала. Получатель эти импульсы декодирует в биты.</td>
              </tr>
            </tbody>
          </table>
          <h2>Ethernet</h2>
          <p>
            После преамбулы все компьютеры в сети начинают записывать передаваемый кадр в свой буфер.</br>
            Первые 6 байт кадра содержат адрес получателя:
          </p>
          <ul>
            <li>компьютер, который узнал свой адрес, продолжает записывать кадр</li>
            <li>остальные удаляют кадр из буфера</li>
          </ul>
          <p>
            Для диагностики сети удобно использовать Promiscuous mode (неразборчивый режим работы сетевого адаптера) - адаптер принимает все кадры в сети, не зависимо от МАС-адреса получателя.<br />
            Недостатки классического Ethernet:
            
          </p>
          <p>Плохая масштабируемость:</p>
          <ul>
            <li>сеть становиться неработоспособной при загрузки разделяемой среды больше чем на 30%</li>
            <li>работоспособное количество компьютеров - 30</li>
          </ul>
          <p>Низкая безопасность - данные в разделяемой среде доступны всем.</p>
          <p>Разное время доставки кадра:</p>
          <ul>
            <li>причина - коллизии</li>
            <li>плохо для трафика реального времени (аудиозвонок, видеоконференция)</li>
          </ul>
          <p>
            В распределяемой среде возможны коллизии.<br />
            В коммутируемом Ethernet соединение Точка-Точка без разделяемой среды.
            
          </p>
          <h2>IP & Port</h2>
          <p>
            Internet Protocol (IP, досл. «межсетевой протокол») - маршрутизируемый протокол сетевого уровня стека TCP/IP.<br />
            Именно IP стал тем протоколом, который объединил отдельные компьютерные сети во всемирную сеть Интернет.<br />
            Неотъемлемой частью протокола является адресация сети - IP-адрес.<br />
            <br />
            IP-адрес — уникальный сетевой адрес узла в компьютерной сети, построенной на основе стека протоколов TCP/IP.<br />
            В сети Интернет требуется глобальная уникальность адреса, в случае работы в локальной сети требуется уникальность адреса в пределах сети.<br />
            Чтобы обратиться к какому-то компьютеру, каждый компьютер, подключенный к сети, имеет свой уникальный адрес - IP-адрес.<br />
            <br />
            Каждый компьютер, подключенный к интернету, может быть доступен через публичный IP-адрес, который состоит из 32 бит для IPv4 (такие адреса обычно записываются в виде четырёх чисел от 0 до 255, разделённых точками: 173.194.121.32) или 128 бит для IPv6 (обычно записываются в виде 8 групп по 4 шестнадцатеричных числа, разделённых двоеточиями: 2027:0da8:8b73:0000:0000:8a2e:0370:1337).<br />
            <br />
            ICANN (Internet Corporation for Assigned Names and Numbers) - Корпорация по управлению доменными именами и IP-адресами.<br />
          </p><a href="https://www.icann.org">ICANN</a><br><a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">Service Name and Transport Protocol Port Number Registry</a>
          <p>Сокет - комбинация исходного IP-адреса и номера порта источника, или IP-адреса и номера порта назначения.</p>
          <ul>
            <li>192.168.1.5:1099 - сокет источника</li>
            <li>192.168.1.7:80   - сокет веб сервера</li>
          </ul>
          <p>
            Netstat – это сетевая утилита, которая может использоваться для проверки соединений.<br />
            Параметр -n - отображение IP-адресов и номеров портов в числовом виде.<br />
            Порты назначаются и управляются организацией, известной как ICANN.<br />
            Порты делятся на три категории и имеют число от 1 до 65535:
          </p>
          <ul>
            <li>Хорошо известные порты – порты назначения, связанные с общими сетевыми программами, идентифицируются как хорошо известные порты. Эти порты находятся в диапазоне от 1 до 1023.</li>
            <li>Зарегистрированные порты – порты от 1024 до 49151 можно использовать в качестве портов источника или назначения. Они могут быть использованы организациями для регистрации конкретных приложений, таких как программы чата.</li>
            <li>Частные порты – порты от 49 152 до 65 535, которые часто используются как порты источника.&lt;br /&gt;Эти порты могут использоваться любыми приложениями.</li>
          </ul>
          <table>
            <caption>Команды</caption>
            <tbody>
              <tr>
                <td>ipconfig</td>
                <td>информация про IP-конфигурацию</td>
              </tr>
              <tr>
                <td>ping</td>
                <td>проверка соединения с другими IP-хостами</td>
              </tr>
              <tr>
                <td>netstat</td>
                <td>просмотр сетевых соединений</td>
              </tr>
              <tr>
                <td>tracert</td>
                <td>просмотр маршрута до места назначения</td>
              </tr>
              <tr>
                <td>nslookup</td>
                <td>информация про домен</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Команда ipconfig /all предназначена для просмотра расширенной информации, включая MAC-адреса, IP-адреса шлюза по умолчанию и DNS-серверы.</li>
            <li>Также указывается, включен ли протокол DHCP и выводятся данные адреса DHCP-сервера и информация об аренде.</li>
            <li>Если используется динамическое назначение IP-адресов, команда ipconfig /release удаляет существующие привязки адресов DHCP.</li>
            <li>Команда ipconfig /renew запрашивает текущую конфигурацию с DHCP-сервера. Хост может содержать ошибочную или устаревшую информацию о конфигурации IP, и простое обновление этой информации – это все, что нужно для восстановления соединения.</li>
          </ul>
          <p>
            TCP (Transmission Control Protocol) - протокол управления передачей.<br />
            Обмен данными, ориентированный на соединения, может использовать надежную связь, для обеспечения которой протокол уровня 4 (транспортный) посылает подтверждения о полученных данных и запрашивает повторную передачу, если данные не получены или искажены.
          </p>
          <p>
            Пакеты в TCP называются сегментами.<br />
            TCP используется в прикладных протоколах HTTP, FTP, SMTP, Telnet.<br />
            Перед отправкой сообщения по протоколу TCP соединение должно быть открыто.<br />
            Механизм TCP предоставляет поток данных с предварительной установкой соединения, осуществляет повторный запрос данных в случае потери данных и устраняет дублирование при получении двух копий одного пакета.<br />
          </p>
          <p>
            Процесс начала сеанса TCP (также называемый «*рукопожатие*» (handshake)), состоит из трёх шагов.<br />
            Клиент, который намеревается установить соединение, посылает серверу сегмент с номером последовательности и флагом SYN.
          </p>
          <ul>
            <li>Сервер получает сегмент, запоминает номер последовательности и пытается создать сокет (буфера и управляющие структуры памяти) для обслуживания нового клиента.</li>
            <li>В случае успеха сервер посылает клиенту сегмент с номером последовательности и флагами SYN и ACK, и переходит в состояние SYN-RECEIVED.</li>
            <li>В случае неудачи сервер посылает клиенту сегмент с флагом RST.</li>
          </ul>
          <p>Если клиент получает сегмент с флагом SYN, то он запоминает номер последовательности и посылает сегмент с флагом ACK.</p>
          <ul>
            <li>Если клиент одновременно получает и флаг ACK (что обычно и происходит), то он переходит в состояние ESTABLISHED.</li>
            <li>Если клиент получает сегмент с флагом RST, то он прекращает попытки соединиться.</li>
            <li>Если клиент не получает ответа в течение 10 секунд, то он повторяет процесс соединения заново.</li>
          </ul>
          <p>
            Если сервер в состоянии SYN-RECEIVED получает сегмент с флагом ACK, то он переходит в состояние ESTABLISHED.<br />
            В противном случае после тайм-аута он закрывает сокет и переходит в состояние CLOSED.
            
          </p>
          <p>
            UDP - User Datagram Protocol. В отличии от TCP, UDP - очень быстрый протокол поскольку в нём определён самый минимальный механизм необходимый для передачи данных.<br />
            Сообщения поступают в любом порядке и то, которое отправлено первым, может быть получено последним.<br />
            Доставка сообщений UDP вовсе не гарантируется, сообщение может потеряться и могут быть получены две копии одного и того же сообщения.<br />
            Такой случай возникает если для отправки сообщений в один адрес использовать два разных маршрута.<br />
            UDP не требует открывать соединение и данные могут быть отправлены сразу же как только они подготовлены.<br />
            UDP не отправляет подтверждающие сообщения, поэтому данные могут быть потеряны.
            
          </p>
          <p>
            HyperText Transfer Protocol (HTTP) — протокол передачи гипертекста: протокол прикладного уровня передачи данных.<br />
            Изначально — в виде гипертекстовых документов в формате HTML (документов, которые содержат ссылки, позволяющие переходить к другим документам).<br />
            В настоящий момент используется для передачи произвольных данных).
          </p>
          <p>Основой HTTP является технология «клиент-сервер», то есть предполагается существование потребителей (клиентов), которые инициируют соединение и посылают запрос, и поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.</p>
          <ul>
            <li>Обычно с помощью протокола HTTP осуществляется обмен данными между вэб-браузером и вэб-сервером.</li>
            <li>Благодаря протоколу HTTP обеспечивается работа всемирной паутины.</li>
            <li>Также HTTP часто используется как протокол передачи информации для других протоколов прикладного уровня, таких как: SOAP, XML-RPC, WebDAV.</li>
            <li>В таком случае говорят, что протокол HTTP используется как транспорт.</li>
            <li>API многих программных продуктов использую HTTP для передачи данных - сами данные при этом могут иметь любой формат: XML или JSON.</li>
            <li>Как правило передача данных по протоколу HTTP осуществляется через TCP/IP-соединения.</li>
            <li>Серверное ПО при этом обычно использует TCP-порт 80, хотя может использовать и любой другой.</li>
          </ul>
          <p>
            HTTP-structure: каждое HTTP-сообщение состоит из трёх частей: Starting line, HTTP Headers, Message body.<br />
            Starting line (Стартовая строка) — определяет тип сообщения.<br />
            <br />
            Стартовая строка запроса: Method - URI - Version.
          </p>
          <ul>
            <li>Method - метод запроса.</li>
            <li>URI - путь к запрашиваемому документу.</li>
            <li>Version - версия протокола, пара разделенных точкой цифр. Например: 1.0</li>
          </ul>
          <p>Стартовая строка ответа: Version - Status Code - Reason Phrase.</p>
          <ul>
            <li>Version - версия протокола, пара разделенных точкой цифр. Например: 1.0</li>
            <li>Код состояния (Status Code) — три цифры.</li>
            <li>Код состояния является частью первой строки ответа сервера.</li>
            <li>Он представляет собой целое число из трёх цифр.</li>
            <li>Первая цифра указывает на класс состояния.</li>
          </ul>
          <p>HTTP-status:</p>
          <ul>
            <li>Informational responses (100 – 199).</li>
            <li>1xx - Информационный: информирование о процессе передачи.</li>
            <li>В HTTP/1.0 — сообщения с такими кодами должны игнорироваться.</li>
            <li>В HTTP/1.1 — клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно.</li>
            <li>Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка.</li>
            <li>Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту.</li>
          </ul>
          <ul>
            <li>Successful responses (200 – 299).</li>
            <li>2xx - Успех: информирование о случаях успешного принятия и обработки запроса клиента.</li>
            <li>В зависимости от статуса, сервер может ещё передать заголовки и тело сообщения.</li>
          </ul>
          <ul>
            <li>Redirection messages (300 – 399).</li>
            <li>3xx - Перенаправление: сообщает клиенту, что для успешного выполнения операции необходимо сделать другой запрос (как правило по другому URI).</li>
            <li>Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям (редирект).</li>
            <li>Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. Допускается использование фрагментов в целевом URI.</li>
          </ul>
          <ul>
            <li>Client error responses (400 – 499).</li>
            <li>4xx - Ошибка клиента: указание ошибок со стороны клиента.</li>
            <li>При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.</li>
          </ul>
          <ul>
            <li>Server error responses (500 – 599).</li>
            <li>5xx - Ошибка сервера: информирование о случаях неудачного выполнения операции по вине сервера.</li>
            <li>Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.</li>
          </ul>
          <p>
            По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента.<br />
            Пояснение (Reason Phrase) — отделённая пробелом поясняющая фраза к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.
          </p>
          <p>
            Тип HTTP-запроса (также называемый HTTP-метод) указывает серверу на то, какое действие мы хотим произвести с ресурсом.<br />
            HTTP-method:
          </p>
          <ul>
            <li>OPTIONS - Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса.</li>
            <li>GET - Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс.</li>
            <li>HEAD - Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело.&lt;br /&gt;Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.</li>
            <li>POST - Применяется для передачи пользовательских данных заданному ресурсу.&lt;br /&gt;Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса.</li>
            <li>PUT - Применяется для загрузки содержимого запроса на указанный в запросе URI.&lt;br /&gt;Если по заданному URI не существует ресурс, то сервер создаёт его и возвращает статус 201 (Created).&lt;br /&gt;Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content).</li>
            <li>PATCH - Аналогично PUT, но применяется только к фрагменту ресурса.</li>
            <li>DELETE - Удаляет указанный ресурс.</li>
            <li>TRACE  - Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.</li>
            <li>CONNECT - Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.</li>
          </ul>
          <p>HTTP Headers:</p>
          <ul>
            <li>Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару параметр-значение.</li>
            <li>Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA (см. RFC 822).</li>
            <li>Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.</li>
          </ul>
          <p>Message body: тело HTTP-сообщения (message-body), если оно присутствует, используется для передачи тела объекта, связанного с запросом или ответом.</p>
          <p>
            HTTPS (Hypertext Transfer Protocol Secure) — защищённая версия HTTP.<br />
            Использует SSL-протокол, который активируется после установки SSL-сертификата и зашифровывает личную информацию, перед тем как передать её владельцу сайта.<br />
            В основе любого метода шифрования лежит ключ.<br />
            Ключ — это способ зашифровать или расшифровать сообщение.<br />
            В работе SSL-сертификата участвуют три ключа: публичный, приватный и сеансовый.
            
          </p>
        </details>
        <details>
          <summary>Api</summary>
          <h2>API (Application programming interface)</h2>
          <ul>
            <li>это набор функций, который группируется разработчиком по функционалу, по заказчику, по смыслу операций и т.д.</li>
            <li>это контракт, который предоставляется программой: Ко мне можно обращаться так, я сделаю это</li>
            <li>это интерфейс или правила связи между клиентом и сервером, предназначенный для упрощения создания программного обеспечения на стороне клиента</li>
            <li>это абстракция, которая описывает функциональность, без описания того, как реализована эта функциональность</li>
          </ul>
          <ul>
            <li><a href="https://www.postman.com/">Postman</a>
            </li>
          </ul>
          <ul>
            <li>RPC  - запрос на выполнение функции на сервере по имени функции с входными параметрами.</li>
            <li>REST - запрос с помощью установленных методов к ресурсу (сущности) на сервере.</li>
            <li>SOAP - формальный корпоративный подход, работает поверх любого протокола связи, даже асинхронно.</li>
          </ul>
          <p>Наиболее распространенные связки</p>
          <ul>
            <li>JSON + REST + HTTP</li>
            <li>XML  + RPC  + SOAP</li>
          </ul>
          <p>Преимущества</p>
          <ul>
            <li>API основанные на RPC прекрасно работают для действий (выполнения процедур или команд).</li>
            <li>API основанные на REST хороши для моделирования сущностей и применения CRUD (create, read, update, delete) для данных.</li>
            <li>REST vs SOAP - Простота VS Стандарты.</li>
            <li>JSON более компактный и не требует тегов закрытия как в XML.</li>
            <li>XML не может использовать массивы, как JSON.</li>
          </ul>
          <h3>RPC (Remote Procedure Call)</h3>
          <p>Удаленный вызов процедур — класс технологий, позволяющих компьютерным программам вызывать функции или процедуры в другом адресном пространстве (как правило, на удалённых компьютерах).</p>
          <h3>REST (Representational State Transfer)</h3>
          <p>
            Передача состояния представления — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети, который имеет набор ограничений, для проектирования по модели клиент-сервер.<br />
            Особенности архитектурного стиля:
          </p>
          <ul>
            <li>Каждая сущность должна иметь уникальный идентификатор – URI.</li>
            <li>Сущности должны быть связаны между собой.</li>
            <li>Для чтения и изменения данных должны использоваться стандартные методы.</li>
            <li>Должна быть поддержка нескольких типов ресурсов.</li>
            <li>Взаимодействие должно осуществляться без состояния.</li>
          </ul>
          <p>
            Каждая единица информации однозначно определяется URL – это значит, что URL по сути является первичным ключом для единицы данных.<br />
            Т.е. например третья книга с книжной полки будет иметь вид /book/3, а 35-я страница в этой книге — /book/3/page/35.
            
          </p>
          <h4>Запросы:  </h4>
          <p>Get: /test/demo_form.php?name1=value1&name2=value2</p>
          <ul>
            <li>параметры передаются в строке браузера</li>
            <li>может быть закеширован</li>
            <li>остаётся в истории браузера</li>
            <li>может быть сохранён в избранном</li>
            <li>нельзя передавать конфиденциальные данные</li>
            <li>максимальная длина в адресной строке 1024 символа</li>
            <li>используется только для получения данных</li>
          </ul>
          <p>POST:</p>
          <pre><code>POST /test/demo_from.php HTTP/1.1
HOST: w3schools.com
name1=value1&name2=value2</code></pre>
          <ul>
            <li>параметры передаются в теле запроса</li>
            <li>не может быть закеширован, сохранён в истории или в избранном</li>
            <li>не имеет ограничения на длину запроса</li>
            <li>можно передавать файлы</li>
          </ul>
          <h4>CRUD в REST:</h4>
          <ul>
            <li>GET /book/ — получить список всех книг</li>
            <li>GET /book/3/ — получить книгу номер 3</li>
            <li>POST /book/ — добавить книгу (данные в теле запроса)</li>
            <li>PUT /book/3 – изменить книгу (данные в теле запроса)</li>
            <li>DELETE /book/3 – удалить книгу</li>
          </ul>
          <p>Или:</p>
          <ul>
            <li>GET /book/ — получить список всех книг</li>
            <li>GET /book/3/ — получить книгу номер 3</li>
            <li>POST /book/ — добавить книгу (данные в теле запроса)</li>
            <li>POST /book/3 — изменить книгу (данные в теле запроса)</li>
            <li>POST /book/3 — удалить книгу (тело запроса пустое)</li>
          </ul>
          <h3>SOAP</h3>
          <p>
            SOAP — протокол обмена структурированными сообщениями в распределённой вычислительной среде.<br />
            Первоначально SOAP предназначался, в основном, для реализации удалённого вызова процедур (RPC).<br />
            Сейчас протокол используется для обмена произвольными сообщениями в формате XML, а не только для вызова процедур.<br />
            SOAP-сообщение представляет собой XML-документ, сообщение состоит из трех основных элементов:  
            
          </p>
          <h4>SOAP Envelope - конверт.</h4>
          <p>
            Является самым «верхним» элементом SOAP сообщения.<br />
            Содержит корневой элемент XML-документа.<br />
            Описывается с помощью элемента Envelope с обязательным пространством имен:<br />
          </p>
          <ul>
            <li><a href="http://www.w3.org/2003/05/soap-envelope">для версии 1.2</a>
            </li>
            <li><a href="http://schemas.xmlsoap.org/soap/">для версии 1.1</a>
            </li>
          </ul>
          <h4>SOAP Header - заголовок.</h4>
          <p>
            Первый прямой дочерний элемент конверта. Необязательный.<br />
            Заголовок кроме атрибутов xmlns может содержать 0 или более стандартных атрибутов:
          </p>
          <ul>
            <li>encodingStyle</li>
            <li>actor (или role для версии 1.2)</li>
            <li>mustUnderstand</li>
            <li>relay</li>
          </ul>
          <h4>SOAP Body - тело:</h4>
          <ul>
            <li>Элемент Body обязательно записывается сразу за элементом Header, если он есть в сообщении, или первым в SOAP-сообщении, если заголовок отсутствует.</li>
            <li>В элемент Body можно вложить произвольные элементы, спецификация никак не определяет их структуру.</li>
            <li>Определен только один стандартный элемент, который может быть в теле сообщения - Fault, содержащий сообщение об ошибке.</li>
            <li>Если SOAP-сервер, обрабатывая поступившее SOAP-сообщение, обнаружит ошибку, то он прекратит обработку и отправит клиенту SOAP-сообщение, содержащее один элемент Fault с сообщением об ошибке.</li>
          </ul>
          <h3>Форматы JSON / XML / WSDL</h3>
          <h4>WSDL (Web Services Definition Language) - Язык описания веб-сервисов, основан на языке XML.</h4>
          <p>Каждый документ WSDL можно разбить на следующие логические части:</p>
          <ul>
            <li>types: определение типов данных   — определение вида отправляемых и получаемых сервисом XML сообщений</li>
            <li>message: элементы данных          — сообщения, используемые web-сервисом</li>
            <li>portType: абстрактные операции    — список операций, которые могут быть выполнены с сообщениями</li>
            <li>binding: связывание сервисов      — способ, которым сообщение будет доставлено</li>
          </ul>
          <h4>XML (Extensible Markup Language]* - Расширяемый Язык Разметки.  </h4>
          <ul>
            <li>Корневой элемент и пространство имен.</li>
            <li>Разработчик сам определяет используемые теги.</li>
            <li>Не может содержать массивы.</li>
            <li>Основная цель XML - это передача данных между разными системами.</li>
            <li>Документ должен соответствовать семантическим правилам языка (схеме XML, WSDL или DTD *[Document Type Definition]*.</li>
            <li>XML обычно используют для описания чего-то.</li>
          </ul>
          <p>Сходство с HTML:</p>
          <ul>
            <li>В XML существуют открывающие, закрывающие и пустые тэги.</li>
            <li>Теги в документе могут быть вложены друг в друга.</li>
            <li>Теги начала и конца элемента являются основными используемыми в XML разметками.</li>
            <li>Тэги могут иметь любое количество атрибутов.</li>
            <li>Документы XML могут содержать ссылки на другие объекты.</li>
          </ul>
          <p>В отличии от HTML большое внимание уделяется контролю документа.</p>
          <ul>
            <li>Синтаксическая проверка.</li>
            <li>Проверка валидности документа.</li>
          </ul>
          <p>
            Существуют методы отображения XML данных, но если вы не определили способ визуализации XML документа, то в браузере он отобразится построчно, как обычный текстовый файл.<br />
            Один из методов отображения XML - указать CSS (чтобы использовать в документе нужно прописать инструкцию xml-stylesheet).
          </p>
          <pre><code>xml-stylesheet type="text/css" href="stylesheet.css"</code></pre>
          <p>Есть также много других мощных методов отображения XML, например, XSLT (Extensible Stylesheet Language Transformations), который используется для преобразование XML в другие языки такие, как HTML.</p>
          <pre><code>xml-stylesheet type="text/xsl" href="transform.xsl"</code></pre>
          <h4>JSON (JavaScript Object Note) - Описание объектов JavaScript.</h4>
          <p>
            Простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером.<br />
            Произошёл от JavaScript, но используется с любым языком программирования.
          </p>
          <ul>
            <li>Не имеет тегов.</li>
            <li>Может содержать в значениях массивы и объекты.</li>
            <li>Ключи в JSON находятся с левой стороны от двоеточия - это любая строка, например 'key'.</li>
            <li>В каждом объекте ключи уникальные.</li>
            <li>Пробелы допускаются, но лучше их заменять знаком подчеркивания.</li>
            <li>Значения находятся с правой стороны от двоеточия.</li>
            <li>Типы значений: строка, число, объект, массив, булево, null</li>
          </ul>
        </details>
        <details>
          <summary>Apache</summary>
        </details>
        <details>
          <summary>Nginx</summary>
        </details>
        <details>
          <summary>PHP</summary>
          <h2>PHP</h2>
          <ul>
            <li>х64 Nоп Thread Safe - 64-битный СGI-вариант дистрибутива;</li>
            <li>х64 Thread Safe - 64-битный вариант для установки в качестве модуля вебсервера - Apache;</li>
          </ul>
          <p>Установка в Виндовс: Распаковать архив в необходимую папку, например C:\php. Добавить в PATH.</p>
          <pre><code>// Установка Линукс
sudo apt install -y php

// Интерактивный режим
php -a

// Локальный сервер:
php -S localhost:4000
</code></pre>
          <p>Указать локальному серверу хост в Виндовс: C:\Windows\system32\drivers\etc\hosts, Линукс: /etc/hosts</p>
          <p>Указать локальному серверу на файл с настройками php вручную:</p>
          <pre><code>// Windows
php -S 127.0.0.1:4000 -с C:\php\php.ini

// Linux
php -s 127.0.0.1:4000 -с /etc/php.ini
</code></pre>
          <p>в HTML разметке</p>
          <pre><code>< !DOCTYPE html>
< html lang="ru">
  < head>
    < title>Простейший РНР-скрипт< /title>
    < meta charset='utf-8' />
  < /head>
  < body>
    < ?php echo "Hello, world!"; ?>

    // либо
    < ?= "Hello, world!"; ?>
  < /body>
< /html>
</code></pre>
          <p>Синтаксис:</p>
          <pre><code>< ?php
echo "Hello, world!";

{
  echo "Hello, world!";
  echo 5 + 5;
  echo 5 - 2;
}
?>

< ?php
if (rand(0, 1)) {
  ?>
  < div style='color:green'><?= "Истина"; ?>< /div>
  < ?php
  } else {
  ?>
  < div style='color:red'><?= "Ложь" ?>< /div>
}
</code></pre>
          <table>
            <caption>Комментарий</caption>
            <tbody>
              <tr>
                <td>//</td>
                <td>однострочный комментарий</td>
              </tr>
              <tr>
                <td>#</td>
                <td>однострочный комментарий</td>
              </tr>
              <tr>
                <td>/* */</td>
                <td>многострочный комментарий</td>
              </tr>
              <tr>
                <td>\</td>
                <td>экранировать символ</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Кавычки</caption>
            <tbody>
              <tr>
                <td>"..."</td>
                <td>вместо переменных подставляются их значения - интерполяция</td>
              </tr>
              <tr>
                <td>'...'</td>
                <td>переменные отображаются как есть, их значения не подставляются</td>
              </tr>
              <tr>
                <td>`...`</td>
                <td>системная команда, возвращает результат выполнения терминальной команды системы: echo `ls -l`;</td>
              </tr>
            </tbody>
          </table>
          <table>
            <tbody>
              <tr>
                <td>$str = <<< METKA ... METKA;</td>
                <td>Между метками любой текст.</td>
              </tr>
              <tr>
                <td>$str = <<< `METKA`... METKA;</td>
                <td>Переменные не интерполируются.</td>
              </tr>
              <tr>
                <td>$str[0];</td>
                <td>Получить символ строки по индексу</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// масиив: ключ=>значение
$arr = [
  0         => "element",
  "surname" => "Gates",
  "name"    => "Bill"
]

/**
* mixed $var       - параметр $var типа mixed
* [mixed ...$vars] - необязательный параметр
* ...              - бесконечное количество аргументов
* : void           - ничего не возвращает
*/
unset(mixed $var, [mixed ...$vars]): void

// жесткая ссылка &, $Ь и $а имеют одно значение на двоих, ссылаются на одну и ту же область памяти
$Ь = &$а;
$right "красная";
$color = "right";

// символическая ссылка $$ обращается к значению переменной, имя которой содержит, выводит значение переменной $right ("красная")
echo $$color;

// если file.php отсутствует, то скрипт продолжит работу с предупреждением
include 'file.php'

// если file.php отсутствует, то скрипт остановится
require 'file.php'

// если file.php отсутствует, то скрипт продолжит работу с предупреждением, включает файл один раз
include_once 'file.php'

// если file.php отсутствует, то скрипт остановится, включает файл один раз
require_once 'file.php'
</code></pre>
          <p>Степень числа 10 через букву е: 346.1256 = 3.461256*10 в квадрате или 3.461256е+2, 0.00012 = 1.2е-4.  </p>
          <p>Ключевые слова class и function создают область видимости в своём блоке {}.  </p>
          <p>Элементы языка:</p>
          <ul>
            <li>ключевые слова</li>
            <li>переменные</li>
            <li>скалярные величины: скалярный - определяется полностью своим значением и не имеет направления как вектор или мнимой части как комплекс</li>
            <li>константы</li>
            <li>операторы</li>
            <li>функции</li>
            <li>классы</li>
            <li>объекты</li>
            <li>пространства имён</li>
            <li>трейты</li>
            <li>перечисления</li>
            <li>исключения</li>
          </ul>
          <p>Переменные, Константы и Типы</p>
          <ul>
            <li>Адрес ячейки оперативной памяти, где хранится значение, содержится в таблице интерпретатора и имеет имя - имя переменной.</li>
            <li>Имя переменной используется в скрипте для обращения к значению переменной в оперативной памяти.</li>
            <li>Значение переменной можно менять, т.е. присваивать переменной другое значение, т.е. напротив имени переменной в таблице интерпретатора адрес нового значения в оперативной памяти.</li>
          </ul>
          <pre><code>< ?php
$price = 3000;
$price_vip = $price + 500;

// 3900200 - допускается разделение разрядов _ для читабельности
echo 2_000_000 + 1_920_000;

// 85 - двоичное число 0b010101
echo 0b010101;

// 493 - восьмеричное число
echo 0o755;

// 16763904 - шестнадцатеричное число
echo 0xffcc00;

// Служебные переменные:
$this - указывает на текущий объект</code></pre>
          <ul>
            <li>Значения чисел для 32-битной операционной системы от -2 147 483 648 до 2 147 483 647.</li>
            <li>Значения чисел для 64-битной операционной системы от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807.</li>
            <li>Если значение превышает диапазон integer, то автоматически тип становится float.</li>
            <li>Директива precision в php.ini указывает количество знаков после точки.</li>
            <li>Дескрипторы применяются при работе с файлами, базами данных, динамическими изображениями и предоставляют к ним доступ при помощи библиотечных функций.</li>
            <li>Функции обратного вызова - функции, которые принимаются как аргументы другими функциями.</li>
          </ul>
          <p>Типы</p>
          <ul>
            <li>Тип переменной - это тип значения: число, строка, массив, объект и ресурс.</li>
            <li>По типу значения интерпретатор определяет какие операторы и функции можно применять к значению.</li>
            <li>Встроенные базовые типы менять нельзя - можно создавать свои классы, которые похожи на типы.</li>
            <li>PHP - слабо типизированный язык, т.е. тип не определяется при объявлении переменной и может изменяться в зависимости от присваиваемого значения.</li>
          </ul>
          <table>
            <thead>
              <tr>
                <th>Тип</th>
                <th>Описание</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td colspan="2">Встроенные типы</td>
                <td></td>
              </tr>
              <tr>
                <td>int</td>
                <td>integer - целое число</td>
              </tr>
              <tr>
                <td>bool</td>
                <td>boolean - логический тип: true (истина) и false (ложь)</td>
              </tr>
              <tr>
                <td>float</td>
                <td>вещественное число, значения от ±2.23х10-эов до ±1.79х1О30</td>
              </tr>
              <tr>
                <td>string</td>
                <td>строковый тип, может хранить строку</td>
              </tr>
              <tr>
                <td>array</td>
                <td>массив - объединение нескольких переменных под одним именем</td>
              </tr>
              <tr>
                <td>object</td>
                <td>объект - объединяет разнотипные переменные и методы их обработки</td>
              </tr>
              <tr>
                <td>resource</td>
                <td>дескриптор, позволяющий оперировать ресурсом</td>
              </tr>
              <tr>
                <td>Relative class</td>
                <td>self, parent, and static - относительные типы классов</td>
              </tr>
              <tr>
                <td>Singleton</td>
                <td>false, true - одноэлементные типы</td>
              </tr>
              <tr>
                <td>null</td>
                <td>тип, который сигнализирует о том, что переменная не была инициализирована</td>
              </tr>
              <tr>
                <td colspan="2">Пользовательские типы</td>
                <td></td>
              </tr>
              <tr>
                <td>Interfaces</td>
                <td></td>
              </tr>
              <tr>
                <td>Classes</td>
                <td></td>
              </tr>
              <tr>
                <td>Enumerations</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="2">Псевдонимы типов</td>
                <td></td>
              </tr>
              <tr>
                <td>never</td>
                <td>возвращается при досрочном прерывании программы функцией exit() или при исключительной ситуации</td>
              </tr>
              <tr>
                <td>void</td>
                <td>отсутствие типа - используется в функциях для обозначения, что возвращаемое значение не возвращает никакого значения</td>
              </tr>
              <tr>
                <td>mixed</td>
                <td>объединение типов object,resource,array,string,float,int,bool,null, т.е. значение может иметь любой тип</td>
              </tr>
              <tr>
                <td>iterable</td>
                <td>объединение типов Traversable,array, т.е. массив или объект</td>
              </tr>
              <tr>
                <td>callable</td>
                <td>переменные этого типа содержат ссылки на функции обратного вызова</td>
              </tr>
            </tbody>
          </table>
          <p>
            Пересечение типов - значения, которые удовлетворяют не одному, а одновременно нескольким классам-типам: T&U&V.</br>
            Объединение типов - значения или одного или другого типа: T|U|V.</br>
            Явное приведение к типу:
          </p>
          <pre><code>$var = (int) $a;

// либо
$var = settype($a, 'int')
</code></pre>
          <p>Копирование значения при присваивании:</p>
          <pre><code>$a = 42;

// $a = 42; $b = 42; - у каждой переменной своё значение
$b = $a;

// $a = 24; $b = 42;
$a = 24;

// объявил класс
class MyClass {}

// создал объект
$first = new MzClass();

// скопировал из $first адрес объекта в $second, один объект на две переменные
$second = $first;</code></pre>
          <table>
            <caption>Константы: значение присваивается один раз, нет символа $ и не может быть равно null.  </caption>
            <tbody>
              <tr>
                <td>PHP_INT_МAX</td>
                <td>максимальное значение целого числа</td>
              </tr>
              <tr>
                <td>PHP_INT_SIZE</td>
                <td>количество байтов, отведенное под целое число</td>
              </tr>
              <tr>
                <td>__DIR__</td>
                <td>директория корня проекта</td>
              </tr>
              <tr>
                <td>__FILE__</td>
                <td>имя файла, в котором расположен запущенный в настоящий момент код</td>
              </tr>
              <tr>
                <td>__LINE__</td>
                <td>номер строки, которую обрабатывает в текущий момент интерпретатор</td>
              </tr>
              <tr>
                <td>__FUNCTION__</td>
                <td>имя текущей функции</td>
              </tr>
              <tr>
                <td>__CLASS__</td>
                <td>имя текущего класса</td>
              </tr>
              <tr>
                <td>PHP_VERSION</td>
                <td>версия интерпретатора PHP</td>
              </tr>
              <tr>
                <td>PHP_OS</td>
                <td>имя операционной системы, под управлением которой работает PHP</td>
              </tr>
              <tr>
                <td>PHP_EOL</td>
                <td>символ конца строки текущей платформы: UNIX - \n, Windows - \r\n</td>
              </tr>
              <tr>
                <td>true</td>
                <td>истина</td>
              </tr>
              <tr>
                <td>false</td>
                <td>ложь</td>
              </tr>
              <tr>
                <td>null</td>
                <td>null</td>
              </tr>
              <tr>
                <td>get_defined_constants (bool $categorize = false): array</td>
                <td>получить все доступные в данный момент константы</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// определить константу: имя, значение - типы значений: bool, int, float, string, array
define('PI', 3.14);
define('VALUE', 'Hello world!');

// 3.14
echo PI;

// Hello world!
echo VALUE;

// проверить существование константы: true|false
defined('VALUE')

define('START_TIME', new DateTime());

// 23-04-2022 13:42:56
echo START_TIME->format('d-m-Y H:i:s');

// Формируем случайное число от 1 до 10
$index = rand(l, 10);

// Формируем имя константы
$name = "VALUE{$index}";

// Определяем константу с динамическим именем
define($name, 1);

// Получаем значение динамической константы
echo constant($name);
</code></pre>
          <p>ООП</p>
          <ul>
            <li>У переменной тип - у объекта класс.</li>
            <li>Переменные - свойства, функции - методы.</li>
            <li>Класс - self, объект - $this.</li>
            <li>$obj-&gt;method; - вызывать метод объекта, если метод вернёт null, то будет ошибка.</li>
            <li>$obj?-&gt;method; - безопасно вызывать метод объекта, если метод вернёт null, то ошибки не будет.</li>
          </ul>
          <p>Объекты: один класс - один файл, класс и объект в разных файлах</p>
          <pre><code>$date = new DateTime();

// 14-04-2022 16:26:34
echo $date->format('d-m-Y H:i:s');

// object
echo gettype($date);

// DateTime
echo get_class($date);

// DateTime
echo $date::class;
</code></pre>
          <p>свойства класса public - везде, protected - внутри и наследники, private - только внутри</p>
          <pre><code>class MyClass {

  // либо int, либо float
  public int|float $x;

  // либо int, либо null. можно использовать ? с любым типом кроме callable
  public ?int $x;

  static - создаёт переменную в классе
  public static $static_var = 100;

  const - только для класса, создаёт константу, по умолчанию public, можно указать protected или private
  const NAME = 'cls';
}

// Использование
$obj = new MyClass;

// для использования нужно инициализировать
$obj->x = 2;

// 2
echo $obj->x;

// Использование
// 100
echo MyClass::$static_var;

// обращение к значению константы
echo MyClass::NAME

// проверка существует ли константа NAME в классе MyClass: true|false
defined(('MyClass::NAME'));
</code></pre>
          <p>Значения</p>
          <pre><code>class Greeting {

  // $hello - строка только для чтения снаружи
  public readonly string $hello;

  // присваиваю значение
  public function setter() {
    $this->hello = 'PHP';
  }
}

// Использование
$object = new Greeting;

// вызвать setter() для инициализации свойства hello
echo $object->setter();

// PHP
echo $object->hello;
</code></pre>
          <p>Конструктор инициализирует свойство при создании объекта</p>
          <pre><code>class Greeting
{
  // $hello - строка только для чтения снаружи
  public readonly string $hello;

  // присваиваю значение при создании объекта
  public function __construct() {
    $this->hello = 'PHP';
  }
}

// Использование
$object = new Greeting;

// PHP
echo $object->hello;
</code></pre>
          <p>Клонирование</p>
          <pre><code>class Point
{
  public ?int $x;
}

// Использование
$first = new Point;
$first->x = 1;

$second = $first;

// $first и $second ссылаются на один и тот же объект, изменил значение х
$second->x = 2;

// создал отдельный объект - клон объекта $first
$third = clone $first;

// изменил значение х в клоне
$third->x = 3;

// first x: 2, third x: 3
echo "first x: {$first->x}, third x: {$third->x}"

// greeting.php
class Greeting
{
  public function say(string $who): string
  {
    return "Hello, $who!";
  }
}

// greeting_say.php
require_once 'greeting.php';

// инициализация свойств
$object = new Greeting;

// Hello, PHP!
echo $object->say('PHP');

class Point
{
  private $x;
  private $y;

  public function __construct(int $x = 0, int $y = 0)
  {
    $this->x = $x;
    $this->y = $y;
  }
}

// или
class Point
{
  public function __construct(private int $x = 0, private int $y = 0) {}
}

// использование
$point = new Point(x: 3, y: 5);
</code></pre>
          <p>Статический метод - метод класса, который можно вызвать без создания объекта</p>
          <pre><code>class Greeting
{
  public static function say(string $who) {
    return "Hello, $who!";
  }
}

// Hello, PHP!
echo Greeting::say('PHP');
</code></pre>
          <p>Методы</p>
          <pre><code>// существует ли метод, вернёт массив со всеми методами объекта
get_class_methods(object|string $object_or_class): array

// существует ли свойство, вернёт массив со всеми свойствами объекта
get_object_vars(object $object): array

// существует ли метод, вернёт true|false
method_exists(object|string $object_or_class, string $method): bool

// существует ли свойство, вернёт true|false
property_exists(object|string $object_or_class, string $property): bool
</code></pre>
          <table>
            <caption>Специальные встроенные методы, выполняются автоматически</caption>
            <tbody>
              <tr>
                <td>__construct()</td>
                <td>конструктор класса, при создании объекта - во время вызова new</td>
              </tr>
              <tr>
                <td>__destruct()</td>
                <td>деструктор класса, при уничтожении объекта</td>
              </tr>
              <tr>
                <td>__autoload()</td>
                <td>загружает класс при создании его объекта</td>
              </tr>
              <tr>
                <td>__set()</td>
                <td>аксессор, при установке свойства объекта</td>
              </tr>
              <tr>
                <td>__get()</td>
                <td>аксессор, при обращении к свойству объекта</td>
              </tr>
              <tr>
                <td>__isset()</td>
                <td>при проверки свойства с помощью isset()</td>
              </tr>
              <tr>
                <td>__unset()</td>
                <td>при удалении свойства с помощью unset()</td>
              </tr>
              <tr>
                <td>__call()</td>
                <td>при попытке вызвать несуществующий метод объекта, либо для перехвата вызова метода (посредник)</td>
              </tr>
              <tr>
                <td>__toString()</td>
                <td>при интерполяции объекта в строку</td>
              </tr>
              <tr>
                <td>__set_state()</td>
                <td>экспорт объекта</td>
              </tr>
              <tr>
                <td>__clone()</td>
                <td>клонирование объекта</td>
              </tr>
              <tr>
                <td>__sleep()</td>
                <td>управлять поведением объекта при его сериализации с помощью serialize()</td>
              </tr>
              <tr>
                <td>__wakeup()</td>
                <td>управлять поведением объекта при его восстановления из сериализованного состояния с помощью unserialize()</td>
              </tr>
            </tbody>
          </table>
          <pre><code>class MinMax
{
  // перехватывает вызов любого метода
  public function __call(string $method, array $arr)
  {
    // выбираю какой метод вызвать
    switch($method) {
      case 'min':
        // min - встроенная функция PHP, доступ извне закрыт, но к __call() доступ извне есть
        return min($arr);
      case 'max':
        // max - встроенная функция PHP, доступ извне закрыт, но к __call() доступ извне есть
        return max($arr);
      default:
        // если такого названия метода нет, то null. break не нужен, т.к. return выйдет из __call()
        return null
    }
  }
}

// использование
$obj = new MinMax();
echo $obj->min(43, 18, 5, 61, 23);   // 5
echo $obj->max(43, 18, 5, 61, 23);   // 61

// тоже самое для класса
class MinMax
{
  public static function __callStatic(string $method, array $arr)
  {
    switch($method) {
      case 'min':
        return min($arr);
      case 'max':
        return max($arr);
      default:
        return null
    }
  }
}

// использование
$obj = new MinMax();
echo MinMax::min(43, 18, 5, 61, 23);   // 5
echo MinMax::max(43, 18, 5, 61, 23);   // 61

// вызов объекта в строке возможен только если его класс содержит __toString()
class Point
{
  private int $x;
  private int $y;

  public function __construct(int $x = 0, int $y = 0) {
    $this x = $x;
    $this y = $y;
  }

  public function __toString() {
    return "({$this->x}, {$this->y})";
  }
}

// использование
$point = new Point(5, 12);

// point = (5, 12)
echo "point = {$point}";


// передать метод в качестве колбэк функции
class Algorithm
{
  public function distance(array $point): float
  {
    return sqrt($point[0] ** 2 + $point[1] ** 2);
  }
}

$points = ([3, 5], [5, 3], [5, 5], [5, 0]);

// создать объект класса Algorithm и применить к элементам массива $points метод distance
$objects = array_map([new Algorithm, 'distance'], $points);

// тоже самое, но без создания объекта - сделать метод статическим
class Algorithm
{
  public static function distance(array $point): float
  {
    return sqrt($point[0] ** 2 + $point[1] ** 2);
  }
}

$points = ([3, 5], [5, 3], [5, 5], [5, 0]);

// применить метод distance класса Algorithm к элементам массива $points
$objects = array_map(['Algorithm', 'distance'], $points);
</code></pre>
          <p>Операторы PHP: любое выражение имеет значение, а значит и тип.  </p>
          <table>
            <tbody>
              <tr>
                <td>2 + 3</td>
                <td>оператор: +, операнды 2 и 3</td>
              </tr>
              <tr>
                <td>.</td>
                <td>конкатенация: соединение строк, число приводится к строке</td>
              </tr>
              <tr>
                <td>,</td>
                <td>запятая для списка значений</td>
              </tr>
              <tr>
                <td>;</td>
                <td>окончание выражения</td>
              </tr>
              <tr>
                <td>\=</td>
                <td>равно, оператор присваивания</td>
              </tr>
              <tr>
                <td>.=</td>
                <td>сокращает $str = $str . $newstring до $str .= $newstring, аналогично +=, *=, -=, /=, %=, **=</td>
              </tr>
              <tr>
                <td>+</td>
                <td>сложение, строка приводится к числу</td>
              </tr>
              <tr>
                <td>*</td>
                <td>умножение</td>
              </tr>
              <tr>
                <td>-</td>
                <td>вычитание</td>
              </tr>
              <tr>
                <td>/</td>
                <td>деление</td>
              </tr>
              <tr>
                <td>%</td>
                <td>деление по модулю: возвращает остаток от деления</td>
              </tr>
              <tr>
                <td>**</td>
                <td>возведение в степень</td>
              </tr>
              <tr>
                <td>++</td>
                <td>инкремент: увеличить на единицу, применяется только к переменным</td>
              </tr>
              <tr>
                <td>++=</td>
                <td>префиксный инкремент сначала увеличивает значение, а потом присваивает, постфиксный =++ наоборот</td>
              </tr>
              <tr>
                <td>--</td>
                <td>декремент: уменьшить на единицу, применяется только к переменным</td>
              </tr>
              <tr>
                <td>--=</td>
                <td>префиксный декремент сначала уменьшает значение, а потом присваивает, постфиксный =-- наоборот</td>
              </tr>
              <tr>
                <td>()</td>
                <td>группировка аргументов, приоритет операции</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Побитовые операторы применяются к строкам если оба операнда строки, иначе приводятся к числу</caption>
            <tbody>
              <tr>
                <td>$a & $b</td>
                <td>вернёт биты, которые есть и в $a и в $b</td>
              </tr>
              <tr>
                <td>$a | $b</td>
                <td>вернёт биты $a и $b</td>
              </tr>
              <tr>
                <td>$a ^ $b</td>
                <td>вернёт биты, которые есть либо в $a либо в $b, но не в обоих одновременно</td>
              </tr>
              <tr>
                <td>~ $a</td>
                <td>вернёт биты, которых нет в $a</td>
              </tr>
              <tr>
                <td>$a << $b</td>
                <td>на $b позиций сдвиг влево: умножить на два, знак операнда не сохраняется</td>
              </tr>
              <tr>
                <td>$a >> $b</td>
                <td>на $b позиций сдвиг вправо: разделить на два, знак операнда сохраняется</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Операторы сравнения: true|false</caption>
            <tbody>
              <tr>
                <td><</td>
                <td>меньше</td>
              </tr>
              <tr>
                <td><=</td>
                <td>меньше либо равно</td>
              </tr>
              <tr>
                <td>></td>
                <td>больше</td>
              </tr>
              <tr>
                <td>>=</td>
                <td>больше либо равно</td>
              </tr>
              <tr>
                <td>\==</td>
                <td>равенство: значения равны</td>
              </tr>
              <tr>
                <td>!=</td>
                <td>неравенства: значения не равны</td>
              </tr>
              <tr>
                <td><></td>
                <td>неравенства: значения не равны</td>
              </tr>
              <tr>
                <td>\===</td>
                <td>эквивалентности: значения и типы равны</td>
              </tr>
              <tr>
                <td>!==</td>
                <td>неэквивалентности: либо значение, либо типы не равны</td>
              </tr>
              <tr>
                <td>$x <=> $y</td>
                <td>в случае равенства вернёт 0, если $x больше $y вернёт положительное число, если $y больше $x, то вернёт отрицательное число</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Логические операторы</caption>
            <tbody>
              <tr>
                <td>&&</td>
                <td>логическое И: возвращает true если оба операнда true</td>
              </tr>
              <tr>
                <td>and</td>
                <td>логическое И: приоритет меньше чем у &&</td>
              </tr>
              <tr>
                <td>||</td>
                <td>логическое ИЛИ: возвращает true если хоть один из операндов true, если оба false, то вернёт false</td>
              </tr>
              <tr>
                <td>or</td>
                <td>логическое ИЛИ: приоритет меньше чем у ||</td>
              </tr>
              <tr>
                <td>!</td>
                <td>логическое НЕ: меняет true|false на противоположное</td>
              </tr>
            </tbody>
          </table>
          <p>Суперглобальные и другие массивы</p>
          <ul>
            <li>переменная доступная для всех контекстов - глобальная переменная global $var;</li>
            <li>глобальный массив $GLOBALS позволяет получить доступ к переменным в любом месте программы - $GLOBALS['var']</li>
            <li>global $var; это тоже самое что $var = &amp;$GLOBALS['var'], т.е. ссылка на элемент глобального массива</li>
          </ul>
          <p>Массивы</p>
          <ul>
            <li>Если индексы числа, то массив индексный.</li>
            <li>Если индексы строки, то массив ассоциативный.</li>
            <li>Если индексы и числа и строки, то массив смешанный.</li>
            <li>Многомерный массив - массив, элемент которого другой массив.</li>
          </ul>
          <pre><code>$arr = array('Hello', 'world', '!');
echo $arr[0]; // Hello
echo $arr[1]; // world
echo $arr[2]; // !

// Вывести весь массив
echo '< pre>';
print_r($arr);
echo '< pre>';

// или
$arr = [];
$arr = ['Hello', 'world', '!'];

// Задать индекс вручную
// индекс 'Hello' - 10, 'world' - 11, а '!' - 12
$arr = [10 => 'Hello', 'world', '!'];

// индекс 'Hello' - 10, 'world' - 9, а '!' - 11
$arr = [10 => 'Hello', 9 => 'world', '!'];

$arr = array_fill(первый индекс, количество элементов, значение элемента);
// создаст массив с шестью элементами 'Hello world !', с индексами начиная с 5
$arr = array_fill(5, 6, 'Hello world !');

$arr = range(начало интервала, конец интервала, шаг);
// создаст массив [0, 0.2, 0.4, 0.6, 0.8, 1]
$arr = range(0, 1, 0.2);

// ассоциативный массив
$arr = ['one' => '1', 'two' => '2'];

// многомерный массив
$arr = [
  'one' => ['first', 'second', 'third'],
  'two' => ['red', 'green', 'blue']
]

// Интерполяция массива в строку
echo "Событие произошло $arr[O] дней назад";

// ключ без кавычек
echo "Событие произошло $arr[one] дней назад";

// с кавычками
echo "Событие произошло {$arr['one']} дней назад";
echo "Событие произошло " . $arr[O][О] . " дней назад";
echo "Событие произошло {$arr[O][О]} дней назад";
</code></pre>
          <p>Конструкция list() - преобразует элементы массива в обычные переменные, работает только с числовыми массивами, нумерация индексов которых начинается с нуля.</p>
          <pre><code>$arr = [1, 2, 3];
list($one, $two, $three) = $arr;

echo Sone;    // 1
echo $two;    // 2
echo $three;  // З

// либо
[$one, $two, $three] = $arr;
</code></pre>
          <table>
            <caption>Сечение массива</caption>
            <tbody>
              <tr>
                <td colspan="2">выделяет часть массива в новый массив</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="2">array_slice(): array</td>
                <td></td>
              </tr>
              <tr>
                <td>array $array,</td>
                <td>исходный массив</td>
              </tr>
              <tr>
                <td>int $offset,</td>
                <td>индекс элемента - начало сечения</td>
              </tr>
              <tr>
                <td>?int $length = null,</td>
                <td>количество элементов нового массива, если не задан, то все до конца</td>
              </tr>
              <tr>
                <td>bool $preserve_keys = false</td>
                <td>true - сохранить ключи, false - индексировать новый массив с 0</td>
              </tr>
              <tr>
                <td colspan="2">$arr = ['a', 'b', 'c', 'd', 'e'];</td>
                <td></td>
              </tr>
              <tr>
                <td>array_slice($arr, 2);</td>
                <td>вернёт ['c', 'd', 'e']</td>
              </tr>
              <tr>
                <td>array_slice($arr, 2, -1);</td>
                <td>вернёт ['c', 'd']</td>
              </tr>
              <tr>
                <td>array_slice($arr, -2, 1);</td>
                <td>вернёт ['d']</td>
              </tr>
              <tr>
                <td>array_slice($arr, 0, 3);</td>
                <td>вернёт ['a', 'b', 'c']</td>
              </tr>
              <tr>
                <td colspan="2">заменяет часть массива</td>
                <td></td>
              </tr>
              <tr>
                <td colspan="2">array_splice(): array</td>
                <td></td>
              </tr>
              <tr>
                <td>array $array,</td>
                <td>исходный массив</td>
              </tr>
              <tr>
                <td>int $offset,</td>
                <td>индекс элемента - начало сечения</td>
              </tr>
              <tr>
                <td>?int $length = null,</td>
                <td>количество элементов нового массива, если не задан, то все до конца</td>
              </tr>
              <tr>
                <td>mixed $replacement = []</td>
                <td>заменяет часть элементов тем, что в массиве $replacement, если пустой [], то элементы удаляются</td>
              </tr>
              <tr>
                <td colspan="2">$arr = ['a', 'b', 'c', 'd'];</td>
                <td></td>
              </tr>
              <tr>
                <td>array_splice($arr, 2);</td>
                <td>вернёт ['a', 'b'] - остальные удалены, начиная с индекса 2</td>
              </tr>
              <tr>
                <td>array_splice($arr, 1, -1);</td>
                <td>вернёт ['a', 'd'] - удалено всё, начиная с индекса 1 и без последнего индекса.</td>
              </tr>
              <tr>
                <td>array_splice($arr, 1, count($arr), 'e');</td>
                <td>вернёт ['a', 'e'] - заменил всё, начиная с индекса 1 на 'e'</td>
              </tr>
            </tbody>
          </table>
          <p>Слияние массивов</p>
          <pre><code>// оператор +. При одинаковых индексах в результат попадёт элемент из левого массива.
$fst = [1 => 'one', 2 => 'two'];
$snd = [3 => 'three', 4 => 'four'];

// [1 => 'one', 2 => 'two', 3 => 'three', 4 => 'four']
$sum = $fst + $snd;

// Объединить все элементы массивов
$fst = ['one', 'two'];
$snd = ['three', 'four', 'five'];
$sum = array_marge($fst, $snd); 
</code></pre>
          <p>Сравнение массивов</p>
          <ul>
            <li>Массивы равны == если количество элементов, ключи и значения совпадают.</li>
            <li>Массивы эквивалентны === если количество элементов, ключи, значения и типы значений совпадают.</li>
          </ul>
          <pre><code>// массивы равны, но не эквивалентны
$fst = [1 => 1, 2 => 2];
$snd = [1 => 1, 2 => '2'];

if ($fst == $snd)
  echo 'массивы равны< Ьr/>';
} else {
  echo 'массивы не равны< Ьr/>';
}

if ($fst === $snd) {
  echo 'массивы эквивалентны< Ьr/>';
} else {
  echo 'массивы не эквивалентны< Ьr/>';
}

// массивы равны и эквивалентны
$fst = [1 => 1, 2 => 2];
$snd = [1 => 1, '2' => 2];

// исключительное пересечение массивов, т.е. их отличия, вернёт массив значений, которые есть только в первом массиве.
array_diff(array $arr, array ...$arrays): array
$result = array_diff($fst, $snd);

// включительное пересечение массивов, т.е. общее, вернёт массив значений из первого массива, которые есть в остальных массивах.
array_intersect(array $arr, array ...$arrays): array
$result = array_intersect($fst, $snd);
</code></pre>
          <table>
            <caption>Поиск в массиве</caption>
            <tbody>
              <tr>
                <td colspan="2">проверить существование значения в массиве</td>
                <td></td>
              </tr>
              <tr>
                <td>in_array(): bool</td>
                <td>вернёт true если найдёт, или false если нет</td>
              </tr>
              <tr>
                <td>mixed $val,</td>
                <td>искомое значение</td>
              </tr>
              <tr>
                <td>array $arr,</td>
                <td>массив, в котором ищем</td>
              </tr>
              <tr>
                <td>bool $strict = false</td>
                <td>true - эквивалентное сравнение ===, false - равенство ==</td>
              </tr>
              <tr>
                <td>array_key_exists (string|int $key, array $array): bool</td>
                <td>проверить наличие ключа в массиве</td>
              </tr>
              <tr>
                <td colspan="2">найти ключ массива по значению</td>
                <td></td>
              </tr>
              <tr>
                <td>array_search (): int|string|false</td>
                <td>вернёт либо ключ, либо false</td>
              </tr>
              <tr>
                <td>mixed $val,</td>
                <td>значение, ключ которого ищем</td>
              </tr>
              <tr>
                <td>array $arr,</td>
                <td>массив, в котором ищем</td>
              </tr>
              <tr>
                <td>bool $strict = false</td>
                <td>true - эквивалентное сравнение ===, false - равенство ==</td>
              </tr>
            </tbody>
          </table>
          <p>Математические операции массивов</p>
          <pre><code>$arr = [
  [1, 2, 3, 4],
  [5, 6, 7, 8]
];
</code></pre>
          <table>
            <caption>количество элементов в массиве</caption>
            <tbody>
              <tr>
                <td colspan="2">count(): int</td>
                <td></td>
              </tr>
              <tr>
                <td>Countable|array $arr,</td>
                <td>массив, элементы которого считаем</td>
              </tr>
              <tr>
                <td>int $mode = COUNT_NORMAL</td>
                <td>нормальный режим подсчёта, если COUNT_RECURSIVE, то считает сумму всех элементов с вложенными массивами вместе</td>
              </tr>
              <tr>
                <td>echo count($arr);</td>
                <td>2 - у массива arr два элемента: вложенные массивы</td>
              </tr>
              <tr>
                <td>echo count($arr[0]);</td>
                <td>4 - у первого вложенного массива 4 элемента</td>
              </tr>
              <tr>
                <td>echo count($arr, COUNT_RECURSIVE);</td>
                <td>10 - 2 вложенных массива + по 4 элемента в каждом</td>
              </tr>
            </tbody>
          </table>
          <pre><code>/**
* количество уникальных значений в массиве
* возвращает массив, в котором ключи - это уникальные значения,
* а значения - это количество вхождений в массив
*/
array_count_values(array $array): array   

// сумма элементов массива
array_sum(array $array): int|float

$arr = [1, 2, 3, 4, 5];
echo array_sum($arr);   // 15

// случайный элемент индексного массива, индексы которого начинаются с 0 и не имеют перерывов в нумерации
rand(): int

// задать интервал, из которого выбрать случайное значение
rand(int $min, int max): int

$arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
$index = rand(0, count($arr) - 1);
echo $arr[$index];

// получить случайно выбранный индекс (ключ) или массив случайно выбранных индексов (ключей) элементов
// если $num больше 1, то получить массив
array_rand(array $array, int $num = 1): int|string|array

// перемешать элементы массива случайным образом
shuffle(array &$array): bool
$arr = [1, 2, 3, 4, 5];
shuffle($arr);

// [5, 4, 1, 3, 2]
print_r($arr);
</code></pre>
          <p>Сортировка массива</p>
          <pre><code>/**
* сортировка значений по возрастанию в индексном массиве
* 
* SORT_REGULAR - нормальное сравнение элементов
* SORT_NUMERIC - сравнивает элементы как числа
* SORT_STRING  - сравнивает элементы как строки
* SORT_NATURAL - сравнивает элементы как строки, используя естественный для человека порядок
* SORT_LOCAL_STRING - сравнивает элементы как строки, основываясь на текущей локали
* SORT_STRING|SORT_NATURAL - можно объединять, т.к. константы являются целыми числами
*/
sort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка значений по убыванию в индексном массиве
rsort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка значений по возрастанию в ассоциативном массиве связь ключей и значений сохраняется
asort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка значений по убыванию в ассоциативном массиве связь ключей и значений сохраняется
arsort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка ключей по возрастанию в ассоциативном массиве связь ключей и значений сохраняется
ksort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка ключей по убыванию в ассоциативном массиве связь ключей и значений сохраняется
krsort(array &$array, int $flags = SORT_REGULAR): bool

// сортировка с применением колбэк функции
usort(array &$array, callable $callback): bool

// естественная сортировка индексном массиве
natsort(array &$array): bool
</code></pre>
          <ul>
            <li>сортировка нескольких массивов или одного многомерного массива</li>
            <li>массивы, которые передаются для сортировки должны содержать одинаковое количество аргументов</li>
            <li>сортируется только первый массив, остальные выстраиваются в соответствии с первым</li>
          </ul>
          <table>
            <tbody>
              <tr>
                <td colspan="2">array_multisort(): bool</td>
                <td></td>
              </tr>
              <tr>
                <td>array &$array1,</td>
                <td>массив для сортировки</td>
              </tr>
              <tr>
                <td>mixed $array1_sort_order = SORT_ASC,</td>
                <td>SORT_ASC - по возрастанию, SORT_DESC - по убыванию</td>
              </tr>
              <tr>
                <td>mixed $array1_sort_flags = SORT_REGULAR,</td>
                <td>флаги как в sort()</td>
              </tr>
              <tr>
                <td>mixed ...$rest</td>
                <td>остальные массивы</td>
              </tr>
            </tbody>
          </table>
          <p>Добавить/удалить элементы</p>
          <pre><code>// увеличить размер массива: вернёт копию массива $array, размер которого был увеличен до значения $length, элементами со значением $value
array_pad(array $array, int $length, mixed $value): array

$arr = [1, 2, 3];

// [1, 2, 3, 0, 0, 0]
$result = array_pad($arr, 6, 0);

// добавить элементы в конец массива
array_push(array &$array, mixed ...$values): int

// удалить последний элемент в массиве
array_pop(array &$array): mixed

// добавить элементы в начало массива
array_unshift(array &$array, mixed ...$values): int

// удалить первый элемент в массиве
array_shift(array &$array): mixed
</code></pre>
          <p>Ключи массива</p>
          <pre><code>// изменить регистр ключей CASE_UPPER, CASE_LOWER - по умолчанию
array_change_key_case(array $array, int $case = CASE_LOWER): array

// вернёт копию ассоциативного массива, в котором ключи заменены числовыми индексами
array_values(array $array): array

// вернёт копию массива, где ключи становятся значениями, а значения - ключами, из повторных значений учитывается только последнее
array_flip(array $array): array

// вернёт массив ключей_ если указано значение, то массив ключей указанного значения
array_keys(
  // массив
  array $array,

  // необязательное значение для поиска только его ключей
  mixed $val,

  // false - равенство, true - эквивалент
  bool $strict = false
  
): array
</code></pre>
          <p>Применить функцию к каждому элементу в массиве</p>
          <pre><code>// принимает функцию как параметр $callback и применяет её к элементам массива $array
// array_walk_recursive() - рекурсивный вариант функции, можно применить к вложенным массивам

array_walk(
    array|object &$array,
    callable $callback,

    // дополнительные параметры
    mixed $arg = null
): bool

// вернёт массив с изменёнными элементами
// количество параметров колбэк функции должно быть равно количеству обрабатываемых массивов
array_map(?callable $callback, array $array, array ... arrays): array

// вернёт копию массива с элементами согласно критерия фильтра
// колбэк функция $callback принимает по одному элементу массива $array
// сравнивает с критерием $mode и возвращает в функцию array_filter либо true либо false
// функция array_filter копирует в новый массив элементы массива $array, по которым колбэк функция вернула true
array_filter(array $array, ?callable $callback = null, int $mode = 0): array

// array_walk(), array_map(), array_filter() - всё вместе
array_reduce(array $array, callable $callback, mixed $initial = null): mixed
</code></pre>
          <p>Условия и циклы</p>
          <ul>
            <li>Ключевое слово break - прерывание выполнения.</li>
            <li>Ключевое слово continue - прервать текущую итерацию и перейти к следующей.</li>
          </ul>
          <p>Ветвление if</p>
          <pre><code>if (условие) {
  выражения
}

if (условие) {
  выражения
} else {
  выражения
}

if (условие) {
  выражения
} elseif (условие) {
  выражения
} else {
  выражения
}
</code></pre>
          <p>Тернарный оператор ?</p>
          <pre><code>условие ? выражение1 : выражение2
$х = isset($x) ?: 1;

// 1
echo $х;

// лучше так
// 1 - если переменная не инициализирована, то присвоит ей значение. если значение уже есть, то оставит без изменений
$х ??= 1;
</code></pre>
          <p>Конструкция switch, сравнивает выражение со значением через ==</p>
          <pre><code>switch (выражение)
{
  case значение1:
    выражения;
    break;
  case значение2:
    выражения;
    break;
  default:
    выражения;
}
</code></pre>
          <p>Конструкция match, сравнивает выражение с ключом через ===  </p>
          <ul>
            <li>возвращает первое совпавшее и прекращает поиск</li>
            <li>может быть частью операции с другими операторами и ключевыми словами</li>
            <li>точка с запятой в конце обязательно</li>
          </ul>
          <pre><code>match (выражение) {
  'key1' => 'value1',
  'key2' => 'value2'
};

// Использование
$str 'Hello, РНР! ';
$arr [1, 2, 3, 4, 5];
$obj new DateTime(); 
$arg = 'string';

// Hello, РНР!
echo match ( $arg) {
  gettype($str) => $str,
  gettype($arr) => print_r($arr),
  gettype($obj) => var_dump($obj)
};
</code></pre>
          <p>Конструкция goto: переход на метку - лучше не использовать</p>
          <pre><code>$i = О;
begin:
$i++;
echo "$i< Ьr />";
if ($i >= 10) goto finish;
goto begin;
finish:
</code></pre>
          <p>Цикл while</p>
          <pre><code>while (условие) {
  выражение;
}

$i = 5;
while ($i--):
  echo "$i< br />";
endwhile;

do {
  выражения;
} while (условие);
</code></pre>
          <p>Цикл for</p>
          <pre><code>for (начало счетчика; условие; инкремент/декремент) {
  выражения;
}

for ($i = О; $i < 5; $i++) {
  echo "$i< br/>";
}

for (;;) {} - бесконечный цикл

$numbers = ['1', '2', '3'];

// цикл вернёт 123
for ($i = О; $i < count($numbers); $i++) {
  echo $numbers[$i];
}
</code></pre>
          <p> Цикл foreach - создан специально для ассоциативных массивов</p>
          <pre><code>// вернёт
// first = 1 
// second = 2
// third = 3
$arr = [
  'first' => '1',
  'second' => '2',
  'third' => '3'
];

foreach ($arr as $index => $val) {
  echo "$index = $val < br/>";
}

// вернёт 123
$arr = [
  'first' => '1',
  'second' => '2',
  'third' => '3'
];

foreach ($arr as $val) {
  echo $val;
}

// перебрать многомерный массив через вложенный цикл
foreach ($arr as $key => $elem) {
  echo $key;
  foreach ($elem as $val) {
    echo $val;
  }
}

// либо перебрать через list()
foreach ($arr as $key => list($fst, $snd, $thd)) {
  echo $key;
  echo $fst;
  echo $snd;
  echo $thd;
}

// либо перебрать через []
foreach ($arr as $key => [$fst, $snd, $thd]) {
  echo $key;
  echo $fst;
  echo $snd;
  echo $thd;
}
</code></pre>
          <p>Функция - это набор выражений, который ведёт себя как одно выражение.</p>
          <ul>
            <li>по умолчанию функции с переменным числом параметров</li>
            <li>у каждой функции своя область видимости (контекст), которая уничтожается при выходе из функции</li>
            <li>каждый контекст - это отдельная область памяти</li>
            <li>время жизни локальной переменной - время выполнения функции, в которой она объявлена</li>
            <li>статическая переменная сохраняет своё значение до следующего вызова функции static $counter;</li>
            <li>время жизни статических и глобальных переменных - время выполнения сценария (до перезагрузки страницы)</li>
            <li>return - возвращает результат вычисления функции в вызывающую программу</li>
            <li>тип возвращаемого значения может быть любым, но можно задать принудительную проверку типа для значения и параметров</li>
            <li>можно создавать анонимные функции</li>
            <li>имя функции не зависит от регистра, CamelCase, первая буква маленькая</li>
            <li>функцию можно вызвать до её объявления</li>
            <li>переменные в определении функции function nameFunction($param) - параметры</li>
            <li>значения, передаваемые в функцию, при её вызове nameFunction(5) - аргументы, аргументы без имени - позиционные</li>
            <li>именованные аргументы позволяют связать имя параметра со значением nameFunction(param: 5)</li>
            <li>указать тип аргумента и возвращаемого значения nameFunction(int 5): int</li>
            <li>интерпретатор будет требовать указывать типы - declare(strict_types = 1);</li>
            <li>типы void, never и static только для возвращаемых значений</li>
            <li>если функция вызывает саму себя, то это рекурсивная функция</li>
            <li>вложенная функция может быть вызвана только после вызова основной функции, в которой объявлена вложенная</li>
            <li>каждая функция добавляется во внутреннюю таблицу функций PHP</li>
            <li>функция, переданная как параметр (в виде переменной) в другую функцию называется функцией обратного вызова, тип параметра - callable</li>
            <li>анонимная функция - $var = function(...$param) {}</li>
            <li>замыкание - это функция, которая запоминает состояние окружения в момент своего создания</li>
            <li>замыкание применяется только к анонимным функциям при помощи ключевого слова use</li>
            <li>use($var1, $var2) - перечислить переменные, которые должны войти в замыкание</li>
            <li>стрелочная функция - это короткая запись анонимной функции с однострочным выражением</li>
            <li>стрелочная функция всегда возвращает значение, return указывать не нужно - fn($n) =&gt; $n * $n;</li>
            <li>метод - это функция в классе или объекте</li>
          </ul>
          <p>Функция PHP</p>
          <pre><code>function nameFunction($param)
{
  // выражения
  // вернуть 0
  return 0;
}

// 0
echo nameFunction();

function simple()
{
  return [1, 2, 3];
}

$arr = simple();

// [1, 2, 3]
var_dump($arr);

// $a = 1, $b = 2, $c = 3
[$a, $b, $c] = simple();

// 3
echo simple()[2];
</code></pre>
          <p>Последовательность ...</p>
          <pre><code>// функция принимает неограниченное количество параметров, $items - массив параметров
function manyParam(...$items) {}
</code></pre>
          <p>Переменная в качестве аргумента</p>
          <pre><code>// аргумент передается по значению, т.е. внешнее значение копируется в тело функции
function getSшn($var)
{
  // изменяет значение внутри тела функции, внешнее не изменяется
  $var = $var + 5;
  return $var;
}

$new_var = 20;
echo getSшn($new_var); // 25
echo "$new_var";       // 20

// аргумент передается по ссылке, т.е. внешнее значение изменяется в теле функции
function getSшn(&$var)
{
  // изменяет значение внутри тела функции, внешнее не изменяется
  $var = $var + 5;
  return $var;
}

$new_var = 20;
echo getSшn($new_var); // 25
echo "$new_var";       // 25
</code></pre>
          <p>Встроенные функции</p>
          <pre><code>// удаляет значение переменной или элемента массива
unset()
unset($a);
unset($arr["elem"]);

// проверить существование значения переменной
isset()
$str='';

// true
if (isset($str)) {
echo 'Переменная $str существует< Ьr/>';

// Помечаем переменную $str как неинициализированную
$str = null;

// false
if (isset($str)) {
echo 'Переменная $str существует< Ьr/>';

// определить тип переменной: true | false
is_int($a);
is_double($a);
is_infinite($a);
is_nan($a);         // NAN (not a number) - недопустимое числовое значение
is_string($a);
is_numeric($a);     // рекомендовано использовать вместо is_int($a); и is_double($a);
is_bool($a);
is_scalar($a);
is_null($a);
is_array($a);
is_object($a);
gettype($a);
settype($a, 'int'); // привести переменную $a к типу int, вернёт true | false
floatval($a);       // привести переменную $a к типу float, вернёт значение
doubleval($a);      // привести переменную $a к типу double, вернёт значение
intval($a);         // привести переменную $a к типу int, вернёт значение
strval($a);         // привести переменную $a к типу str, вернёт значение

// необязательный аргумент $base говорит, что в аргументе $value восьмеричное число. По умолчанию $base = 10
intval(mixed $value, int $base = 8): int

// возвращает количество байтов оперативной памяти, занятые сценарием
memory_get_usage()
</code></pre>
          <p>Отладочные функции</p>
          <pre><code>// отладочное представление значений переменных и массивов
print_r(mixed $value, bool $return = false): string|bool

// отладочное представление значений и типов переменных и массивов
var_dump(mixed $value, mixed ... $values): void

// представление значений переменной как кусок кода программы
var_export(mixed $value, bool $return = false): ?string

// проверить наличие функции во внутренней таблице функций PHP, т.е. что она уже объявлена
function_exists(string $function): bool

// хранение функции в переменной
function hello()
{
    return 'Hello!';
}

function Ьуе()
{
    return 'Bye!';
}

$var = rand(0, 1) ? 'hello' : 'bye';

echo $var();  // вызов hello() и bye() по случайному выбору

// может ли переменная вызываться как функция
is_callable(
    mixed $val;                     // переменная, в которой может быть функция
    bool $syntax_only = false;      // необязательный
    string &$callable_name = null   // необязательный
): bool
</code></pre>
          <p>Генераторы - функции для создания собственных итераторов в цикле foreach:</p>
          <ul>
            <li>не создаёт копию массива, а использует элементы массива по одному, чем экономит память</li>
            <li>использовать слово return для возврата значения и выхода из функции генератора</li>
            <li>использовать слово yield для передачи на время потока вычисления циклу foreach и возврата обратно в функцию генератора</li>
            <li>возвращает объект</li>
          </ul>
          <table>
            <caption>генератор предоставляет функции, который позволяют обходить генератор без цикла foreach:</caption>
            <tbody>
              <tr>
                <td>send()</td>
                <td>передать значение внутрь генератора</td>
              </tr>
              <tr>
                <td>getReturn()</td>
                <td>получить из генератора значение, которое возвращается при помощи слова return</td>
              </tr>
              <tr>
                <td>current()</td>
                <td>вернуть текущее значение</td>
              </tr>
              <tr>
                <td>key()</td>
                <td>вернуть текущее значение по ключу - если в yield указан ключ</td>
              </tr>
              <tr>
                <td>next()</td>
                <td>переход в к следующей итерации, итератор однонаправленный - обратного хода нет</td>
              </tr>
              <tr>
                <td>valid()</td>
                <td>проверить работает ли генератор true|false</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>вернёт:</caption>
            <tbody>
              <tr>
                <td>первый yield</td>
                <td>foreach вызвал generator(), сработал echo 'первый yield' - вывел 'первый yield'</td>
              </tr>
              <tr>
                <td>1</td>
                <td>yield вернул управление в foreach и цифру 1, foreach вывел 1</td>
              </tr>
              <tr>
                <td>второй yield</td>
                <td>foreach вызвал generator(), сработал echo 'второй yield' - вывел 'второй yield'</td>
              </tr>
              <tr>
                <td>2</td>
                <td>yield вернул управление в foreach и цифру 2, foreach вывел 2</td>
              </tr>
              <tr>
                <td>третий yield</td>
                <td>foreach вызвал generator(), сработал echo 'третий yield' - вывел 'третий yield'</td>
              </tr>
              <tr>
                <td>3</td>
                <td>yield вернул управление в foreach и цифру 3, foreach вывел 3</td>
              </tr>
              <tr>
                <td>после третьего yield</td>
                <td>foreach вызвал generator(), сработал echo 'после третьего yield' - вывел 'после третьего yield'</td>
              </tr>
              <tr>
                <td></td>
                <td>функция generator() после echo 'после третьего yield'; ничего не содержит, поэтому возвращает null</td>
              </tr>
              <tr>
                <td>                    </td>
                <td>foreach получает null и завершает работу</td>
              </tr>
            </tbody>
          </table>
          <pre><code>function generator()
{
  echo 'первый yield';
  yield 1;
  echo 'второй yield';
  yield 2;
  echo 'третий yield';
  yield 3;
  echo 'после третьего yield';
}

foreach (generator() as $i) {
  echo $i < br/>;
}

// варианта с колбэк функцией - вернёт: 1 4 9 16 25  36
function collect(array $arr, callable $callback)
{
  foreach ($arr as $value) {
    yield $callback($value);
  }
}

$arr = [1, 2, 3, 4, 5, 6];
$collect = collect($arr, fn($e) => $e * $e);
foreach ($collect as $val) {
  echo "$val";
}

// делегирование генераторов - вызов одного генератора из другого
function square($value) {
  yield $value * $value;
}

function even_square($arr) {
  foreach ($arr as $value) {
    if ($value % 2 == 0) yield from square($value)
  }
}

$arr = [1, 2, 3, 4, 5, 6];
foreach (even_square($arr) as $ val) echo "$val ";

// использовать ключи - вернёт: 1 (first) 4 (second) 9 (third) 16 (fourth) 25 (fifth) 36 (sixth) 
function collect(array $arr, callaЫe $callback) {
  foreach ($arr as $key => $value) {
    yield $key => $callback($value);
  }
}

$arr = [
  'first' => 1,
  'second' => 2,
  'third' => 3,
  'fourth' => 4,
  'fifth' => 5,
  'sixth' => 6 
];

$collect = collect($arr, fn($e) => $е * $е);

foreach ($collect as $key => $val) {
  echo "$val ($key) ";
}
</code></pre>
          <p>Текст и HTML</p>
          <ul>
            <li>для работы с UTF-8 нужно расширение mbstring. Расскоментировать (убрать ;) extension dir = 'ext', extension=php_mЬstring.dll в php.ini.</li>
            <li>mbstring может заменять стандартные функции РНР работы со строками, это определяется в настройках mbstring.</li>
          </ul>
          <p>Строки</p>
          <pre><code>// символ из кодировкки UTF-8
// русская А
echo "\u{0410}";

// вернуть подстроку
// $length - количество символов возвращаемой подстроки, необязательный
substr(string $string, int $offset, ?int $length = null): string

$str = '04.02.2005';
// день - 04
echo 'день - ' . substr($str, 0, 2);

// вернуть позицию вхождения подстроки в строку
// $offset - позиция, с которой начинается поиск, необязательный
strpos(string $string, string $substring, int $offset = 0): int|false
echo strpos('Hello, world!', 'world'); // 7
</code></pre>
          <p>удалить пробелы и пробельные символы:</p>
          <ul>
            <li>пробел ' '</li>
            <li>перевод строки 
</li>
            <li>возврат каретки </li>
            <li>табуляция 	</li>
            <li>вертикальная табуляция </li>
            <li>нулевой байт  </li>
          </ul>
          <pre><code>// $characters - обозначить удаляемые символы, необязательный
trim(string $string, string $characters = " \n\r\t\v\x00"): string
</code></pre>
          <ul>
            <li>в строке $subject заменить подстроку $search на $replace</li>
            <li>$count - содержит количество проведенных замен</li>
            <li>str_replace() - с учётом регистра символов</li>
            <li>str_ireplace() - без учёта регистра символов</li>
          </ul>
          <pre><code>str_replace(
  array|string $search,
  array|string $replace,
  array|string $subject,
  int &$count = null
): array|string
</code></pre>
          <p>Локаль - локальные настройки: числа, валюта, формат времени и даты.</p>
          <table>
            <caption>Переменные окружения РНР для управления локалью:</caption>
            <tbody>
              <tr>
                <td>LC COLLATE</td>
                <td>правила сравнения и сортировки строк для местного алфавита</td>
              </tr>
              <tr>
                <td>LC СТУРЕ</td>
                <td>распознавать вид символа: цифра, буква, знак, верхний и нижний регистр</td>
              </tr>
              <tr>
                <td>LC МONETARY</td>
                <td>правила национального представления денежных величин</td>
              </tr>
              <tr>
                <td>LC NUМERIC</td>
                <td>правила национального представления чисел с плавающей точкой</td>
              </tr>
              <tr>
                <td>LC ТIМЕ</td>
                <td>правила национального представления даты и времени</td>
              </tr>
              <tr>
                <td>LC МESSAGES</td>
                <td>формат информационных, диагностических и интерактивных сообщений операционной системы</td>
              </tr>
              <tr>
                <td>LC ALL</td>
                <td>устанановить значения для всех приведенных выше переменных</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// узнать язык и кодировку
echo $LANG;

// вернёт текущее значение локали
echo setlocale(LC_ALL, О);

// вернёт ассоциативный массив с информацией о локали
localeconv(): array

setlocale(int $category, string $locales, string ...$rest): string|false

// установить локаль для денежных единиц
setlocale(LC_MONETARY, 'ru_RU.UТF-8');

// установка русской локали в переменной $loc
$loc = setlocale(LC_ALL, 'ru', 'ru_RU', 'rus', 'russian');
</code></pre>
          <p> Обработка HTML</p>
          <pre><code>n12br(string $string, bool $use_xhtml = true): string</code></pre>
          <ul>
            <li>функция n12br() добавляет на тег &lt; br/&gt; к каждому переводу строки 
</li>
            <li>лучше использовать str_replace()</li>
            <li>$use_xhtml = false - &lt; br&gt;</li>
            <li>$use_xhtml = true  - &lt; br/&gt;</li>
          </ul>
          <pre><code>htmlspecialchars(
    // строка для преобразования
    string $string,
    int $flags = ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML401,
    ?string $encoding = null,
    bool $double_encode = true
): string
</code></pre>
          <ul>
            <li>преобразовывает HTML в безопасное представление</li>
            <li>применять всегда при обработке текстовых сообщений из формы</li>
            <li>текст будет отображён, но выполняться не будет</li>
            <li>замена спецсимволов:</li>
            <li>&amp; - &amp;amp</li>
            <li>&quot; - &amp;quot</li>
            <li>' - &amp;#039 или &amp;apos</li>
            <li>&lt; - &amp;lt</li>
            <li>&gt; - &amp;gt</li>
          </ul>
          <pre><code>< !DOCTYPE html>
< html lang="en">

< head>
  < meta charset="UTF-8">
  < meta name="viewport" content="width=device-width, initial-scale=1.0">
  < title>Calculator< /title>
< /head>

< body>
  < form action="< ?php echo htmlspecialchars($_SERVER["PHP_SELF"]); ?>" method="post">
    < input type="number" name="num01" placeholder="First num">
    < select name="operator">
      < option value="add">+< /option>
      < option value="subtract">-< /option>
      < option value="multiply">*< /option>
      < option value="divide">/< /option>
    < /select>
    < input type="number" name="num02" placeholder="Second num">
    < button>Calculate< /button>
  < /form>
  < ?php
  if ($_SERVER["REQUEST_METHOD"] == "POST") {

    // Grab data from inputs
    $num01 = filter_input(INPUT_POST, "num01", FILTER_SANITIZE_NUMBER_FLOAT);
    $num02 = filter_input(INPUT_POST, "num02", FILTER_SANITIZE_NUMBER_FLOAT);
    $operator = htmlspecialchars($_POST["operator"]);

    // Error handlers
    $errors = false;
    if (empty($num01) || empty($num02) || empty($operator)) {
      echo "< p>Fill in all fealds!< /p>";
      $errors = true;
    }

    if (!is_numeric($num01) || !is_numeric($num02)) {
      echo "< p>Only write numbers!< /p>";
      $errors = true;
    }

    // Calculate the numbers if no errors
    if (!$errors) {
      $value = 0;
      switch ($operator) {
        case 'add':
          $value = $num01 + $num02;
          break;
        case 'subtract':
          $value = $num01 - $num02;
          break;
        case 'multiply':
          $value = $num01 * $num02;
          break;
        case 'divide':
          $value = $num01 / $num02;
          break;
        default:
          echo "< p>Something went wrong!< /p>";
          break;
      }
      echo "< p>Result = " . $value . "< /p>";
    }
  }
  ?>
< /body>
< /html>
</code></pre>
          <h2>Lesson</h2><a href="#!">Lesson</a><br><a href="./assets/download/php_lesson.zip">Code</a>
        </details>
        <details>
          <summary>Rust</summary>
          <h2>Rust</h2>
          <table>
            <tbody>
              <tr>
                <td>Rust</td>
                <td>мультипарадигменный компилируемый, парадигмы функционального и процедурного программирования с объектной системой, основанной на типажах</td>
              </tr>
              <tr>
                <td>Esbuild</td>
                <td>сборщик для фронта</td>
              </tr>
              <tr>
                <td>Yew</td>
                <td>framework for building front-end web apps</td>
              </tr>
              <tr>
                <td>Percy</td>
                <td>библиотека для rust web apps</td>
              </tr>
              <tr>
                <td>Seed</td>
                <td>Rust framework for creating fast and reliable web apps</td>
              </tr>
              <tr>
                <td>Sycamore</td>
                <td>library for creating web apps</td>
              </tr>
              <tr>
                <td>Leptos</td>
                <td>full-stack framework for building web applications in Rust with WebAssembly (docs.rs/leptos/latest/leptos/)</td>
              </tr>
              <tr>
                <td>Stork</td>
                <td>простая библиотека, основанная на фичах, для рекурсивного сканирования источников в стиле поисковой системы</td>
              </tr>
              <tr>
                <td>SWC</td>
                <td>Speedy Web Compiler - Rust-based platform for the Web</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Syntax: значения, размер которых известен хранятся в стэке, если размер не известен то в куче</caption>
            <tbody>
              <tr>
                <td>Statment: let x = 3;</td>
                <td>ничего не вернём, т.к. есть ; - это Statment. Если есть = то это всегда statment.</td>
              </tr>
              <tr>
                <td>Expression: x += 1</td>
                <td>вернем значение 4, т.к. нет ; - это Expression.</td>
              </tr>
              <tr>
                <td>()</td>
                <td>unit тип, который не имеет значения, размер 0 байт.</td>
              </tr>
              <tr>
                <td>let _v: () = ();</td>
                <td>представляет собой пустой tuple, возвращается когда функция ничего не возвращает.</td>
              </tr>
              <tr>
                <td>{}</td>
                <td>Scope - блок кода, в котором живёт объявленная переменная</td>
              </tr>
              <tr>
                <td>Shadowing</td>
                <td>затенение - позволяет переобъявить переменную в том же блоке кода под тем же именем</td>
              </tr>
              <tr>
                <td>let x: i32 = 5;</td>
                <td>инициализация переменной - присваиваем переменной значение</td>
              </tr>
              <tr>
                <td>let</td>
                <td>ключевое слово для объявления переменной</td>
              </tr>
              <tr>
                <td>let x: i32;</td>
                <td>объявление переменной х типа интежер 32-бита тип указывать желательно</td>
              </tr>
              <tr>
                <td>assert_eq!(x, 5);</td>
                <td>assert - утверждать, equal - равенство. Макрос (!), который проверяет на равенство</td>
              </tr>
              <tr>
                <td>println!("Success")</td>
                <td>Макрос (!), который выводит в стандартный вывод (терминал) то, что в "" и переводит курсор на новую строку</td>
              </tr>
              <tr>
                <td>format!("{}", x)</td>
                <td>возвращает String</td>
              </tr>
              <tr>
                <td>let _y: i32;</td>
                <td>_y означает неиспользуемая переменная</td>
              </tr>
              <tr>
                <td># [allow(unused_variables)]</td>
                <td>говорит компилятору позволить неиспользуемые переменные при такой записи имена переменных можно без _</td>
              </tr>
              <tr>
                <td># [derive(Debug)]</td>
                <td>говорит компилятору использовать анотацию "{:?}". dbg!(x) - выводит значение переменной х в режиме дебага</td>
              </tr>
              <tr>
                <td># [derive(Display)]</td>
                <td>говорит компилятору использовать анотацию "{}"</td>
              </tr>
              <tr>
                <td>let (x, y);</td>
                <td>объявление сразу нескольких переменных let x; и let y;</td>
              </tr>
              <tr>
                <td>let mut x;</td>
                <td>mut означает что значение переменной можно изменять</td>
              </tr>
              <tr>
                <td>x += 2;</td>
                <td>короткая запись х = х + 2;</td>
              </tr>
              <tr>
                <td>let &x = y;</td>
                <td>&x ссылка по имени х ссылается на у</td>
              </tr>
              <tr>
                <td>let &mut x = mut y;</td>
                <td>изменяемая ссылка х ссылается на изменяемую переменную у</td>
              </tr>
              <tr>
                <td>let &<'a> x</td>
                <td><'a> время жизни ссылки &</td>
              </tr>
              <tr>
                <td>*x</td>
                <td>Если х содержит ссылку &x, то * даёт нам значение по ссылке &x</td>
              </tr>
              <tr>
                <td>let t = (2, "hello", 6.4);</td>
                <td>tuple - коллекция разнотипных значений, доступ t.0, println!((только до 12 значений));</td>
              </tr>
              <tr>
                <td>let (x, y) = (1, 2);</td>
                <td>Деструктуризация tuple (1, 2) - х = 1, у = 2</td>
              </tr>
              <tr>
                <td>(x, ..) = (3, 4);            </td>
                <td>Деструктуризация: х принимает значение 3, .. означает пропустить, у принимает значение 2: [x, y] = [3, 2]   </td>
              </tr>
              <tr>
                <td>Integers: i32                </td>
                <td>целое число i32 и число с плавающей точкой - f64, при операциях с f64 большая точность выявляет погрешность чисел</td>
              </tr>
              <tr>
                <td>Floats: f64                  </td>
                <td>поэтому равенства могут на работать, в таких случаях нужно использовать f32: 0.1 + 0.2 == 0.300000000000000001</td>
              </tr>
              <tr>
                <td>let x: u16 = 38_u8 as u16;   </td>
                <td>присваиваю значение 38 типа u8 переменной х типа u16, т.к. присваивать можно только того же типа, то меняю тип as u16</td>
              </tr>
              <tr>
                <td>bool                         </td>
                <td>логический тип false и true, имеет размер 1 байт</td>
              </tr>
              <tr>
                <td>char                         </td>
                <td>тип символа имеет размер 4 байта. обозначается одинарной кавычкой ''.</td>
              </tr>
              <tr>
                <td>String                       </td>
                <td>тип строки - набор символов в виде вектора байт. обозначается двойной кавычкой "".</td>
              </tr>
              <tr>
                <td>let x= String::from("hello");</td>
                <td>переменная x хранит ярлык с длиной, ёмкостью и указателем на адрес памяти в куче где хранится "hello"</td>
              </tr>
              <tr>
                <td colspan="2">Методы приведения к типу String: String::from("hallo"); "hello".to_string();</td>
                <td></td>
              </tr>
              <tr>
                <td>s.replace("word1", "word2");</td>
                <td>заменяет word1 на word2 в строке s</td>
              </tr>
              <tr>
                <td>s.push_str("hello, world");</td>
                <td>когда добавляем в строку другую строку</td>
              </tr>
              <tr>
                <td>s.push('!');</td>
                <td>когда добавляем в строку один символ</td>
              </tr>
              <tr>
                <td>s3: String = s1: String + s2.as_str();</td>
                <td>при конкатенации строк второе слагаемое должно быть &str. Метод s.clear() - делает строку пустой</td>
              </tr>
              <tr>
                <td>str</td>
                <td>тип строкового литерала "hello", используется только по ссылке &str, хранится в стэке и является представлением (фотографией на данный момент) строки типа String которая храниться в куче, т.е. при инициализации переменной типа &str мы идём в кучу делаем срез нужной строки и сохраняем его в стэке под именем инициализируемой переменной</td>
              </tr>
              <tr>
                <td>\</td>
                <td>экранирование символов в стоке</td>
              </tr>
              <tr>
                <td>let row_str = r"\x3F";</td>
                <td>в row строке экранирование не работает, конвертации в символ не будет</td>
              </tr>
              <tr>
                <td>let s = &s1[0..1];</td>
                <td>доступ к символам в строке s только через срез. В срезе указывается диапазон байт строки в котором находится нужный символ</td>
              </tr>
              <tr>
                <td>\=</td>
                <td>
                  <ul>
                    <li>Присваивание. Значение, которое имеет фиксированный размер живёт в стеке и принадлежит переменной.</li>
                    <li>Значение, которое может изменяться живёт в куче, на его адрес в куче указывает переменная, в которой хранится указатель, длина значения и количество памяти зарезервированное под это значение.</li>
                    <li>При присваивании значения переменной из стэка другой переменной происходит копирование значения.</li>
                    <li>При присваивании значения переменной из кучи другой переменной происходит перемещение указателя, длины и количества памяти из старой переменной в новую. Старая переменная уничтожается.</li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td>let new_var = old_var.clone();</td>
                <td>копия значения в куче и указатель на копию в новой переменной</td>
              </tr>
              <tr>
                <td>::         </td>
                <td>обращение к ассоциированной функции String::from("hello"); ассоциированная - это функция без аргумента self</td>
              </tr>
              <tr>
                <td>.          </td>
                <td>обращение к методу "hello".to_string(); метод - это функция первый аргумент которой self</td>
              </tr>
              <tr>
                <td>0xff       </td>
                <td>16-ти ричное значение 255</td>
              </tr>
              <tr>
                <td>0o77       </td>
                <td>8-ти ричное значение 63</td>
              </tr>
              <tr>
                <td>0b1111_1111</td>
                <td>бинарное (0 и 1) значение 255 </td>
              </tr>
              <tr>
                <td colspan="2">for i in 'a'..='z' {println!("{}", i);}</td>
                <td></td>
              </tr>
              <tr>
                <td>for _ in _ {}</td>
                <td>цикл</td>
              </tr>
              <tr>
                <td>'a'..='z'</td>
                <td>диапозон от..до. если есть =, значит включительно</td>
              </tr>
              <tr>
                <td>"{}", i</td>
                <td>вставить в стоку значение i</td>
              </tr>
              <tr>
                <td>for c in "hello".chars() {</td>
                <td>Метод chars() переведёт символы строки в итератор (в последовательность для итерирования)</td>
              </tr>
              <tr>
                <td>println!("{}", c)}</td>
                <td>Цикл for пройдёт по всей последовательности и выведет каждый символ на печать</td>
              </tr>
              <tr>
                <td>fn name(x: i32, y: i32) -> i32 {x + y}</td>
                <td>именованный блок кода, который используется несколько раз</td>
              </tr>
              <tr>
                <td>fn</td>
                <td>ключевое слово для объявления функции;</td>
              </tr>
              <tr>
                <td>name(x: i32, y: i32)</td>
                <td> 
                  <ul>
                    <li>имя функции с параметрами х и у, анотация типа параметра обязательна</li>
                    <li>если в параметр передается переменная, которая указывает на значение в куче, то эта переменная перемещается из своей области видимости в область видимости функции</li>
                    <li>если в параметр передается переменная со значением в стэке, то переменная остается в своей области видимости, а в область видимости функции передается её копия</li>
                  </ul>
                </td>
              </tr>
              <tr>
                <td>-> i32</td>
                <td>возвращает значение типа i32, обязательно указывать если функция что-нибудь возвращает;</td>
              </tr>
              <tr>
                <td>{}</td>
                <td>scope, блок кода, область видимости функции;</td>
              </tr>
              <tr>
                <td>x + y</td>
                <td>выражение, результат которого возвращает функция</td>
              </tr>
              <tr>
                <td>fn never_return() -> ! {panic!()}</td>
                <td>функция, которая никогда не вернет поток. Макрос panic!() вызовет ошибку и завершение программы.</td>
              </tr>
              <tr>
                <td>unimplemented!()</td>
                <td></td>
              </tr>
              <tr>
                <td>todo!()</td>
                <td>макрос для функций, которые пока ещё не реализованы.</td>
              </tr>
              <tr>
                <td>Option< i32></td>
                <td>Some() None</td>
              </tr>
              <tr>
                <td>Result< Res, Err></td>
                <td>Ok() Err()</td>
              </tr>
              <tr>
                <td>let x: Box< i32> = Box::new(5);</td>
                <td>Box позволяет разместить любое значение в куче.</td>
              </tr>
              <tr>
                <td>let s: Box< str> = "hello, world".into();</td>
                <td>Метод into() переводит значение, на которои его вызвали в указанный тип переменной.</td>
              </tr>
            </tbody>
          </table>
          <pre><code>match x {
  1 => { }
  _ => { }
}

// создаёт сруктуру с полями. Так создаются новые пользовательские типы.
struct Person {
  name: String,
  age: Box< u8>,
}

// инициализируем структуру с конкретными значениями. Переменная person имеет тип Person.
let person: Person = struct Person {
  name: String::from("Alice"),
  age: Box::new(20),
};

// деструктуризируем переменную. Получаем переменные name и age с указателями на значения.
let Person {name, age} = person;

let arr = [];

// [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
let arr: [i32; 3] = [1, 2, 3]; let arr: [i32; 10] = [1; 10];

arr[0], arr.get(0).unwrap();
get(0) - возвращает Option< T>
</code></pre>
          <h2>Introduction</h2>
          <table>
            <caption>Cargo - система сборки и менеджер пакетов</caption>
            <tbody>
              <tr>
                <td>cargo new name_folder</td>
                <td>создать проект name_folder</td>
              </tr>
              <tr>
                <td>cargo new proj --vcs=none</td>
                <td>создать проект proj без git</td>
              </tr>
              <tr>
                <td>cargo build</td>
                <td>создать исполняемый файл</td>
              </tr>
              <tr>
                <td>cargo run</td>
                <td>пересобирает исполняемый файл и запускает его</td>
              </tr>
              <tr>
                <td>cargo check</td>
                <td>проверяет, что код компелируется, но не создаёт исполняемый файл</td>
              </tr>
              <tr>
                <td>cargo build --release</td>
                <td>создаёт исполнфемый файл с оптимизаией, собирает финальную версию</td>
              </tr>
            </tbody>
          </table>
          <p>Модульная система</p>
          <table>
            <caption>разделение кода по основным функциональностям (фичам, feature) и группировка связанных функций</caption>
            <tbody>
              <tr>
                <td>Пакеты:</td>
                <td>функционал Cargo позволяющий собирать, тестировать и делиться крейтами.</td>
              </tr>
              <tr>
                <td>Крейты:</td>
                <td>дерево модулей, которое создаёт библиотечный или исполняемый файл.</td>
              </tr>
              <tr>
                <td>Модули</td>
                <td>и use: позволяют вместе контролировать организацию, область видимости и скрытие путей.</td>
              </tr>
              <tr>
                <td>Пути:</td>
                <td>способ именования элемента, такого как структура, функция или модуль.</td>
              </tr>
              <tr>
                <td>Крейт</td>
                <td>наименьший объём кода, который компилятор Rust рассматривает за раз.</td>
              </tr>
              <tr>
                <td>Бинарный крейт</td>
                <td>обязательно содержит функцию main. Программа, которую можно скомпилировать в исполняемый файл.</td>
              </tr>
              <tr>
                <td>Библиотечный крейт</td>
                <td>не имеет функции main и не компилируется в исполняемый файл. Функциональность для совместного использования другими проектами.</td>
              </tr>
              <tr>
                <td colspan="2">По умолчанию</td>
                <td></td>
              </tr>
              <tr>
                <td>src/main.rs</td>
                <td>это корневой модуль бинарного крейта</td>
              </tr>
              <tr>
                <td>src/lib.rs</td>
                <td>это корневой модуль библиотечного крейта</td>
              </tr>
            </tbody>
          </table>
          <p>Корневой модуль крейта - исходный файл.</p>
          <ul>
            <li>Пакет - набор из одного или нескольких крейтов, представляющий набор функциональности.</li>
            <li>Пакет содержит файл Cargo.toml, в котором описывается как собирать эти крейты.</li>
            <li>Пакет может содержать любое количество бинарных крейтов, но не более одного библиотечного крейта.</li>
            <li>Пакет должен содержать хотя бы один крейт, библиотечный или бинарный.</li>
            <li>Совокупность пакетов образуют рабочее пространство (workspace).</li>
            <li>Cargo передаёт файлы корневого модуля крейта в rustc для сборки этого крейта.</li>
            <li>Пакет может иметь несколько бинарных крейтов, помещая их файлы в каталог src/bin: каждый файл будет отдельным бинарным крейтом, с тем же именем, что и пакет.</li>
          </ul>
          <p>Правила:</p>
          <ul>
            <li>При компиляции компилятор сначала ищет корневой модуль крейта (src/lib.rs или src/main.rs)</li>
            <li>В файле корневого модуля крейта можно объявить новые модули; при объявлении mod garden компилятор будет искать код модуля в местах:</li>
            <li>в этом же файле, между фигурных скобок, которые заменяют точку с запятой после mod garden</li>
            <li>в файле src/garden.rs</li>
            <li>в файле src/garden/mod.rs</li>
            <li>Если объявить модуль в файле, например объявить mod vegetables в src/garden.rs, то компилятор будет искать код модуля в каталоге родительского модуля:</li>
            <li>в файле где объявили (garden.rs) сразу после mod vegetables, между фигурных скобок, которые заменяют точку с запятой.</li>
            <li>в файле src/garden/vegetables.rs</li>
            <li>в файле src/garden/vegetables/mod.rs</li>
            <li>Обратиться к коду (к типу) можно используя путь: crate::garden::vegetables::Asparagus. Asparagus - это тип, код которого в модуле vegetables.</li>
            <li>Чтобы сделать модуль общедоступным нужно добавить pub впереди объявления: pub mod.</li>
            <li>Чтобы сделать элемент общедоступного модуля общедоступным нужно добавить pub перед его объявлением.</li>
            <li>Ключевое слово use создаёт псевдоним для элемента для уменьшения длинных путей: после use crate::garden::vegetables::Asparagus можно просто писать Asparagus.</li>
          </ul>
          <p>Пример:</p>
          <pre><code>// src/main.rs
use crate::garden::vegetables::Asparagus;
pub mod garden;

fn main () {
  let plant = Asparagus {};
  println! (“I’m growing {:?}!”, plant);
}

// src/garden.rs
pub mod vegetables;

// src/garden/vegetables.rs
# [derive(Debug)]
pub struct Asparagus {}
</code></pre>
          <p>Код внутри модуля по умолчанию закрытый. Создать библиотечный крейт restaurant:</p>
          <pre><code>cargo new restaurant --lib;</code></pre>
          <p>Получаем src/lib.rs.</p>
          <ul>
            <li>Модуль размещается внутри фигурных скобок.</li>
            <li>Модуль может находиться внутри другого модуля или в отдельном файле.</li>
            <li>Файлы src/main.rs и src/lib.rs называются корневыми модулями крейта.</li>
            <li>Содержимое любого из этих файлов образует модуль с именем crate в корне структуры модулей дерево модулей.</li>
          </ul>
          <table>
            <thead>
              <tr>
                <th>Crate</th>
                <th>родитель всего дерева (parent)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>A</td>
                <td>B</td>
              </tr>
              <tr>
                <td>A и B потомки crate (child)</td>
                <td>A и B братья (siblings)</td>
              </tr>
            </tbody>
          </table>
          <p>Чтобы найти элемент в дереве модулей используем путь:</p>
          <ul>
            <li>абсолютный путь - это полный путь, начинающийся от корневого модуля крейта;</li>
            <li>для кода из внешнего крейта абсолютный путь начинается с имени крейта, а для кода из текущего крейта он начинается с литерала crate.</li>
            <li>относительный путь - начинается с текущего модуля и использует ключевые слова self, super или идентификатор в текущем модуле.</li>
            <li>Абсолютные и относительные пути состоят из одного или нескольких идентификаторов, разделённых двойными двоеточиями(::).</li>
            <li>Чтобы сделать функцию или структуру приватой нужно поместить её в модуль.</li>
            <li>Дочерние модули оборачивают и скрывают детали своей реализации, но могут видеть контекст родителей, в котором они определены.</li>
            <li>Дерево модулей должно быть определено в src/lib.rs, тогда любые общедоступные элементы можно использовать в бинарном крейте, начав пути с имени пакета.</li>
            <li>С помощью ключевого слова super можно построить относительные пути, которые начинаются в родительском модуле.</li>
            <li>Rust не позволяет подключать оператором use два элемента с одинаковыми именами из разных родительских модулей.</li>
            <li>Идиоматические пути с use</li>
          </ul>
          <pre><code>use std::fmt;
use std::io;
fn function1 () -> fmt::Result { }

fn function2 () -> io::Result { }

// С использованием ключевого слова as:
use std::fmt::Result;
use std::io::Result as IoResult;
fn function1 () -> Result { }

fn function2 () -> IoResult <()> { }
</code></pre>
          <p>Реэкспорт pub use - подключаем элемент в область видимости и делаем этот элемент доступным для подключения в других областях видимости. Добавить внешний пакет rand: в файл Cargo.toml написать rand = “0.8.3”</p>
          <pre><code>use rand::Rng;
fn main () {
  let secret_number = rand::thread_rng().gen_range(1..=100);
}
</code></pre>
          <p>Чтобы указать несколько элементов, определённых в одном крейте или в том же модуле используем вложенные пути:</p>
          <pre><code>use std::cmp::Ordering;

// либо
use std::{cmp::Ordering, io};
use std::io;

use::io;
use::io::Write;

// либо
use std::io::{self, Write};
</code></pre>
          <ul>
            <li>Лучше всего разделить функциональность, чтобы каждая функция отвечала за одну задачу.</li>
            <li>main.rs занимается запуском программы, а lib.rs обрабатывает всю логику задачи.</li>
            <li>Разделите код программы на два файла main.rs и lib.rs.</li>
            <li>Перенесите всю логику работы программы в файл lib.rs.</li>
            <li>Пока ваша логика синтаксического анализа командной строки мала, она может оставаться в файле main.rs.</li>
            <li>Когда логика синтаксического анализа командной строки становится сложной, извлеките её из main.rs и переместите в lib.rs.</li>
            <li>Функциональные обязанности, которые остаются в функции main после этого процесса должно быть ограничено следующим:</li>
            <li>Вызов логики разбора командной строки со значениями аргументов</li>
            <li>Настройка любой другой конфигурации</li>
            <li>Вызов функции run в lib.rs</li>
            <li>Обработка ошибки, если run возвращает ошибку мы запустим программу с помощью &gt; и именем файла output.txt в который мы хотим перенаправить стандартный поток вывода.</li>
            <li>Синтаксис &gt; указывает оболочке записывать содержимое стандартного вывода в output.txt вместо экрана.</li>
          </ul>
          <pre><code>cargo run > output.txt</code></pre>
          <ul>
            <li>Программирование в функциональном стиле зачастую предполагает использование функций в качестве значений, которые передаются в качестве аргументов, возвращаются из других функций, присваиваются переменным для последующего выполнения и так далее.</li>
            <li>Cargo имеет два основных профиля: профиль dev, используемый Cargo при запуске cargo build, и профиль release, используемый Cargo при запуске cargo build --release.</li>
            <li>Добавляя секции [profile.*] для любого профиля, который вы хотите настроить, вы переопределяете любое подмножество параметров по умолчанию.</li>
            <li>В Rust также есть особый вид комментариев к документации, который обычно называется комментарием к документации, который генерирует документацию HTML.</li>
            <li>Комментарии к документации используют три слеша, /// вместо двух и поддерживают нотацию Markdown для форматирования текста.</li>
            <li>Размещайте комментарии к документации непосредственно перед элементом, который они документируют.</li>
            <li>Мы можем сгенерировать документацию HTML из этого комментария к документации, запустив cargo doc.</li>
            <li>Стиль комментариев к документам //! добавляет документацию к элементу, содержащему комментарии, а не к элементам, следующим за комментариями.</li>
          </ul>
          <p>
            авторы библиотек обычно используют в своей документации:<br/>
            Panics:
          </p>
          <ul>
            <li>Сценарии, в которых документированная функция может вызывать панику.</li>
            <li>Вызывающие функцию, которые не хотят, чтобы их программы паниковали, должны убедиться, что они не вызывают функцию в этих ситуациях.</li>
          </ul>
          <p>Ошибки:</p>
          <ul>
            <li>Если функция возвращает Result, описание типов ошибок, которые могут произойти и какие условия могут привести к тому, что эти ошибки могут быть возвращены, может быть полезным для вызывающих, так что они могут написать код для обработки различных типов ошибок разными способами.</li>
          </ul>
          <p>Безопасность:</p>
          <ul>
            <li>Если функция является unsafe для вызова, должен быть раздел, объясняющий, почему функция небезопасна и охватывающий инварианты, которые функция ожидает от вызывающих сторон.</li>
            <li>Добавление примеров кода в комментарии к документации может помочь продемонстрировать, как использовать вашу библиотеку, и это даёт дополнительный бонус: запуск cargo test запустит примеры кода в вашей документации как тесты!</li>
          </ul>
          <p>Workspace</p>
          <ul>
            <li>По мере развития вашего проекта может возникнуть ситуация, когда библиотечный крейт будет становиться все больше, и вы захотите разделить ваш пакет на несколько библиотечных крейтов.</li>
            <li>Cargo предоставляет функциональность под названием workspaces, которая помогает управлять несколькими взаимосвязанными пакетами, которые разрабатываются в тандеме.</li>
            <li>Workspace - это набор пакетов, которые используют один и тот же Cargo.lock и директорию для хранения результатов компиляции.</li>
            <li>Команда cargo install позволяет локально устанавливать и использовать исполняемые крейты.</li>
            <li>Она не предназначена для замены системных пакетов; она используется как удобный способ Rust разработчикам устанавливать инструменты, которыми другие разработчики поделились на сайте crates.io.</li>
            <li>Если исполняемый файл доступен через переменную окружения $PATH и назван по шаблону cargo-something, то его можно запускать как субкоманду Cargo cargo something.</li>
            <li>Пользовательские команды подобные этой также перечисляются в списке доступных через cargo --list.</li>
            <li>В большинстве современных операционных систем программный код выполняется в виде процесса, причём операционная система способна управлять несколькими процессами сразу.</li>
            <li>Программа, в свою очередь, может состоять из нескольких независимых частей, выполняемых одновременно.</li>
            <li>Конструкция, благодаря которой эти независимые части выполняются, называется потоком.</li>
            <li>Например, веб-сервер может иметь несколько потоков для того, чтобы он мог обрабатывать больше одного запроса за раз.</li>
            <li>Для обеспечения отправки многопоточных сообщений в стандартной библиотеке языка Rust реализованы каналы.</li>
            <li>Канал в программировании - это общепринятый механизм, с помощью которого данные из одного потока отправляются другому потоку.</li>
            <li>Канал считается закрытым , если либо передающая, либо принимающая его половина уничтожена.</li>
            <li>Мы создаём новый канал, используя функцию mpsc::channel; mpsc означает несколько производителей, один потребитель (multiple producer, single consumer).</li>
            <li>Несколько ручьёв втекают в одну большую реку: всё, что плывёт вниз по любому из ручьёв, в конце концов окажется в одной реке.</li>
          </ul>
          <h2>Variable</h2>
          <table>
            <caption>Переменные по умолчанию не изменяемые.</caption>
            <tbody>
              <tr>
                <td>let x</td>
                <td>объявление переменной</td>
              </tr>
              <tr>
                <td>mut</td>
                <td>измеяемый, с константами использовать нельзя</td>
              </tr>
              <tr>
                <td>let mut x</td>
                <td>объявление изменяемой переменной</td>
              </tr>
              <tr>
                <td>const</td>
                <td>константа, при объявлении константы обязательно указать тип</td>
              </tr>
              <tr>
                <td>const THIS_IS_CONSTANT: U32</td>
                <td>объявление константы</td>
              </tr>
            </tbody>
          </table>
          <p>Затенение - вторая переменная с тем же именем затеняет первую, присваивая себе любое использование имени переменной до тех пор пока либо она сама не будет затенена, либо область действия не закончится.</p>
          <table>
            <tbody>
              <tr>
                <td>let x = 5;</td>
                <td>Используя слово let, мы создвём новую переменную. Менять тип переменной нельзя.</td>
              </tr>
              <tr>
                <td>let x = x + 1;</td>
                <td>Затенение</td>
              </tr>
              <tr>
                <td>let x = 5;</td>
                <td>привязываем значение к переменной</td>
              </tr>
              <tr>
                <td>let y = x;</td>
                <td>копируем значение в другую переменную. Оба значения помещаются в стек.</td>
              </tr>
              <tr>
                <td>let s1 = String::from(“hello”);</td>
                <td>привязываем указатель.</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Указатель находится в стеке.</li>
            <li>Указатель указывает на память, в которой хранится содержимое строки, длина и емкость.</li>
            <li>Содержимое строки хранится в куче.</li>
          </ul>
          <table>
            <tbody>
              <tr>
                <td>let s2 = s1;</td>
                <td>перемещение. Ссылка (указатель) в переменной s1 на данные в куче не действительна.Указатель только в переменной s2.</td>
              </tr>
              <tr>
                <td colspan="2">let s1 = String::from(“hello”);</td>
                <td></td>
              </tr>
              <tr>
                <td>let s2 = s1.clone();</td>
                <td>указатель в стеке перемещается, а содержание строки в куче копируется.</td>
              </tr>
              <tr>
                <td>& - амперсанд (&String)</td>
                <td>это ссылка, которая позволяет ссылаться на некоторое значение, не принимая владение им.</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Передача переменной в функцию приведет к перемещению или копированию как и при присваивании значения переменной.</li>
            <li>Основная разница в том, что значения копируются, находясь в стеке; и доступны обе переменные с одинаковыми значениями, а при копировании указателя, который ссылается на данные в куче, доступной будет только новая переменная, содержащая указатель. То же самое при передачи в функцию.</li>
            <li>Процесс создания ссылки называется заимствованием.</li>
          </ul>
          <p>Чтобы можно было изменять по ссылке:</p>
          <pre><code>fn main () {
  изменяемая переменная s
  let mut s = String::from ("hello");
  
  изменяемая переменная s со ссылкой,
  т.е. изменяемая ссылка на изменяемую переменную.
  change (&mut s);
}
</code></pre>
          <ul>
            <li>Изменяемая ссылка всегда одна в своей области видимости, никаких других ссылок.</li>
            <li>В один момент времени в одной области видимости может существовать либо одна изменяемая ссылочная переменная, либо любое количество неизменяемых ссылочных переменных.</li>
            <li>Все ссылки должны быть действительны, т.е. ссылаться на существующие в памяти данные.</li>
            <li>Срез позволяет ссылаться на непрерывную последовательность элементов в коллекции, а не на всю коллекцию, без права владения.</li>
            <li>iter () - метод, который возвращает каждый элемент в коллекции.</li>
            <li>enumerate () - оборачивает результат iter и возвращает каждый элемент как часть кортежа. Первый элемент кортежа это индекс, а второй - ссылка на элемент (i, &amp;item).</li>
          </ul>
          <pre><code>for (i, &item) in bytes.iter().enumerate()</code></pre>
          <p>Строковые срезы (&str - тип “срез строки”).</p>
          <pre><code>// Строковый срез - это ссылка на часть строки String
let s = String::from (“hello world”);
let hello = &s[0..5];
let world = &s[6..11];

// Срез хранит начальную позицию и длину среза.
let slice = &s[0..2]; одно и тожеlet slice = &s[..2];
let len = s.len();

// s имеет тип &str.
let slice = &s[3..len]; одно и тожеlet slice = &s[3..];

// s - указывает на место в бинарном файле программы.
let slice = &s[0..len]; одно и тожеlet slice = &s[..];

// Строковые литералы - это срезы
let s = “Hello world!”;
</code></pre>
          <p>Строковый литерал неизменяемый, потому что тип &str - это не изменяемая ссылка.</p>
          <pre><code>// Строковый срез может быть параметром
fn first (s:&str) -> &str {}
</code></pre>
          <p>Срезы могут быть разные:</p>
          <pre><code>let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];

// тип среза [i32]
assert_eq! (slice, &[2, 3]);
</code></pre>
          <ul>
            <li>У каждой ссылки в Rust есть своё время жизни - область кода, на протяжении которого данная ссылка действительна (valid).</li>
            <li>Мы должны явно объявлять сроки жизни тех ссылок, для которых времена жизни могут быть определены компилятором по-разному.</li>
            <li>Rust требует от нас объявлять взаимосвязи посредством обобщённых параметров сроков жизни - чтобы убедиться в том, что во время исполнения все действующие ссылки будут корректными.</li>
            <li>Основное предназначение сроков жизни — предотвращать появление так называемых 'повисших ссылок' (dangling references), из-за которых программа обращается не к тем данным, к которым она собиралась обратиться.</li>
          </ul>
          <table>
            <caption>fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {}</caption>
            <tbody>
              <tr>
                <td>&i32</td>
                <td>a reference</td>
              </tr>
              <tr>
                <td>&'a i32</td>
                <td>a reference with an explicit lifetime</td>
              </tr>
              <tr>
                <td>&'a mut i32</td>
                <td>a mutable reference with an explicit lifetime</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Сигнатура функции сообщает Rust, что для некоторого времени жизни 'a функция принимает два параметра, оба из которых являются срезами строк, которые живут не меньше, чем время жизни 'a.</li>
            <li>Сигнатура функции также сообщает Rust, что срез строки, возвращаемый функцией, будет жить как минимум столько, сколько длится время жизни 'a. На практике это означает, что время жизни ссылки, возвращаемой функцией longest, равно меньшему времени жизни передаваемых в неё ссылок.</li>
            <li>Структуры могут содержать и ссылки, но при этом необходимо добавить аннотацию времени жизни для каждой ссылки в определении структуры.</li>
          </ul>
          <pre><code>struct ImportantExcerpt<'a> {
  part: &'a str,
}
</code></pre>
          <ul>
            <li>Сигнатура функции сообщает Rust, что для некоторого времени жизни 'a функция принимает два параметра, оба из которых являются срезами строк, которые живут не меньше, чем время жизни 'a.</li>
            <li>Сигнатура функции также сообщает Rust, что срез строки, возвращаемый функцией, будет жить как минимум столько, сколько длится время жизни 'a. На практике это означает, что время жизни ссылки, возвращаемой функцией longest, равно меньшему времени жизни передаваемых в неё ссылок.</li>
            <li>Структуры могут содержать и ссылки, но при этом необходимо добавить аннотацию времени жизни для каждой ссылки в определении структуры.</li>
          </ul>
          <pre><code>fn foo<'a> (x: &'a i32);</code></pre>
          <p>функция с двумя аргументами получит два отдельных параметра времени жизни:</p>
          <pre><code>// и так далее
fn foo <'a, 'b> (x: &'a i32, , y: &'b i32)
</code></pre>
          <p>Второе правило говорит, что если есть ровно один входной параметр времени жизни, то его время жизни назначается всем выходным параметрам:</p>
          <pre><code>fn foo<'a> (x: &'a i32) -> &'a i32
</code></pre>
          <p>
            Третье правило о том, что если есть множество входных параметров времени жизни, но один из них является ссылкой &self или &mut self, так как эта функция является методом, то время жизни self назначается временем жизни всем выходным параметрам.<br/>
            Это третье правило делает методы намного приятнее для чтения и записи, потому что требуется меньше символов.<br/>
            'static означает, что данная ссылка может жить всю продолжительность работы программы.<br/>
            Все строковые литералы по умолчанию имеют время жизни 'static:
          </p>
          <pre><code>let s: &'static str = "I have a static lifetime.";</code></pre>
          <ul>
            <li>Указатель — это общая концепция для переменной, которая содержит адрес участка памяти.</li>
            <li>Этот адрес «относится к», или «указывает на» некоторые другие данные.</li>
            <li>Наиболее общая разновидность указателя в Rust — это ссылка.</li>
            <li>Умные указатели, с другой стороны, являются структурами данных, которые не только действуют как указатель, но также имеют дополнительные метаданные и возможности.</li>
            <li>Ссылки только заимствуют данные, умные указатели часто владеют данными, на которые указывают.</li>
            <li>Характерной чертой, которая отличает умный указатель от обычной структуры, является то, что для умных указателей реализованы типажи Deref и Drop.</li>
            <li>Наиболее простой умный указатель - это box, чей тип записывается как Box&lt; T&gt;</li>
            <li>Такие переменные позволяют хранить данные в куче, а не в стеке.</li>
            <li>То, что остаётся в стеке, является указателем на данные в куче.</li>
            <li>Использовать его чаще всего в следующих ситуациях:</li>
            <li>Когда у вас есть тип, размер которого невозможно определить во время компиляции, а вы хотите использовать значение этого типа в контексте, требующем точного размера.</li>
            <li>Когда у вас есть большой объем данных и вы хотите передать владение, но при этом быть уверенным, что данные не будут скопированы.</li>
            <li>Когда вы хотите получить значение во владение и вас интересует только то, что оно относится к типу, реализующему определённый трейт, а не то, является ли оно значением какого-то конкретного типа.</li>
            <li>Обычная ссылка - это разновидность указателя, а указатель можно рассматривать как своеобразную стрелочку направляющую к значению, хранящемуся в другом месте.</li>
            <li>Box-ы обеспечивают только перенаправление и выделение в куче; у них нет никаких других специальных возможностей.</li>
            <li>Сравнение числа и ссылки на число не допускается, потому что они различных типов.</li>
            <li>Мы должны использовать оператор разыменования, чтобы перейти по ссылке на значение, на которое она указывает.</li>
            <li>Сильные ссылки - это то с помощью чего вы можете поделиться владением экземпляра Rc&lt; T&gt;</li>
            <li>Слабые ссылки не отражают связи владения, и их подсчёт не влияет на то, когда экземпляр Rc&lt; T&gt; будет очищен.</li>
            <li>Они не приведут к ссылочному циклу, потому что любой цикл, включающий несколько слабых ссылок, будет разорван, как только количество сильных ссылок для задействованных значений станет равным 0.</li>
            <li>Игнорирование неиспользуемой переменной, начинающейся с символа нижнего подчеркивания в имени.</li>
            <li>Начинаем имя переменной с подчёркивания, чтобы не получить предупреждения о неиспользованных переменных.</li>
          </ul>
          <pre><code>fn main() {
  let _x = 5;
  let y = 10;
}
</code></pre>
          <p>Синтаксис _x по-прежнему привязывает значение к переменной, тогда как нижнее подчеркивание не привязывает ничего. Неиспользуемая переменная, начинающаяся с подчёркивания, по-прежнему привязывает значение, что может привести к смене владельца значения.</p>
          <pre><code>fn main() {
  let s = Some(String::from("Hello!"));
  if let Some(_s) = s {
    println!("found a string");
  }
  println!("{:?}", s);
}

// Использование подчёркивания не привязывает значение
fn main() {
  let s = Some(String::from("Hello!"));
  if let Some(_) = s {
    println!("found a string");
  }
    println!("{:?}", s);
}
</code></pre>
          <p>Связывание @</p>
          <ul>
            <li>Оператор at (@) позволяет создать переменную, которая содержит значение, одновременно с тем, как мы проверяем, соответствует ли это значение шаблону.</li>
            <li>мы хотим проверить, что перечисление Message::Hello со значением поля id находится в диапазоне 3..=7.</li>
            <li>Но мы также хотим привязать такое значение к переменной id_variable, чтобы использовать его внутри кода данной ветки.</li>
            <li>Использование @ для привязывания значения в шаблоне, с одновременной его проверкой.</li>
          </ul>
          <pre><code>fn main() {
  enum Message {
    Hello { id: i32 },
  }
  let msg = Message::Hello { id: 5 };
  match msg {
    Message::Hello {
      id: id_variable @ 3..=7,
    } => println!("Found an id in range: {}", id_variable),
    Message::Hello { id: 10..=12 } => {
      println!("Found an id in another range")
    }
    Message::Hello { id } => println!("Found some other id: {}", id),
  }
}
</code></pre>
          <h2>Type</h2>
          <ul>
            <li>Rust статически типизированный язык.</li>
            <li>Целочисленные типы.</li>
            <li>Со знаком - это положительные и отрицательные.</li>
            <li>Без знака всегда положительные.</li>
            <li>arch - основное использование - это индексация коллекции.Зависит от архитектуры компьютера 34-bit или 64-bit.</li>
            <li>Скалярный тип представляет единственное значение.В Rust четыре скалярных типа: целые и вещественные числа, логический тип и символ.</li>
            <li>Типы чисел с плавающей запятой f32 и f64</li>
            <li>Логистический тип данных bool: true или false</li>
            <li>Символический тип данных char.</li>
          </ul>
          <table>
            <thead>
              <tr>
                <th>Длина</th>
                <th>Со знаком</th>
                <th>Без знака</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>8 bit</td>
                <td>i8</td>
                <td>u8</td>
              </tr>
              <tr>
                <td>16 bit</td>
                <td>i16</td>
                <td>u16</td>
              </tr>
              <tr>
                <td>32 bit</td>
                <td>i32</td>
                <td>u32</td>
              </tr>
              <tr>
                <td>64 bit</td>
                <td>i64</td>
                <td>u64</td>
              </tr>
              <tr>
                <td>128 bit</td>
                <td>i128</td>
                <td>u128</td>
              </tr>
              <tr>
                <td>arch</td>
                <td>isize</td>
                <td>usize</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Числовые литералы:</caption>
            <tbody>
              <tr>
                <td>Десятиричный</td>
                <td>98222</td>
              </tr>
              <tr>
                <td>Шестнадцатиричный</td>
                <td>Oxff</td>
              </tr>
              <tr>
                <td>Восьмиричный</td>
                <td>0o77</td>
              </tr>
              <tr>
                <td>Двоичный</td>
                <td>0b11110000</td>
              </tr>
              <tr>
                <td>Байт (только u8)</td>
                <td>b'A'</td>
              </tr>
            </tbody>
          </table>
          <p>Литералы char в одинарных кавычках:</p>
          <pre><code>let c = 'Z';
let z:char = 'Z';
</code></pre>
          <p>Сложные типы данных: кортежи и массивы, могут группировать несколько значений в один тип.</p>
          <pre><code>// Кортеж: группировка нескольких значений различного типа в единый комбинированный тип фиксированной длины.
Let tup: (i32, f64, u8) = (500, 6.4, 1);

// деструктуризация
let (x,y,z) = tup;

// обращение к элементу кортежа по индексу
let five_hundred = tup.0;
</code></pre>
          <p>unit - обозначается () и представляет собой пустое значение или пустой возвращаемый тип.</p>
          <pre><code>// Игнорирование нескольких частей кортежа
fn main() {
  let numbers = (2, 4, 8, 16, 32);
  match numbers {
    (first, _, third, _, fifth) => {
      println!("Some numbers: {first}, {third}, {fifth}")
    }}};
</code></pre>
          <p>Игнорирование оставшихся частей значения с помощью одной точки.</p>
          <pre><code>// Игнорирование полей структуры Point кроме поля x с помощью двух точек.
fn main() {
  struct Point {
    x: i32,
    y: i32,
    z: i32,
  }
let origin = Point { x: 0, y: 0, z: 0 };
  match origin {
    Point { x, .. } => println!("x is {}", x),
  }
}

// Сопоставление только первого и последнего значений в кортеже и игнорирование всех других значений
fn main() {
  let numbers = (2, 4, 8, 16, 32);
  match numbers {
    (first, .., last) => {
      println!("Some numbers: {first}, {last}");
    }
  }
}
</code></pre>
          <p>Массивы: набор значений одного типа и фиксированной длины.</p>
          <pre><code>let a = [1, 2, 3, 4, 5];

// тип и длина [i32; 5]
let a: [i32; 5] = [1, 2, 3, 4, 5];

let a = [3; 5];
// получим массив
let a = [3, 3, 3, 3, 3];

// доступ к элементам массива
let first = a [0];
</code></pre>
          <ul>
            <li>Вектор - аналогичный массиву тип коллекции без фиксированной величины.</li>
            <li>String - строковый тип управляет данными, выделенными в куче, и поэтому может хранить объем текста, который во время компиляции не известен.</li>
            <li>Типы, размер которых известен во время компиляции, полностью хранятся в стеке и быстро копируются.</li>
            <li>Для указателей на данные в куче происходит перемещение.</li>
            <li>Для создания копии данных в куче происходит клонирование.</li>
            <li>За копирование типа отвечает типаж Copy.</li>
            <li>Он анотирован для типов хранящихся в стеке.</li>
            <li>Типаж Copy не совместим с типажем Drop и типами, которые хранятся в куче.</li>
            <li>Структура (struct) - пользовательский тип данных, позволяющий назвать и упаковать вместе несколько связанных значений, составляющих значимую логическую группу.</li>
            <li>Похоже на атрибуты данных объекта.</li>
            <li>Структура, как и кортежи, это способы группировки данных.</li>
            <li>Каждая часть данных структуры имеет имя и свой тип, типы могут быть разные.</li>
            <li>Каждая пара “имя: тип” называется полем.</li>
            <li>Объявление структуры - это шаблон нашего типа, а экземпляр использует этот шаблон, заполняя его данными.</li>
          </ul>
          <pre><code>struct User {
  active: bool,
  username: String,
  email: String,
  sign_in_count: u64,
}

// Создание экземпляра структуры User:
let user1 = User {
  email: String::from (“someone@example.com”),
  username: String::from (“someusername123”),
  active: true,
  sign_in_count: 1,
};

// Доступ к полю через точку: user1.email
User {
  email: email,
  username: username,
  active: true,
  sign_in_count: 1,
}

// тоже самое
User {
  email,
  username,
  active: true,
  sign_in_count: 1,
}
</code></pre>
          <p>Синтаксис .. указывает, что оставшиеся поля устанавливаются неявно и должны иметь значения из указанного экземпляра:</p>
          <pre><code>let user2 = User {
  email: String::from (“another@example.com”),
  ..user1
};
</code></pre>
          <p>..user1 должен стоять последним для указания на получение значений всех оставшихся полей из соответствующих полей в user1.</p>
          <table>
            <caption>Кортежные структуры - именованные кортежи:</caption>
            <tbody>
              <tr>
                <td>struct Color (i32, i32, i32);</td>
                <td>картежная структура</td>
              </tr>
              <tr>
                <td>let black = color (0, 0, 0);</td>
                <td>экземпляр типа color</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Экземпляры кортежных структур можно как кортежи деструктурировать и использовать точку с индексом для доступа к значению.</li>
            <li>Единично-подобные структуры - структуры, которые не имеют полей. Требуются когда нужно реализовать типаж для типа, но нет данных, которые нужно хранить в типе: *struct AlwaysEqual;*</li>
            <li>По умолчанию фигурные скобки в println! означают использование форматирования, известного как типаж Display.</li>
            <li>Структуры не имеют встроенной реализации Display, поэтому можно распечатать в *Debug:println! ({:?})*.</li>
            <li>Макрос dbg! распечатывает значение в формате Debug. Для этого нужно подключить атрибут derive: # [derive(Debug)]</li>
            <li>Структуры создают типы, позволяют хранить связанные данные и давать названия частям данных.</li>
            <li>Методы позволяют определить поведение экземпляров структур, а ассоциированные функции привязывают функциональность к вашей структуре, не обращаясь к её экземпляру.</li>
            <li>Метод - поведение экземпляра</li>
            <li>Ассоциированная функция - поведение структуры</li>
            <li>Перечисления (enumerations, enums) дают способ сказать, что значение является одним из возможных наборов значений, структура данных enum.</li>
            <li>В любой из вариантов перечисления можно поместить данные.</li>
            <li>Каждый вариант перечисления (V4, V6) - это функция, которая создаёт экземпляр перечисления, т.е. принимает String и возвращает экземпляр типа IpAddr, это функция-конструктор.</li>
            <li>В отличии от структуры (struct) перечисление (enum) может иметь разное количество данных в разных типах, можно включать перечисления в другие перечисления.</li>
            <li>С помощью impl блока, мы можем определять методы для перечисления.</li>
          </ul>
          <pre><code>enum IpAddr {
  V4(String),
  V6(String),
}
let home = IpAddr::V4(String::from(“127.0.0.1”));
let loopback = IpAddr::V6(String::from(“ : :1”));

enum IpAddr {
  V4(u8, u8, u8, u8),
  V6(String),
}
let home = IpAddr::V4(String::from(“127.0.0.1”));
let loopback = IpAddr::V6(String::from(“ : :1”));
</code></pre>
          <p>Тип Option кодирует сценарий, в котором значение может быть чем-то, а может быть ничем.</p>
          <pre><code>enum Option < T> {
  None,
  Some (T),
}</code></pre>
          <ul>
            <li>Нужно познакомиться с методами перечисления Option &lt; T&gt; в документации.</li>
            <li>Перечисление Option &lt; T&gt; и его варианты Some и None включены в прелюдию.</li>
            <li>Поэтому Option не нужно вводить в область видимости, а Some и None используем без префикса Option::.</li>
            <li>Чтобы иметь значение, которое может быть null его тип нужно явно описать с помощью Option &lt; T&gt; и явно обрабатывать случай, когда значение равно null.</li>
            <li>Значение может быть равно null только имея тип Option &lt; T&gt;, в остальных случаях (с другими типами) значение всегда not-null.</li>
            <li>Если использовать pub перед определением структуры, то это делает структуру публичной, но поля этой структуры остаются приватными.</li>
            <li>Чтобы поле структуры стало публичным добавляем pub.</li>
            <li>Если сделать перечисление общедоступным pub enum, то все его варианты будут общедоступными.</li>
            <li>Коллекция хранит множество однотипных значений в куче, т.е. размер коллекции может быть не известен в момент компиляции, может изменяться в размере во время работы программы.</li>
          </ul>
          <table>
            <caption>Каждый вид коллекции имеет свои возможности:</caption>
            <tbody>
              <tr>
                <td>Вектор (Vector)</td>
                <td>сохраняет различное количество последовательно хранящихся значений.</td>
              </tr>
              <tr>
                <td>Строка (String)</td>
                <td>последовательность символов.</td>
              </tr>
              <tr>
                <td>Хеш-таблица (hash map)</td>
                <td>коллекция, которая позволяет хранить перечень ассоциаций значения с ключом (перечень пар ключ: значение).</td>
              </tr>
            </tbody>
          </table>
          <p>Коллекция вектор (vector): Vec< T></p>
          <pre><code>// Создание пустого вектора для хранения значений типа i32:
let v: Vec< i32> = Vec::new();
</code></pre>
          <p>Макрос vec! - создает новый вектор.</p>
          <pre><code>// новый вектор целочисленного типа i32 со значениями 1, 2, 3
let v = vec![1, 2, 3];

// Создать новый вектор и добавить значения:
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);

// Доступ к элементу вектора
v.[2]          // индекс (нумерация индексов с 0)
v.get(2)       // метод get, получаем тип Option<&T></code></pre>
          <p>
            При обращении по индексу за пределами вектора, произойдет паника.<br/>
            При обращении к индексу за пределами вектора через get - вернется None без паники.
          </p>
          <pre><code>// Получение неизменяемых ссылок на каждый элемент в векторе
let v = vec![100, 32, 57];
for i in &v {
  println!("{}", i);
}

// Добавление к каждому элементу вектора:
let mut v = vec![100, 32, 57];
for i in &mut v {

  // получение значения переменной i с помощью оператора разыменовывания ссылки *
  *i += 50;}
</code></pre>
          <ul>
            <li>Строки (String) реализованы в виде набора байтов.</li>
            <li>В Rust есть только один строковый тип в ядре языка - срез строки &amp;str.</li>
            <li>Тип String предоставляется стандартной библиотекой.</li>
            <li>И String и строковые срезы &amp;str кодируются в UTF-8.</li>
            <li>String фактически реализован как обертка вокруг вектора байтов.</li>
            <li>СТАНДАРТНУЮ БИБЛИОТЕКУ ВЫУЧИТЬ!!!</li>
            <li>Индексирование строк это плохая идея, т.к. не ясно каким должен быть возвращаемый тип такой операции:</li>
            <li>байтовым значением (код UTF-8), символом (char), кластером графем или срезом строки.</li>
            <li>Коллекция hash map (хеш карта).</li>
            <li>Тип HashMap &lt;K, V&gt; хранит ключ типа К на значение типа V.</li>
            <li>Организует и хранит данные с помощью функции хеширования.</li>
            <li>Как и векторы, HashMap однородны: все ключи должны иметь одинаковый тип и все значения должны иметь одинаковый тип.</li>
            <li>По умолчанию HashMap использует функцию хеширования SipHach, который может противостоять Dos-атакам с использованием таблиц siphash.</li>
            <li>Обобщённые типы данных generics - это абстрактные подставные типы на место которых возможно поставить какой-либо конкретный тип или другое свойство.</li>
          </ul>
          <pre><code>(Option< T>, Vec< T>, HashMap< K, V>, Result< T, E>)</code></pre>
          <p>Мы используем обобщённые типы данных для объявления функций или структур, которые затем можно использовать с различными конкретными типами данных.</p>
          <pre><code>fn largest< T>(list: &[T]) -> &T {}</code></pre>
          <ul>
            <li>Объявление читается так: функция largest является обобщённой по типу T.</li>
            <li>Эта функция имеет один параметр с именем list, который является срезом значений с типом данных T.</li>
            <li>Функция largest возвращает значение этого же типа T.</li>
            <li>Синтаксис использования обобщённых типов в определении структуры такой же как у функции.</li>
            <li>Объявляем имена типов параметров внутри треугольных скобок сразу после названия структуры.</li>
            <li>Мы также можем определить структуры, использующие обобщённые типы в одном или нескольких своих полях, с помощью синтаксиса &lt;&gt;.</li>
            <li>Поля структуры с обобщенным типом имеют одинаковый тип, каким бы он не являлся.</li>
            <li>Чтобы определить структуру Point, где оба значения x и y являются обобщёнными, но различными типами, можно использовать несколько параметров обобщённого типа.</li>
            <li>Определение методов может использовать обобщённые типы: impl&lt; T&gt; Point&lt; T&gt; {}</li>
            <li>Мономорфизация — это процесс превращения обобщённого кода в конкретный код путём подстановки конкретных типов, использующихся при компиляции.</li>
            <li>&lt; Т&gt; - обопщенный тип.</li>
            <li>Bы можете реэкспортировать элементы, чтобы сделать публичную структуру, отличную от вашей внутренней структуры, используя pub use.</li>
            <li>Box&lt; T&gt; для распределения значений в куче (памяти).</li>
            <li>Rc&lt; T&gt; тип счётчика ссылок, который допускает множественное владение.</li>
            <li>Типы Ref&lt; T&gt; и RefMut&lt; T&gt;, доступ к которым осуществляется через тип RefCell&lt; T&gt;, который обеспечивает правила заимствования во время выполнения вместо времени компиляции.</li>
            <li>Тип Box&lt; T&gt; является умным указателем, поскольку он реализует трейт *Deref*, который позволяет обрабатывать значения Box&lt; T&gt; как ссылки. Когда значение Box&lt; T&gt; выходит из области видимости, данные кучи, на которые указывает box, также очищаются благодаря реализации типажа Drop.</li>
            <li>Устанавливаем y как экземпляр Box&lt; T&gt;, указывающий на скопированное значение x, а не как ссылку, указывающую на значение x.</li>
            <li>Без типажа Deref компилятор может только разыменовывать &amp; ссылки.Метод deref даёт компилятору возможность принимать значение любого типа, реализующего Deref и вызывать метод deref чтобы получить ссылку &amp;, которую он знает, как разыменовывать.</li>
            <li>Когда типаж Deref определён для задействованных типов, Rust проанализирует типы и будет использовать Deref::deref столько раз, сколько необходимо, чтобы получить ссылку, соответствующую типу параметра.</li>
          </ul>
          <pre><code>struct Point< T, U> {
  x: T,
  y: U,
}
</code></pre>
          <p>Rust выполняет разыменованное приведение, когда находит типы и реализации типажей в трёх случаях:</p>
          <ul>
            <li>Из типа &amp;T в тип &amp;U когда верно T: Deref&lt;Target=U&gt;</li>
            <li>Из типа &amp;mut T в тип &amp;mut U когда верно T: DerefMut&lt;Target=U&gt;</li>
            <li>Из типа &amp;mut T в тип &amp;U когда верно T: Deref&lt;Target=U&gt;</li>
          </ul>
          <ul>
            <li>Rust также приводит изменяемую ссылку к неизменяемой.</li>
            <li>Но обратное не представляется возможным: неизменяемые ссылки никогда не приводятся к изменяемым ссылкам.</li>
            <li>*Drop* позволяет регулировать, что происходит, когда значение вот-вот выйдет из области видимости.</li>
            <li>Тело функции drop - это место, где должна располагаться вся логика, которую вы захотите выполнять, когда экземпляр вашего типа выйдет из области видимости.</li>
            <li>Rust автоматически вызывал функцию drop в момент выхода наших экземпляров из области видимости, тем самым выполнив заданный нами в drop код.</li>
            <li>Переменные ликвидируются в обратном порядке их создания.</li>
            <li>Rust не позволяет вызвать метод типажа Drop вручную; вместо этого вы должны вызвать функцию *std::mem::drop* предоставляемую стандартной библиотекой, если хотите принудительно удалить значение до конца области видимости.</li>
            <li>Тип Rc&lt; T&gt; отслеживает количество ссылок на значение, чтобы определить, используется ли оно ещё.</li>
            <li>Если ссылок на значение нет, значение может быть очищено и при этом ни одна ссылка не станет недействительной.</li>
            <li>Тип Rc&lt; T&gt; используется, когда мы хотим разместить в куче некоторые данные для чтения несколькими частями нашей программы и не можем определить во время компиляции, какая из частей завершит использование данных последней.</li>
            <li>Обратите внимание, что Rc&lt; T&gt; используется только в одно поточных сценариях.</li>
            <li>Вызов *Rc::clone* только увеличивает счётчик ссылок, что не занимает много времени.</li>
            <li>Внутренняя изменяемость - это паттерн проектирования Rust, который позволяет вам изменять данные даже при наличии неизменяемых ссылок на эти данные; обычно такое действие запрещено правилами заимствования.</li>
            <li>RefCell&lt; T&gt; предоставляет единоличное владение данными, которые он содержит.</li>
            <li>С помощью ссылок и типа Box&lt; T&gt; инварианты правил заимствования применяются на этапе компиляции.</li>
            <li>С помощью RefCell&lt; T&gt; они применяются во время работы программы.</li>
            <li>Тип RefCell&lt; T&gt; полезен, когда вы уверены, что ваш код соответствует правилам заимствования, но компилятор не может понять и гарантировать этого.</li>
          </ul>
          <table>
            <caption>Вот список причин выбора типов Box< T>, Rc< T> или RefCell< T>:</caption>
            <tbody>
              <tr>
                <td>Тип Rc< T></td>
                <td>разрешает множественное владение одними и теми же данными; типы Box< T> и RefCell< T> разрешают иметь единственных владельцев.</td>
              </tr>
              <tr>
                <td>Тип Box< T></td>
                <td>разрешает неизменяемые или изменяемые владения, проверенные при компиляции;</td>
              </tr>
              <tr>
                <td>тип Rc< T></td>
                <td>разрешает только неизменяемые владения, проверенные при компиляции;</td>
              </tr>
              <tr>
                <td>тип RefCell< T></td>
                <td>разрешает неизменяемые или изменяемые владения, проверенные во время выполнения.</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Поскольку RefCell&lt; T&gt; разрешает изменяемые заимствования, проверенные во время выполнения, можно изменять значение внутри RefCell&lt; T&gt; даже если RefCell&lt; T&gt; является неизменным.</li>
            <li>Изменение значения внутри неизменного значения является шаблоном внутренней изменяемости (interior mutability).</li>
            <li>Инсценированные (*Mock*) объекты - это особый тип тестовых дублёров, которые сохраняют данные происходящих во время теста действий тем самым позволяя вам убедиться впоследствии, что все действия были выполнены правильно.</li>
            <li>Вызвать образование ссылочной зацикленности не просто, но и не невозможно.</li>
            <li>Если у вас есть значения RefCell&lt; T&gt; которые содержат значения Rc&lt; T&gt; или аналогичные вложенные комбинации типов с внутренней изменчивостью и подсчётом ссылок, вы должны убедиться, что вы не создаёте зацикленность.</li>
          </ul>
          <table>
            <tbody>
              <tr>
                <td>Тип Box< T></td>
                <td>имеет известный размер и указывает на данные размещённые в куче.</td>
              </tr>
              <tr>
                <td>Тип Rc< T></td>
                <td>отслеживает количество ссылок на данные в куче, поэтому данные могут иметь несколько владельцев.</td>
              </tr>
              <tr>
                <td>Тип RefCell< T></td>
                <td>с его внутренней изменяемостью предоставляет тип, который можно использовать при необходимости неизменного типа, но необходимости изменить внутреннее значение этого типа; он также обеспечивает соблюдение правил заимствования во время выполнения, а не во время компиляции.</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Mutex - это сокращение от взаимное исключение (mutual exclusion), так как мьютекс позволяет только одному потоку получать доступ к некоторым данным в любой момент времени.</li>
            <li>Для того, чтобы получить доступ к данным в мьютексе, поток должен сначала подать сигнал, что он хочет получить доступ запрашивая блокировку (lock) мьютекса.</li>
            <li>Блокировка - это структура данных, являющаяся частью мьютекса, которая отслеживает кто в настоящее время имеет эксклюзивный доступ к данным.</li>
            <li>Поэтому мьютекс описывается как объект защищающий данные, которые он хранит через систему блокировки.</li>
            <li>Mutex&lt; T&gt; является умным указателем, точнее, вызов lock возвращает умный указатель, называемый MutexGuard, обёрнутый в LockResult, который мы обработали с помощью вызова unwrap.</li>
            <li>Умный указатель типа MutexGuard реализует типаж Deref для указания на внутренние данные;</li>
            <li>умный указатель также имеет реализацию типажа Drop, автоматически снимающего блокировку, когда MutexGuard выходит из области видимости.</li>
            <li>Arc&lt; T&gt; является типом аналогичным типу Rc&lt; T&gt;, который безопасен для использования в ситуациях многопоточности.</li>
            <li>Буква А означает атомарное, что означает тип ссылка подсчитываемая атомарно.</li>
            <li>Atomics - работают как примитивные типы, но безопасны для совместного использования между потоками: дополнительную информацию смотрите в документации стандартной библиотеки для *std::sync::atomic*.</li>
            <li>Cтандартные типы библиотек не реализованы для использования вместе с типом Arc&lt; T&gt; по умолчанию.</li>
            <li>Причина в том, что безопасность потоков сопровождается снижением производительности.</li>
            <li>типы Arc&lt; T&gt; и Rc&lt; T&gt; имеют одинаковый API.</li>
            <li>Mutex&lt; T&gt; сопряжён с риском создания взаимных блокировок (deadlocks).</li>
            <li>Это происходит, когда операции необходимо заблокировать два ресурса и каждый из двух потоков получил одну из блокировок, заставляя оба потока ждать друг друга вечно.</li>
            <li>В язык встроены две концепции многопоточности: *std::marker* типажи Sync и Send.</li>
            <li>Маркерный типаж Send указывает, что владение типом реализующим Send, может передаваться между потоками.</li>
            <li>Почти каждый тип Rust является типом Send, но есть некоторые исключения, вроде Rc&lt; T&gt;:</li>
            <li>он не может быть Send, потому что если вы клонировали значение Rc&lt; T&gt;</li>
            <li>и попытались передать владение клоном в другой поток, оба потока могут обновить счётчик ссылок одновременно.</li>
            <li>По этой причине Rc&lt; T&gt; реализован для использования в однопоточных ситуациях, когда вы не хотите платить за снижение производительности.</li>
            <li>Маркерный типаж Sync указывает, что на тип реализующий Sync можно безопасно ссылаться из нескольких потоков.</li>
            <li>Другими словами, любой тип T является типом Sync, если &amp;T (ссылка на T) является типом Send, что означает что ссылку можно безопасно отправить в другой поток.</li>
            <li>Подобно Send, примитивные типы являются типом Sync, а типы полностью скомбинированные из типов Sync, также являются Sync типом.</li>
            <li>Умный указатель Rc&lt; T&gt; не является Sync типом по тем же причинам, по которым он не является Send.</li>
            <li>Тип RefCell&lt; T&gt; и семейство связанных типов Cell&lt; T&gt; не являются Sync.</li>
            <li>Этот код позволяет нам разбивать сложные типы на составные части, чтобы мы могли использовать интересующие нас значения по отдельности.</li>
            <li>Деструктуризация с помощью шаблонов - это удобный способ использования фрагментов значений, таких как как значение из каждого поля в структуре, по отдельности друг друга.</li>
            <li>Ассоциированные типы (*Associated types*) связывают заполнитель типа с типажом, таким образом, что объявления методов типажа могут использовать эти заполнители типов в своих сигнатурах.</li>
            <li>С ассоциированными типами не нужно аннотировать типы, потому что мы не можем реализовать типаж у типа несколько раз.</li>
            <li>Тип по умолчанию указывается при объявлении обобщённого типа с помощью синтаксиса &lt;PlaceholderType=ConcreteType&gt;.</li>
            <li>Rust не позволяет создавать собственные операторы или перегружать произвольные операторы.</li>
            <li>Но можно перегрузить перечисленные операции и соответствующие им типажи из *std::ops* путём реализации типажей, связанных с этими операторами.</li>
          </ul>
          <pre><code>// Integer addition
assert!(1u32 + 2u32 == 3u32);

// Integer subtraction
assert!(1i32 - 2 == -1);
assert!(1i32 - 2 == -1); 
assert!(3 * 50 == 150);
assert!(9.6f32 / 3.2f32 == 3.0);
assert!(24 % 5 == 4);

// Short-circuiting boolean logic
assert!(true && false == false);
assert!(true || false == true);
assert!(!true == false);
</code></pre>
          <table>
            <caption>Function</caption>
            <tbody>
              <tr>
                <td>fn</td>
                <td>объявление функции</td>
              </tr>
              <tr>
                <td>fn main ( ) { }</td>
                <td>точка входа в программу</td>
              </tr>
              <tr>
                <td>fn another_function ( );</td>
                <td>определение функции</td>
              </tr>
              <tr>
                <td>another_function ( );</td>
                <td>вызов функции</td>
              </tr>
              <tr>
                <td>another_function (5);</td>
                <td>вызов функции с передачей значения “5” как аргумент функции</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// Объявлять тип каждого параметра сигнатуры функции обязательно:
fn another_function (valu: i32, label: char) { };
</code></pre>
          <p>Методы как и функции:</p>
          <ul>
            <li>ключевое слово fn</li>
            <li>имеют параметры и возвращаемое значение</li>
            <li>содержат код, который выполняется при вызове</li>
            <li>Методы - это функции, которые определяются в контексте структуры.</li>
            <li>Первый параметр метода всегда self - экземпляр структуры, на который вызывается метод.</li>
          </ul>
          <pre><code>impl Rectangle {
  fn area (&self) -> u32 (
    self.width * self.height
  }}
</code></pre>
          <ul>
            <li>Создание блока impl (implementation - реализация) определяет функцию area в контексте типа Rectangle.</li>
            <li>rect1.area() - вызов метода area на экземпляре rect1 типа Rectangle.</li>
            <li>Всё, что хотим сделать с экземпляром типа, помещаем в один блок impl.</li>
            <li>Методу можно давать имя такое же как и у поля структуры.</li>
            <li>Отличие в обращении - это наличие круглых скобок у метода.</li>
            <li>Как правило, метод с таким же именем как у поля возвращает значение этого поля.</li>
            <li>Такие методы называются геттерами.</li>
            <li>Все функции определенные в блоке impl, называются ассоциированными функциями, потому что они ассоциированы с типом, указанным после ключевого слова impl.</li>
            <li>Можно определить ассоциированные функции без self в качестве первого параметра.</li>
            <li>Такие функции не являются методами и их часто используют для конструкторов, возвращающих новый экземпляр структуры.</li>
            <li>Вызвать ассоциированную функцию можно через ::.</li>
          </ul>
          <table>
            <tbody>
              <tr>
                <td>::</td>
                <td>это синтаксис для обращения к ассоциированным функциям и к пространству имен, созданное модулем</td>
              </tr>
              <tr>
                <td>Ассоциированная функция</td>
                <td>в блоке impl</td>
              </tr>
              <tr>
                <td>Ассоциированная функция в контексте структуры</td>
                <td>метод</td>
              </tr>
              <tr>
                <td>Ассоциированная функция без параметра self</td>
                <td>конструктор</td>
              </tr>
              <tr>
                <td>Замыкания</td>
                <td>конструкции, подобные функциям, которые можно помещать в переменные</td>
              </tr>
            </tbody>
          </table>
          <p>
            Замыкания в Rust - это анонимные функции, которые "захватывают" своё окружение и их можно сохранять в переменных или передавать в качестве аргументов другим функциям.<br/>
            В отличие от функций, замыкания могут использовать значения из области видимости в которой они были определены.
          </p>
          <pre><code>fn giveaway(&self, user_preference: Option< ShirtColor>) -> ShirtColor {
  user_preference.unwrap_or_else(|| self.most_stocked())
}</code></pre>
          <table>
            <tbody>
              <tr>
                <td>|| self.most_stocked()</td>
                <td>замыкание</td>
              </tr>
              <tr>
                <td>||</td>
                <td>между вертикальными линиями указываются параметры</td>
              </tr>
              <tr>
                <td>self.most_stocked()</td>
                <td>тело замыкания</td>
              </tr>
            </tbody>
          </table>
          <p>Замыкания, как правило, короткие и уместны только в узком контексте, а не в произвольном сценарии.</p>
          <table>
            <caption>Определение функции и замыкания:</caption>
            <tbody>
              <tr>
                <td>fn add_one_v1 (x: u32) -> u32 { x + 1 }</td>
                <td>функция</td>
              </tr>
              <tr>
                <td>let add_one_v2 = |x: u32| -> u32 { x + 1 };</td>
                <td>замыкание с полной аннотацией</td>
              </tr>
              <tr>
                <td>let add_one_v3 = |x| { x + 1 };</td>
                <td>замыкание без аннотации типа</td>
              </tr>
              <tr>
                <td>let add_one_v4 = |x| x + 1 ;</td>
                <td>в теле замыкания одна операция, скобки не нужны.</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Строки add_one_v3 и add_one_v4 требуют, чтобы замыкания были вычислены до компиляции, поскольку типы будут выведены из их использования.</li>
            <li>Замыкания могут захватывать значения из своего окружения тремя способами, которые соответствуют тем же трём способам, которыми функция может принимать параметры: заимствование неизменяемых, заимствование изменяемых и получение владения.</li>
            <li>Замыкание самостоятельно определяет, какой из этих способов использовать, исходя из того, что тело функции делает с полученными значениями.</li>
            <li>Если вы хотите заставить замыкание принять владение значениями, которые оно использует в окружении, даже если в теле замыкания нет кода, требующего владения, вы можете использовать ключевое слово move перед списком параметров.</li>
            <li>Замыканиям автоматически присваивается реализация одного, двух или всех трёх из нижеперечисленных трейтов Fn, аддитивным образом, в зависимости от того, как тело замыкания обрабатывает значения:</li>
            <li>FnOnce применяется к замыканиям, которые могут быть вызваны один раз.</li>
            <li>Все замыкания реализуют по крайней мере этот трейт, потому что все замыкания могут быть вызваны.</li>
            <li>Замыкание, которое перемещает захваченные значения из своего тела, реализует только FnOnce и ни один из других признаков Fn, потому что оно может быть вызвано только один раз.</li>
            <li>FnMut применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но могут изменять захваченные значения.</li>
            <li>Такие замыкания могут вызываться более одного раза.</li>
            <li>Fn применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не модифицируют захваченные значения, а также к замыканиям, которые ничего не захватывают из своего окружения.</li>
            <li>Такие замыкания могут выполняться более одного раза и не меняют ничего в своём окружении, что важно в таких случаях, как одновременный вызов замыкания несколько раз.</li>
            <li>Трейты Fn важны при определении или использовании функций или типов, использующих замыкания.</li>
            <li>Итераторы — способ обработки последовательности элементов.</li>
            <li>Использование паттерна Итератор помогает при необходимости поочерёдного выполнения какой-либо операции над элементами последовательности.</li>
            <li>Итератор отвечает за логику перебора элементов и определение момента завершения последовательности.</li>
            <li>Все итераторы реализуют типаж Iterator, который определён в стандартной библиотеке.</li>
            <li>Метод iter создаёт итератор по неизменяемым ссылкам.</li>
            <li>Если мы хотим создать итератор, который становится владельцем v1 и возвращает принадлежащие ему значения, мы можем вызвать into_iter вместо iter.</li>
            <li>Точно так же, если мы хотим перебирать изменяемые ссылки, мы можем вызвать iter_mut вместо iter.</li>
            <li>Методы, вызывающие next, называются потребляющими адаптерами, поскольку их вызов потребляет итератор.</li>
            <li>*Адаптеры итераторов* - это методы, определённые для трейта Iterator, которые не потребляют итератор.</li>
            <li>Вместо этого они создают различные итераторы, изменяя некоторые аспекты исходного итератора.</li>
            <li>В Rust итераторы ленивые (lazy), то есть они не делают ничего, пока вы не вызовете специальные методы, потребляющие итератор, чтобы задействовать его.</li>
            <li>Вы можете выстроить цепочку из нескольких вызовов адаптеров итератора для выполнения сложных действий в удобочитаемом виде.</li>
            <li>Но поскольку все итераторы являются 'ленивыми', для получения результатов вызовов адаптеров итератора необходимо вызвать один из методов потребляющего адаптера.</li>
            <li>Разворачивание - это оптимизация, которая устраняет издержки кода управления циклом и вместо этого генерирует повторяющийся код для каждой итерации цикла.</li>
            <li>Реализации замыканий (closures) и итераторов (iterators) таковы, что нет влияния на производительность выполнения кода.</li>
            <li>Это одна из целей Rust, направленных на обеспечение абстракций с нулевой стоимостью (zero-cost abstractions).</li>
            <li>Чтобы создать новый поток, мы вызываем функцию thread::spawn и передаём ей замыкание, содержащее код, который мы хотим запустить в новом потоке.</li>
            <li>Вызовы thread::sleep заставляют поток на короткое время останавливать своё выполнение, позволяя выполняться другим потокам.</li>
            <li>Тип возвращаемого значения thread::spawn — JoinHandle.</li>
            <li>JoinHandle — это владеющее значение, которое, при вызове метода join, будет ждать завершения своего потока.</li>
            <li>Мы будем часто использовать ключевое слово move с замыканиями, переданными в thread::spawn, потому что замыкание будет затем владеть значениями, взятыми из окружающего кода, а значит передаст владение этими значениями от одного потока к другому.</li>
            <li>Добавляя ключевое слово move перед замыканием, мы заставляем замыкание забирать используемые значения во владение, вместо того, чтобы позволить Rust вывести необходимость заимствования значения.</li>
            <li>Игнорирование значений в шаблоне.</li>
            <li>Есть несколько способов игнорировать целые значения или части значений в шаблоне:</li>
            <li>используя нижнее подчеркивание внутри другого шаблона, используя имя, начинающееся с подчёркивания, либо используя .., чтобы игнорировать оставшиеся части значения.</li>
          </ul>
          <pre><code>// Игнорирование всего значения с помощью шаблона _
fn foo(_: i32, y: i32) {
  println!("This code only uses the y parameter: {}", y);
}

fn main() {
  foo(3, 4);
}
</code></pre>
          <ul>
            <li>Игнорирование параметра функции может быть особенно полезно в случаях когда, например, вы реализуете типаж с определённой сигнатурой, но тело функции в вашей реализации не нуждается в одном из параметров.</li>
            <li>Игнорирование частей значения с помощью вложенного _</li>
            <li>Использование подчёркивания в шаблонах, соответствующих вариантам Some, когда нам не нужно использовать значение внутри Some</li>
          </ul>
          <pre><code>fn main() {
  let mut setting_value = Some(5);
  let new_setting_value = Some(10);
  match (setting_value, new_setting_value) {
    (Some(_), Some(_)) => {
      println!("Can't overwrite an existing customized value");
    }
    _ => {
      setting_value = new_setting_value;
    }
  }
  println!("setting is {:?}", setting_value);
}
</code></pre>
          <p>Бизнес-требования заключаются в том, что пользователь не должен иметь права перезаписывать существующую настройку параметра, но может сбросить параметр и присвоить ему значение, если он в данный момент не установлен.</p>
          <h2>Operator</h2>
          <table>
            <tbody>
              <tr>
                <td>Операторы</td>
                <td>это инструкции, которые выполняют действие и не возвращают значение.</td>
              </tr>
              <tr>
                <td>Выражения</td>
                <td>вычесляют результирующее значение.</td>
              </tr>
              <tr>
                <td>{ }</td>
                <td>создают область видимости (scope)</td>
              </tr>
              <tr>
                <td>let</td>
                <td>это оператор</td>
              </tr>
              <tr>
                <td>fn</td>
                <td>это оператор</td>
              </tr>
              <tr>
                <td>let y = 6;</td>
                <td>оператор</td>
              </tr>
              <tr>
                <td>6</td>
                <td>выражение</td>
              </tr>
              <tr>
                <td>;</td>
                <td>окончание оператора</td>
              </tr>
              <tr>
                <td>fn main ( ) {let y = 6;}</td>
                <td>оператор</td>
              </tr>
              <tr>
                <td>{let y = 6;}</td>
                <td>выражение</td>
              </tr>
            </tbody>
          </table>
          <p>
            Вызов функции, вызов макроса - это выражение.<br/>
            Если добавить точку с запятой в конец выражения, то оно превратится в оператор и не вернет значение.
          </p>
          <table>
            <tbody>
              <tr>
                <td>fn five ( ) -> i32 {5}</td>
                <td>функция возвращает значение.</td>
              </tr>
              <tr>
                <td>-> i32 {5}</td>
                <td>объявляет тип возвращаемого значения.</td>
              </tr>
              <tr>
                <td>//</td>
                <td>комментарий только однострочный</td>
              </tr>
            </tbody>
          </table>
          <p>
            Область видимости - это диапазон внутри программы, для которого допустим элемент.<br/>
            Когда переменная появляется в области видимости, она считается действительной до момента выхода за границы этой области.
          </p>
          <pre><code>// создать String из строкового литерала
// Оператор :: позволяет использовать пространство имен функции from под типом String
let s = String::from(“hello”);
</code></pre>
          <p>Связанное понятие - это область видимости: вложенный контекст в котором написан код имеющий набор имён, которые определены "в текущей области видимости".</p>
          <pre><code>// Оператор glob "*" - включает в область видимости все общедоступные элементы, определенные в пути:
use std::collections::*;
</code></pre>
          <ul>
            <li>Сокращение для проброса ошибок: оператор ?</li>
            <li>Оператор ? может использоваться только в функциях, тип возвращаемого значения которых совместим со значением, для которого используется ?.</li>
            <li>Исполняемые файлы, написанные на C, при выходе возвращают целые числа: успешно завершённые программы возвращают целое число 0, а программы с ошибкой возвращают целое число, отличное от 0.</li>
            <li>Rust также возвращает целые числа из исполняемых файлов, чтобы быть совместимым с этим соглашением.</li>
          </ul>
          <pre><code>0011 AND 0101 is 0001
0011 OR 0101 is 0111
0011 XOR 0101 is 0110
1 << 5 is 32
0x80 >> 2 is 0x20
</code></pre>
          <h2>if & match</h2>
          <p>Условие всегда типа bool:</p>
          <table>
            <caption>if number < 5 {println!(“Hi!”);} else {println!(“Buy”);}</caption>
            <tbody>
              <tr>
                <td>if</td>
                <td>выражение</td>
              </tr>
              <tr>
                <td>number < 5</td>
                <td>условие</td>
              </tr>
              <tr>
                <td>{println!(“Hi!”);}</td>
                <td>ответвление</td>
              </tr>
              <tr>
                <td>println!(“Hi!”);</td>
                <td>макрос</td>
              </tr>
              <tr>
                <td>else</td>
                <td>выражение</td>
              </tr>
              <tr>
                <td>{println!(“Buy”);}</td>
                <td>ответвление</td>
              </tr>
              <tr>
                <td>println!(“Buy”);</td>
                <td>макрос</td>
              </tr>
            </tbody>
          </table>
          <p>По очереди проверяется каждое выражение if и выполняется первое тело, для которого условие истина, остальные блоки уже не проверяет.</p>
          <p>match - механизм управления потоком, который сравнивает значение с различными шаблонами и выполняет код в зависимости от того, какой из шаблонов совпал.</p>
          <pre><code>// Управляющая конструкция match:
enum Coin {
  Penny,
  Nickel,
  Dime,
  Quarter,
}
fn value_in_cents (coin: Coin) -> u8 {
  match coin {
    Coin::Penny => 1,
    Coin::Nickel => 5,
    Coin::Dime => 10,
    Coin::Quarter => 25,
  }
}
</code></pre>
          <table>
            <caption>match coin:</caption>
            <tbody>
              <tr>
                <td>match</td>
                <td>ключевое слово</td>
              </tr>
              <tr>
                <td>coin</td>
                <td>выражение, которое возвращает любой тип. В данном случае значение coin</td>
              </tr>
              <tr>
                <td>Coin::Penny => 1,</td>
                <td>ветка</td>
              </tr>
              <tr>
                <td>Coin::Penny</td>
                <td>шаблон. В данном случае значение Coin::Penny.</td>
              </tr>
              <tr>
                <td>=></td>
                <td>оператор</td>
              </tr>
              <tr>
                <td>1</td>
                <td>выражение, код для выполнения. В данном случае значение 1.</td>
              </tr>
            </tbody>
          </table>
          <ul>
            <li>Код, связанный с каждой веткой, является выражением, а полученное значение выражения в соответствующей ветке - это значение, которое возвращается для всего выражения match.</li>
            <li>Если код для выполнения больше одной строки, то в фигурные скобки { } - запятая не обязательно.</li>
            <li>Для последней ветки шаблоном является переменная, которая передаётся в функцию move_player.</li>
            <li>Последняя ветка является универсальным шаблоном с привязкой к значению переменной шаблона.</li>
            <li>Заполнитель (нижнее подчеркивание) - специальный шаблон, который используется если не нужно привязываться к значению.</li>
            <li>Одно из требований к выражениям match состоит в том, что они должны быть исчерпывающими (exhaustive) в том смысле, что они должны учитывать все возможности для значения в выражении match.</li>
            <li>Нижнее подчеркивание может быть полезен, если вы, например, хотите игнорировать любое не указанное значение.</li>
          </ul>
          <pre><code>// Универсальный шаблон:
let dice_roll = 9;
match dice_roll {
  3 => add_fancy_hat(),
  7 => remove_fancy_hat(),
  
  // универсальный шаблон с привязкой к значению
  other => move_player(other),
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}
fn move_player(num_spaces: u8) {}

let dice_roll = 9;
match dice_roll {
  3 => add_fancy_hat(),
  7 => remove_fancy_hat(),
  
  // универсальный шаблон без привязки к значению
  _=> reroll (),
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}
fn reroll () {}
</code></pre>
          <p>Используем пустой кортеж - единичное значение, чтобы обозначить, что не используем никакое другое значение, кроме предыдущих веток и не запускаем никакого кода:</p>
          <pre><code>let dice_roll = 9;
match dice_roll {
  3 => add_fancy_hat(),
  7 => remove_fancy_hat(),
  _=> (),
}
fn add_fancy_hat () {}
fn remove_fancy_hat () {}
</code></pre>
          <p>if let - не запускается если значение не соответствует шаблону.</p>
          <pre><code>// Шаблон и выражение разделены знаком равенства.
let config_max = Some (3u8);
if let Some (max) = config_max {
  println! (“The maximum is configured to be { }”, max);
}
</code></pre>
          <p>Ветки match:</p>
          <pre><code>match VALUE {
  PATTERN => EXPRESSION,
  PATTERN => EXPRESSION,
  PATTERN => EXPRESSION,
}</code></pre>
          <table>
            <tbody>
              <tr>
                <td>Value</td>
                <td>значение</td>
              </tr>
              <tr>
                <td>Pattern</td>
                <td>шаблон</td>
              </tr>
              <tr>
                <td>Expression</td>
                <td>выражение</td>
              </tr>
            </tbody>
          </table>
          <p>Дополнительные условия оператора сопоставления (Match Guards)</p>
          <ul>
            <li>Условие сопоставления (match guard) является дополнительным условием if, указанным после шаблона в ветке match, которое также должно быть выполнено, чтобы ветка была выбрана.</li>
            <li>Условия сопоставления полезны для выражения более сложных идей, чем позволяет только шаблон.</li>
            <li>Можно также смешивать и сопоставлять выражения if let, else if и else if let.</li>
            <li>Это даёт больше гибкости, чем match выражение, в котором можно выразить только одно значение для сравнения с шаблонами.</li>
            <li>Недостатком использования if let выражений является то, что компилятор не проверяет полноту (exhaustiveness) всех вариантов, в то время как с помощью выражения match это происходит.</li>
          </ul>
          <pre><code>// Добавление условия сопоставления в шаблон
fn main() {
  let num = Some(4);
  match num {
    Some(x) if x % 2 == 0 => println!("The number {} is even", x),
    Some(x) => println!("The number {} is odd", x),
    None => (),
  }
}

// Использование условия сопоставления для проверки на равенство со значением внешней переменной
fn main() {
  let x = Some(5);
  let y = 10;
  match x {
    Some(50) => println!("Got 50"),
    Some(n) if n == y => println!("Matched, n = {n}"),
    _ => println!("Default case, x = {:?}", x),
  }
  println!("at the end: x = {:?}, y = {y}", x);
}

// Комбинирование нескольких шаблонов с условием сопоставления
fn main() {
  let x = 4;
  let y = false;
  match x {
    4 | 5 | 6 if y => println!("yes"),
    _ => println!("no"),
  }
}

// приоритет условия сопоставления по отношению к шаблону ведёт себя так:
(4 | 5 | 6) if y => ...
а не так:
4 | 5 | (6 if y) => ...

let PATTERN = EXPRESSION;
</code></pre>
          <p>Шаблоны бывают двух форм: опровержимые и неопровержимые.</p>
          <ul>
            <li>Шаблоны, которые будут соответствовать любому возможному переданному значению, являются неопровержимыми (irrefutable).</li>
            <li>Примером может быть x в выражении let x = 5;, потому что x соответствует чему-либо и, следовательно, не может не совпадать.</li>
            <li>Шаблоны, которые могут не соответствовать некоторому возможному значению, являются опровержимыми (refutable).</li>
            <li>Примером может быть Some(x) в выражении if let Some(x) = a_value, потому что если значение в переменной a_value равно None, а не Some, то шаблон Some(x) не будет совпадать.</li>
          </ul>
          <pre><code>// Сопоставление с литералом
fn main() {
  let x = 1;
  match x {
    1 => println!("one"),
    2 => println!("two"),
    3 => println!("three"),
    _ => println!("anything"),
  }
}

// Сопоставление именованных переменных
fn main() {
  let x = Some(5);
  let y = 10;
  match x {
    Some(50) => println!("Got 50"),
    Some(y) => println!("Matched, y = {y}"),
    _ => println!("Default case, x = {:?}", x),
  }
  println!("at the end: x = {:?}, y = {y}", x);
}
</code></pre>
          <p>Поскольку match начинает новую область видимости, то переменные, объявленные как часть шаблона внутри выражения match, будут затенять переменные с тем же именем вне конструкции match как и в случае со всеми переменными.</p>
          <pre><code>// Группа шаблонов
fn main() {
  let x = 1;
  match x {
    1 | 2 => println!("one or two"),
    3 => println!("three"),
    _ => println!("anything"),
  }
}

// Сопоставление диапазонов с помощью ..=
fn main() {
  let x = 5;
  match x {
    1..=5 => println!("one through five"),
    _ => println!("something else"),
  }
}

// Деструктуризация структуры
struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  let Point { x: a, y: b } = p;
  assert_eq!(0, a);
  assert_eq!(7, b);
}

// Или
struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  let Point { x, y } = p;
  assert_eq!(0, x);
  assert_eq!(7, y);
}

// Деструктуризация и сопоставление с литералами в одном шаблоне
struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  match p {
    Point { x, y: 0 } => println!("On the x axis at {x}"),
    Point { x: 0, y } => println!("On the y axis at {y}"),
    Point { x, y } => {
      println!("On neither axis: ({x}, {y})");
    }
  }
}

// Вместо создания переменных для всех полей мы также можем деструктурировать с помощью литеральных значений являющихся частью структуры
struct Point {
  x: i32,
  y: i32,
}
fn main() {
  let p = Point { x: 0, y: 7 };
  match p {
    Point { x, y: 0 } => println!("On the x axis at {x}"),
    Point { x: 0, y } => println!("On the y axis at {y}"),
    Point { x, y } => {
      println!("On neither axis: ({x}, {y})");
    }
  }
}

// Деструктуризация перечислений
enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(i32, i32, i32),
}
fn main() {
  let msg = Message::ChangeColor(0, 160, 255);
  match msg {
    Message::Quit => {
      println!("The Quit variant has no data to destructure.");
    }
    Message::Move { x, y } => {
      println!("Move in the x direction {x} and in the y direction {y}");
    }
    Message::Write(text) => {
      println!("Text message: {text}");
    }
    Message::ChangeColor(r, g, b) => {
      println!("Change the color to red {r}, green {g}, and blue {b}",)
    }
  }
}
</code></pre>
          <ul>
            <li>Этот код напечатает Change the color to red 0, green 160, and blue 255.</li>
            <li>Деструктуризация вложенных структур и перечислений.</li>
            <li>До сих пор все наши примеры сопоставляли структуры или перечисления на один уровень глубины, но сопоставление может работать и с вложенными элементами!</li>
          </ul>
          <pre><code>enum Color {
  Rgb(i32, i32, i32),
  Hsv(i32, i32, i32),
}
enum Message {
  Quit,
  Move { x: i32, y: i32 },
  Write(String),
  ChangeColor(Color),
}

fn main() {
  let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));
  match msg {
    Message::ChangeColor(Color::Rgb(r, g, b)) => {
      println!("Change color to red {r}, green {g}, and blue {b}");
    }
    Message::ChangeColor(Color::Hsv(h, s, v)) => {
      println!("Change color to hue {h}, saturation {s}, value {v}")
    }
    _ => (),
  }
}
</code></pre>
          <h2>Memory</h2>
          <ul>
            <li>Владение позволяет обеспечивать безопасность памяти без использования сборщика мусора.</li>
            <li>Владение - это набор правил, определяющих как программа на Rust управляет памятью.</li>
            <li>Стек - часть памяти, который хранит значения в порядке их получения, а удаляет - в обратном. Последний пришёл, первый вышел.</li>
            <li>Все данные, хранящиеся в стеке, должны иметь известный фиксированный размер.</li>
            <li>Данные, размер которых во время компиляции неизвестен или может измениться, должны храниться в куче.</li>
            <li>Куча - часть памяти, в которой распределитель памяти находит для данных подходящее место, помечает его как используемое и возвращает указатель - адрес этого места. Это выделение в куче или просто выделение.</li>
          </ul>
          <p>Правила владения:</p>
          <ul>
            <li>У каждого значения в Rust есть владелец.</li>
            <li>У значения может быть только один владелец в один момент времени.</li>
            <li>Когда владелец покидает область видимости, значение удаляется.</li>
            <li>При вызове String::from происходит запрос необходимой памяти.</li>
            <li>Память автоматически возвращается, как только владеющая памятью переменная выходит из области видимости { }.</li>
            <li>Rust автоматически вызывает функцию drop после закрывающей фигурной скобки и очищает память.</li>
            <li>Вектор освобождает память когда выходит из области видимости, при этом удаляются все значения, которые он содержит.</li>
          </ul>
          <table>
            <caption>Cycle: loop, while, for</caption>
            <tbody>
              <tr>
                <td>loop</td>
                <td>выполняет блок кода пока нет команды остановиться (break)</td>
              </tr>
              <tr>
                <td>break</td>
                <td>прерывает выполнение цикла и выходит из него</td>
              </tr>
              <tr>
                <td>continue</td>
                <td>пропустить оставшийся код в данной итерации цикла и перейти к следующей итерации</td>
              </tr>
            </tbody>
          </table>
          <p>break и continue применяется к самому внутреннему циклу внутри цепочки циклов</p>
          <pre><code>// Метка цикла '
'counting_up: loop {
  ...
  loop {
  ...
    if count == 2 {

      // выход из цикла к 'counting_up в начале цикла
      break 'counting_up;
    }
  }
  ...
}

// пока условие истинно, код выполняется, в противном случае происходит выход из цикла.
while number! = 0 {...}
</code></pre>
          <ul>
            <li>Конструкция условного цикла while let позволяет повторять цикл while до тех пор, пока шаблон продолжает совпадать.</li>
            <li>В цикле for значение, которое следует непосредственно за ключевым словом for, является шаблоном.</li>
            <li>Например, в for x in y выражение x является шаблоном.</li>
          </ul>
          <pre><code>fn main () {
  let a = [10, 20, 30, 40, 50];
  for element in a {
    println! (“the value is: {element}”);
  }
}

fn main () {
  for number in (1..4).rev() {
    println! (“{number}!”);
  }
    println! (“LIFTOFF !!!”);
}
</code></pre>
          <h2>Error</h2>
          <ul>
            <li>В Rust ошибки группируются на две основные категории: исправимые (recoverable) и неисправимые (unrecoverable).</li>
            <li>Rust имеет тип Result&lt; T, E&gt; для обрабатываемых (исправимых) ошибок и макрос panic!, который останавливает выполнение, когда программа встречает необрабатываемую (неисправимую) ошибку.</li>
            <li>На практике существует два способа вызвать панику: путём выполнения действия, которое вызывает панику в нашем коде (например, обращение к массиву за пределами его размера) или путём явного вызова макроса panic!.</li>
            <li>По умолчанию, когда происходит паника, программа начинает процесс раскрутки стека, означающий в Rust проход обратно по стеку вызовов и очистку данных для каждой обнаруженной функции.</li>
            <li>Rust как альтернативу предоставляет вам возможность немедленного прерывания (aborting), которое завершает работу программы без очистки.</li>
            <li>Память, которую использовала программа, должна быть очищена операционной системой.</li>
            <li>Добавьте panic = 'abort' в раздел [profile] вашего Cargo.toml файла.</li>
            <li>Мы можем использовать обратную трассировку вызовов функций которые вызвали panic! чтобы выяснить, какая часть нашего кода вызывает проблему.</li>
            <li>Получить обратную трассировку можно с помощью установки переменной среды RUST_BACKTRACE в любое значение, кроме 0.</li>
            <li>Обратная трассировка создаёт список всех функций, которые были вызваны до какой-то определённой точки выполнения программы.</li>
            <li>Другие строки, которые выше над  строками с упоминанием наших файлов, - это код, который вызывается нашим кодом;</li>
            <li>строки ниже являются кодом, который вызывает наш код.</li>
          </ul>
          <pre><code>enum Result< T, E> {
  Ok(T),
  Err(E),
}
</code></pre>
          <p>T представляет тип значения, которое будет возвращено в случае успеха внутри варианта Ok, а E представляет тип ошибки, которая будет возвращена при сбое внутри варианта Err.</p>
          <ul>
            <li>Метод unwrap - это метод быстрого доступа к значениям.</li>
            <li>Если значение Result является вариантом Ok, unwrap возвращает значение внутри Ok.</li>
            <li>Если Result - вариант Err, то unwrap вызовет для нас макрос panic!.</li>
            <li>Метод expect позволяет указать сообщение об ошибке для макроса panic!.</li>
            <li>expect используется так же как и unwrap: либо возвращается дескриптор файла либо вызывается макрос panic!.</li>
            <li>Наше сообщение об ошибке в expect будет передано в panic! и заменит стандартное используемое сообщение.</li>
            <li>Когда вы пишете функцию, реализация которой вызывает что-то, что может завершиться ошибкой, вместо обработки ошибки в этой функции, вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что с ней делать.</li>
            <li>Такой приём известен как распространение ошибки (propagating the error).</li>
          </ul>
          <h2>Trait</h2>
          <ul>
            <li>Типаж сообщает компилятору Rust о функциональности, которой обладает определённый тип и которой он может поделиться с другими типами.</li>
            <li>Можно использовать типажи, чтобы определять общее поведение абстрактным способом.</li>
            <li>Мы можем использовать ограничение типажа (trait bounds) чтобы указать, что общим типом может быть любой тип, который имеет определённое поведение.</li>
          </ul>
          <p>Определение типажей - это способ сгруппировать сигнатуры методов вместе для того, чтобы описать общее поведение.</p>
          <pre><code>pub trait Summary {
  fn summarize(&self) -> String;
}
</code></pre>
          <p>
            После сигнатуры метода, вместо предоставления реализации в фигурных в скобках, мы используем точку с запятой.<br/>
            Каждый тип, реализующий данный типаж, должен предоставить своё собственное поведение для данного метода.
          </p>
          <pre><code>// Реализация типожа у типа
impl Summary for NewsArticle {
  fn summarize(&self) -> String {}

impl Summary for Tweet {
  fn summarize(&self) -> String {}
</code></pre>
          <ul>
            <li>Мы не можем реализовать внешние типажи для внешних типов.</li>
            <li>Это ограничение является частью свойства называемого согласованность (coherence), а ещё точнее сиротское правило (orphan rule), которое называется так потому что не представлен родительский тип.</li>
            <li>Без этого правила два крейта могли бы реализовать один типаж для одинакового типа и Rust не сможет понять, какой реализацией нужно пользоваться.</li>
          </ul>
          <pre><code>// Типажи как параметры
pub fn notify(item: &impl Summary) {
  println!("Breaking news! {}", item.summarize());
}
</code></pre>
          <ul>
            <li>Вместо конкретного типа у параметра item указывается ключевое слово impl и имя типажа.</li>
            <li>Этот параметр принимает любой тип, который реализует указанный типаж.</li>
            <li>Используя impl Summary для возвращаемого типа, мы указываем, что функция returns_summarizable возвращает некоторый тип, который реализует типаж Summary без обозначения конкретного типа.</li>
          </ul>
          <pre><code>// Обе записи одинаковы:
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
pub fn notify< T: Summary>(item1: &T, item2: &T) {}

// Более одного типажа
pub fn notify(item: &(impl Summary + Display)) {}

// Это выражение:
fn some_function< T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}

// Можно записать так:
fn some_function< T, U>(t: &T, u: &U) -> i32

// где
T: Display + Clone,
U: Clone + Debug,

fn returns_summarizable() -> impl Summary {}
</code></pre>
          <p>Поскольку стандартная библиотека имеет эту общую реализацию, то можно вызвать метод to_string определённый типажом ToString для любого типа, который реализует типаж Display:</p>
          <pre><code>impl< T: Display> ToString for T { }</code></pre>
          <ul>
            <li>Общие реализации приведены в документации к типажу в разделе 'Implementors'.</li>
            <li>Типажи и ограничения типажей позволяют писать код, который использует параметры обобщённого типа для уменьшения дублирования кода, а также указывая компилятору, что мы хотим обобщённый тип, чтобы иметь определённое поведение.</li>
            <li>Затем компилятор может использовать информацию про ограничения типажа, чтобы проверить, что все конкретные типы, используемые с нашим кодом, обеспечивают правильное поведение.</li>
            <li>В Rust применяется подход с использованием типажей-объектов вместо наследования.</li>
            <li>Мы можем использовать типаж-объекты вместо универсального или конкретного типа.</li>
            <li>Везде, где мы используем типаж-объект, система типов Rust проверит во время компиляции, что любое значение, используемое в этом контексте, будет реализовывать нужный типаж у типаж-объекта.</li>
            <li>Следовательно, нам не нужно знать все возможные типы во время компиляции.</li>
            <li>В структуре или перечислении данные в полях структуры и поведение в блоках impl разделены, тогда как в других языках данные и поведение объединены в одну концепцию, часто обозначающуюся как объект.</li>
            <li>Тем не менее, типаж-объекты являются более похожими на объекты на других языках, в том смысле, что они сочетают в себе данные и поведение.</li>
            <li>Но типаж-объекты отличаются от традиционных объектов тем, что не позволяют добавлять данные к типаж-объекту.</li>
            <li>Типаж-объекты обычно не настолько полезны, как объекты в других языках:</li>
            <li>их конкретная цель - обеспечить абстракцию через общее поведение.</li>
            <li>Когда мы используем типаж-объекты, Rust должен использовать динамическую диспетчеризацию.</li>
            <li>Компилятор не знает всех типов, которые могут быть использованы с кодом, использующим типаж-объекты, поэтому он не знает, какой метод реализован для какого типа при вызове.</li>
            <li>Вместо этого, во время выполнения, Rust использует указатели внутри типаж-объекта, чтобы узнать какой метод вызвать.</li>
            <li>Такой поиск вызывает дополнительные затраты во время исполнения, которые не требуются при статической диспетчеризации.</li>
          </ul>
          <pre><code>// Деструктуризация структур и кортежей
fn main() {
  struct Point {
    x: i32,
    y: i32,
  }
  let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });
}
</code></pre>
          <h2>Test</h2>
          <p>
            Тесты - это функции Rust, которые проверяют, что не тестовый код работает ожидаемым образом.<br/>
            Содержимое тестовых функций обычно выполняет следующие три действия:
          </p>
          <ul>
            <li>Установка любых необходимых данных или состояния.</li>
            <li>Запуск кода, который вы хотите проверить.</li>
            <li>Утверждение, что результаты являются теми, которые вы ожидаете.</li>
          </ul>
          <ul>
            <li>Чтобы превратить функцию в тестирующую функцию добавьте # [test] в строку перед fn.</li>
            <li>Когда вы запускаете тесты командой cargo test, Rust создаёт бинарный модуль выполняющий функции аннотированные атрибутом test и сообщающий о том, успешно или нет прошла каждая тестирующая функция.</li>
            <li>Макрос *assert!* доступен из стандартной библиотеки и является удобным, когда вы хотите проверить что некоторое условие в тесте вычисляется в значение true.</li>
            <li>Когда проверка не срабатывает, макросы печатают значения аргументов с помощью отладочного форматирования и это означает, что значения сравниваемых аргументов должны реализовать типажи PartialEq и Debug.</li>
            <li>Все примитивные и большая часть типов стандартной библиотеки Rust реализуют эти типажи.</li>
            <li>Для структур и перечислений, которые вы реализуете сами будет необходимо реализовать типаж PartialEq для сравнения значений на равенство или неравенство.</li>
            <li>Для печати отладочной информации в виде сообщений в строку вывода консоли необходимо реализовать типаж Debug.</li>
            <li>Так как оба типажа являются выводимыми типажами, то эти типажи можно реализовать добавив аннотацию # [derive(PartialEq, Debug)] к определению структуры или перечисления.</li>
            <li>Общим способом проверки функциональности является использование сравнения результата тестируемого кода и ожидаемого значения, чтобы убедиться в их равенстве.</li>
            <li>Для этого можно использовать макрос assert!, передавая ему выражение с использованием оператора ==.</li>
            <li>Стандартная библиотека предлагает пару макросов assert_eq! и assert_ne!, чтобы сделать тестирование более удобным.</li>
            <li>Эти макросы сравнивают два аргумента на равенство или неравенство соответственно.</li>
            <li>Макросы также печатают два значения входных параметров, если тест завершился ошибкой, что позволяет легче увидеть почему тест ошибочен.</li>
            <li>Противоположно этому, макрос assert! может только отобразить, что он вычислил значение false для выражения ==, но не значения, которые привели к результату false.</li>
            <li>В своей работе макросы assert_eq! и assert_ne! неявным образом используют операторы == и != соответственно.</li>
            <li>Другой атрибут тест-функции # [should_panic].</li>
          </ul>
          <pre><code>// Этот атрибут сообщает системе тестирования, что тест проходит, когда метод генерирует ошибку.
# [cfg(test)]
mod tests {
  use super::*;
  # [test]
  # [should_panic]
  fn greater_than_100() {}
}
</code></pre>
          <p>
            Тест с атрибутом should_panic пройдёт, даже если тест паникует по причине, отличной от той, которую мы ожидали.<br/>
            Чтобы сделать тесты с should_panic более точными, мы можем добавить необязательный параметр expected для атрибута should_panic.
          </p>
          <pre><code># [cfg(test)]
mod tests {
  use super::*;
  # [test]
  # [should_panic(expected = "less than or equal to 100")]
  fn greater_than_100() {}
}
</code></pre>
          <p>Написание тестов так, чтобы они возвращали Result< T, E> позволяет использовать оператор "вопросительный знак" в теле тестов, который может быть удобным способом писать тесты, которые должны выполниться не успешно, если какая-либо операция внутри них возвращает вариант ошибки Err.</p>
          <pre><code># [cfg(test)]
mod tests {
  # [test]
  fn it_works() -> Result<(), String> {
    if 2 + 2 == 4 {
      Ok(())
    } else {
      Err(String::from("two plus two does not equal four"))
    }
  }
}
</code></pre>
          <p>Поскольку тесты выполняются параллельно, вы должны убедиться, что ваши тесты не зависят друг от друга или от какого-либо общего состояния, включая общее окружение, например, текущий рабочий каталог или переменные окружения.</p>
          <pre><code>cargo test -- --test-threads=1</code></pre>
          <ul>
            <li>Мы устанавливаем количество тестовых потоков равным 1, указывая программе не использовать параллелизм.</li>
            <li>Выполнение тестов с использованием одного потока займёт больше времени, чем их параллельное выполнение, но тесты не будут мешать друг другу, если они совместно используют состояние.</li>
            <li>Если мы хотим видеть напечатанные результаты прохождения тестов, мы можем сказать Rust, чтобы он также показывал результаты успешных тестов с помощью --show-output.</li>
          </ul>
          <pre><code>cargo test -- --show-output</code></pre>
          <p>Запустить только несколько тестов, используя команду cargo test, передав в качестве аргумента имена тестов.</p>
          <pre><code>cargo test it_works</code></pre>
          <p>Мы можем указать часть имени теста, и будет запущен любой тест, имя которого соответствует этому значению.</p>
          <pre><code>// Можно аннотировать тесты атрибутом ignore, чтобы исключить их из исполнения:
# [test]
fn it_works() {
  assert_eq!(2 + 2, 4);
}

# [test]
# [ignore]
fn expensive_test() {
  // code that takes an hour to run
}
</code></pre>
          <p>Если вы хотите выполнить только проигнорированные тесты, вы можете воспользоваться командой</p>
          <pre><code>cargo test -- --ignored</code></pre>
          <p>Если вы хотите запустить все тесты независимо от того, игнорируются они или нет, выполните</p>
          <pre><code>cargo test -- --include-ignored</code></pre>
          <ul>
            <li>Модульные тесты это небольшие и более сфокусированные на тестировании одного модуля в отдельности или могут тестироваться приватные интерфейсы.</li>
            <li>Интеграционные тесты являются полностью внешними по отношению к вашей библиотеке и используют код библиотеки так же, как любой другой внешний код, используя только общедоступные интерфейсы и потенциально выполняя тестирование нескольких модулей в одном тесте.</li>
            <li>Целью модульных тестов является тестирование каждого блока кода, изолированное от остального функционала, чтобы можно было быстро понять, что работает некорректно или не так как ожидается.</li>
            <li>Аннотация # [cfg(test)] у модуля с тестами указывает Rust компилировать и запускать только код тестов, когда выполняется команда cargo test, а не когда запускается cargo build.</li>
            <li>Тем не менее, так как модульные тесты идут в тех же файлах что и основной код, вы будете использовать # [cfg(test)] чтобы указать, что они не должны быть включены в скомпилированный результат.</li>
            <li>Мы создаём папку tests в корневой папке вашего проекта, рядом с папкой src.</li>
            <li>Cargo знает, что искать файлы с интеграционными тестами нужно в этой директории.</li>
            <li>Нам не нужно комментировать код в tests/integration_test.rs с помощью # [cfg(test)].</li>
            <li>Cargo специальным образом обрабатывает каталог tests и компилирует файлы в этом каталоге только тогда, когда мы запускаем команду cargo test.</li>
          </ul>
          <p>
            Выходные данные представлены тремя разделами: модульные тесты, интеграционные тесты и тесты документации.<br/>
            Чтобы запустить все тесты в конкретном файле интеграционных тестов, используйте аргумент --test сопровождаемый именем файла у команды cargo test:
          </p>
          <pre><code>cargo test --test integration_test</code></pre>
          <ul>
            <li>Файлы в подкаталогах каталога tests не компилируются как отдельные крейты или не появляются в результатах выполнения тестов.</li>
            <li>Если наш проект является бинарным крейтом, который содержит только src/main.rs и не содержит src/lib.rs, мы не сможем создать интеграционные тесты в папке tests и подключить функции определённые в файле src/main.rs в область видимости с помощью оператора use.</li>
            <li>Только библиотечные крейты могут предоставлять функции, которые можно использовать в других крейтах;</li>
            <li>бинарные крейты предназначены только для самостоятельного запуска.</li>
          </ul>
          <p>Процесс разработки через тестирование (TDD), который следует этим шагам:</p>
          <ul>
            <li>Напишите тест, который не прошёл и запустите его, чтобы убедиться, что он не прошёл по той причине, которую вы ожидаете.</li>
            <li>Пишите или изменяйте ровно столько кода, чтобы успешно выполнился новый тест.</li>
            <li>Выполните рефакторинг кода, который вы только что добавили или изменили, и убедитесь, что тесты продолжают проходить.</li>
            <li>Повторите с шага 1!</li>
          </ul>
          <h2>Unsafe Rust</h2>
          <p>
            Чтобы переключиться на небезопасный Rust, используйте ключевое слово *unsafe*, а затем начните новый блок, содержащий небезопасный код.<br/>
            В небезопасном Rust можно выполнять пять действий, которые недоступны в безопасном Rust, которые мы называем небезопасными супер силами.<br/>
            Эти супер силы включают в себя следующее:
          </p>
          <ul>
            <li>Разыменование сырого указателя</li>
            <li>Вызов небезопасной функции или небезопасного метода</li>
            <li>Доступ или изменение изменяемой статической переменной</li>
            <li>Реализация небезопасного типажа</li>
            <li>Доступ к полям в union</li>
          </ul>
          <ul>
            <li>Люди подвержены ошибкам и ошибки будут происходить, но требуя размещение этих четырёх небезопасных операции внутри блоков, помеченных как unsafe, вы будете знать, что любые ошибки, связанные с безопасностью памяти, будут находиться внутри unsafe блоков.</li>
            <li>Делайте unsafe блоки маленькими; вы будете благодарны себе за это позже, при исследовании ошибок с памятью.</li>
            <li>Части стандартной библиотеки реализованы как проверенные, безопасные абстракции над небезопасным кодом.</li>
            <li>Создание необработанных указателей из ссылок</li>
          </ul>
          <pre><code>fn main() {
  let mut num = 5;
  let r1 = &num as *const i32;
  let r2 = &mut num as *mut i32;
}
</code></pre>
          <p>В отличие от ссылок и умных указателей, сырые указатели:</p>
          <ul>
            <li>могут игнорировать правила заимствования и иметь неизменяемые и изменяемые указатели, или множество изменяемых указателей на одну и ту же область памяти</li>
            <li>не гарантируют что ссылаются на действительную память</li>
            <li>могут быть null</li>
            <li>не реализуют автоматическую очистку памяти</li>
          </ul>
          <p>Разыменование сырых указателей в блоке unsafe</p>
          <pre><code>fn main() {
  let mut num = 5;
  let r1 = &num as *const i32;
  let r2 = &mut num as *mut i32;
  unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
  }
}
</code></pre>
          <p>Вызов небезопасной функции или метода</p>
          <pre><code>fn main() {
  unsafe fn dangerous() {}
  unsafe {
    dangerous();
  }
}
</code></pre>
          <p>обёртывание небезопасного кода в безопасную функцию - это обычная абстракция.</p>
          <pre><code>// Использование небезопасного кода в реализации функции split_at_mut
use std::slice;
fn split_at_mut(values: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
  let len = values.len();
  let ptr = values.as_mut_ptr();
  assert!(mid <= len);
  unsafe {
    (
      slice::from_raw_parts_mut(ptr, mid),
      slice::from_raw_parts_mut(ptr.add(mid), len - mid),
    )
  }
}
fn main() {
  let mut vector = vec![1, 2, 3, 4, 5, 6];
  let (left, right) = split_at_mut(&mut vector, 3);
}
</code></pre>
          <p>мы можем быть уверены, что все сырые указатели, используемые в unsafe блоке будут действительными указателями на данные внутри среза. Это приемлемое и правильное использование unsafe.</p>
          <p>
            Иногда вашему коду на языке Rust может потребоваться взаимодействие с кодом, написанным на другом языке.<br/>
            Для этого в Rust есть ключевое слово extern, которое облегчает создание и использование интерфейса внешних функций (Foreign Function Interface - FFI).
          </p>
          <pre><code>// FFI - это способ для языка программирования определить функции и позволить другому (внешнему) языку программирования вызывать эти функции.
extern "C" {
  fn abs(input: i32) -> i32;
}
fn main() {
  unsafe {
    println!("Absolute value of -3 according to C: {}", abs(-3));
  }
}

// мы делаем функцию call_from_c доступной из кода на языке C, после того как она скомпилирована в разделяемую библиотеку и прилинкована из C
#![allow(unused)]
fn main() {
  # [no_mangle]
  pub extern "C" fn call_from_c() {
    println!("Just called a Rust function from C!");
  }
}

// Определение и использование неизменяемой статической (глобальной) переменной
static HELLO_WORLD: &str = "Hello, world!";
fn main() {
  println!("name is: {}", HELLO_WORLD);
}
</code></pre>
          <p>Имена статических переменных по общему соглашению пишутся в нотации SCREAMING_SNAKE_CASE, и мы должны указывать тип переменной, которым в данном случае является &'static str.</p>
          <pre><code>// Чтение из изменяемой статической переменной или запись в неё небезопасны
static mut COUNTER: u32 = 0;
fn add_to_count(inc: u32) {
  unsafe {
    COUNTER += inc;
  }
}

fn main() {
  add_to_count(3);
  unsafe {
    println!("COUNTER: {}", COUNTER);
  }
}</code></pre>
          <p>
            Мы можем использовать unsafe для реализации небезопасного трейта.<br/>
            Трейт является небезопасным, если хотя бы один из его методов имеет некоторый инвариант, который компилятор не может проверить.
          </p>
          <pre><code>unsafe trait Foo {
// methods go here
}
unsafe impl Foo for i32 {

// method implementations go here
}
fn main() {}
</code></pre>
        </details>
        <details> 
          <summary>SQL</summary>
          <ul>
            <li><a href="https://dbdiagram.io">DB Diagram</a>
            </li>
            <li><a href="https://drawsql.app/">Рисовать диаграмму БД онлайн</a>
            </li>
          </ul>
          <h2>Определение (Definition)</h2>
          <ul>
            <li>SQL — применяется для создания, модификации и управления данными в реляционной базе данных, управляемой соответствующей системой управления базами данных.</li>
            <li>В базовом варианте SQL является информационно-логическим языком, а не языком программирования.</li>
            <li>Система управления базами данных (СУБД) — совокупность программных и лингвистических средств общего или специального назначения, обеспечивающих управление созданием и использованием баз данных.</li>
            <li>База данных (БД) - под БД (БД) понимают хранилище структурированных данных, при этом данные должны быть непротиворечивы, минимально избыточны и целостны.</li>
            <li>Реляционная база данных — база данных, основанная на реляционной модели данных.</li>
            <li>Реляционные БД представляют связанную между собой совокупность таблиц-сущностей БД.</li>
            <li>Каждая таблица БД представляется как совокупность строк и столбцов, где строки соответствуют экземпляру объекта, конкретному событию или явлению, а столбцы - атрибутам (признакам, характеристикам, параметрам) объекта, события, явления.</li>
            <li>При практической разработке БД таблицы-сущности зовутся таблицами, строки-экземпляры - записями, столбцы-атрибуты - полями.</li>
            <li>Преимущества SQL - наличие стандартов и независимость от конкретной СУБД.</li>
            <li>Недостатки SQL - сложность.</li>
          </ul>
          <p>Классификация по модели данных:</p>
          <ul>
            <li>Иерархическая</li>
            <li>Объектная и объектно-ориентированная</li>
            <li>Объектно-реляционная</li>
            <li>Реляционная</li>
            <li>Сетевая</li>
            <li>Функциональная</li>
          </ul>
          <p>Типы отношений:</p>
          <ul>
            <li>Один к одному (one-to-one)</li>
            <li>Один ко многим (one-to-many)</li>
            <li>Многие к одному (many-to-one)</li>
            <li>Многие ко многим (many-to-many, реализуется через отдельную таблицу)</li>
          </ul>
          <h2>Операторы определения данных (Data Definition Language, DDL)</h2>
          <h3>CREATE - создает объект БД (саму базу, таблицу, представление, пользователя и т. д.)</h3>
          <pre><code>// создать новую базу данных SQL
CREATE DATABASE database name;
</code></pre>
          <p>Создать таблицу table со столбцами id, field_1, field_2, field_3: по каждому столбцу заданы тип и количество символов.</p>
          <pre><code>CREATE TABLE table(
  id INT PRIMARY KEY,
  field_1 VARCHAR(100),
  field_2 VARCHAR(30),
  field_3 INT
);</code></pre>
          <table>
            <tbody>
              <tr>
                <td>DESCRIBE table</td>
                <td>информация о таблице</td>
              </tr>
              <tr>
                <td>PRIMARY KEY</td>
                <td>уникальный идентификатор записей.</td>
              </tr>
              <tr>
                <td>FOREIGN KEY</td>
                <td>внешний ключ, значения идентификатора записей в связанной таблице.</td>
              </tr>
              <tr>
                <td>SERIAL</td>
                <td>автоинкремент идентификатора в PostgreSQL</td>
              </tr>
              <tr>
                <td>AUTO_INCREMENT</td>
                <td>автоинкремент идентификатора в MySQL</td>
              </tr>
            </tbody>
          </table>
          <pre><code>CREATE TABLE table(
  id SERIAL PRIMARY KEY,
  field_1 VARCHAR(100),
  field_2 VARCHAR(30),
  field_3 INT
);

// Скрипт создания таблицы
DROP TABLE IF EXISTS table;
CREATE TABLE table(
  id SERIAL PRIMARY KEY,
  field_1 VARCHAR(100),
  field_2 VARCHAR(30),
  field_3 INT
);

// BACKUP - резервное копирование
BACKUP DATABASE testDB
TO DISK = 'D:\backups\testDB.bak'; 

</code></pre>
          <h3>Ограничения на уровне таблицы</h3>
          <ul>
            <li>либо RESTRICT - запретить удалять id таблицы table_2</li>
            <li>либо CASCADE  - при удалении id таблицы table_2, удалить соответствующие записи</li>
          </ul>
          <pre><code>CREATE TABLE table_1(
  id PRIMARY KEY,

  // Значения в столбцах id и field_1 уникальные и не пустые
  field_1 VARCHAR(100) UNIQUE NOT NULL,
  field_2 VARCHAR(30),
  field_3 INT,

  // Значения столбца field_table_2_id - ссылки на id таблицы table_2
  field_table_2_id INT REFERENCES table_2(id)
  ON DELETE RESTRICT

  // Ограничение с именем positive_field
  CONSTRAINT positive_field

  // Значения в столбце field_3 должны быть положительными
  CHECK (field_3 >= 0)
);

// Уникальный идентификатор состоит из двух столбцов
CREATE TABLE table_1(
  field_table_2_id INT REFERENCES table_2(id),
  field_table_3_id INT REFERENCES table_3(id),
  quantity INT,
  PRIMARY KEY(field_table_2_id, field_table_3_id)
);
</code></pre>
          <h3>ALTER - изменяет таблицу</h3>
          <pre><code>// Изменить таблицу table, добавить столбец field_4 с типом BOOLEAN
ALTER TABLE table 
ADD COLUMN field_4 BOOLEAN;

// Изменить таблицу table, удалить столбец field_4
ALTER TABLE table 
DROP COLUMN field_4;

// Изменить таблицу table, переименовать столбец field_4 в field_5
ALTER TABLE table 
RENAME COLUMN field_4 TO field_5;

// Изменить таблицу table, переименовать в another_table
ALTER TABLE table 
RENAME TO another_table;
</code></pre>
          <h3>DROP - удаляет таблицу</h3>
          <pre><code>DROP TABLE table</code></pre>
          <h2>Операторы манипуляции данными (Data Manipulation Language, DML)</h2>
          <h3>SELECT</h3>
          <p>SELECT - выбирает данные, удовлетворяющие заданным условиям</p>
          <pre><code>SELECT * FROM table</code></pre>
          <ul>
            <li>Для примера используем таблицу table со столбцами field_1, field_2 и т.д.</li>
            <li>У каждого столбца свои значения value_1, value_2, value_3 и т.д.</li>
            <li>Выбираю столбец (field_1) и столбец (field_2) из таблицы (table)</li>
          </ul>
          <pre><code>SELECT field_1, field_2
FROM table;
</code></pre>
          <p>Ключевое слово AS назначает псевдоним f1 столбцу field_1</p>
          <pre><code>SELECT field_1 AS f1
FROM table;
</code></pre>
          <p>Выбрать только уникальные значения столбца field_1</p>
          <pre><code>SELECT DISTINCT(field_1)
FROM table;
</code></pre>
          <p>Выбрать первых 10 уникальных значений столбца field_1</p>
          <pre><code>SELECT DISTINCT(field_1)
FROM table
LIMIT 10;
</code></pre>
          <p>Выбрать из таблицы table все строки со значением value в столбце field_2</p>
          <pre><code>SELECT *
FROM table

// WHERE и фильтр field_2 = 'value'
WHERE field_2 = 'value';
</code></pre>
          <table>
            <caption>Используем в WHERE:</caption>
            <tbody>
              <tr>
                <td>/=</td>
                <td>Равно</td>
              </tr>
              <tr>
                <td><>, !=</td>
                <td>Неравно</td>
              </tr>
              <tr>
                <td>></td>
                <td>Больше</td>
              </tr>
              <tr>
                <td>>=</td>
                <td>Больше или равно</td>
              </tr>
              <tr>
                <td><</td>
                <td>Меньше</td>
              </tr>
              <tr>
                <td><=</td>
                <td>Меньше или равно</td>
              </tr>
              <tr>
                <td>BETWEEN</td>
                <td>Значение в диапазоне</td>
              </tr>
              <tr>
                <td>IN</td>
                <td>Значение в списке</td>
              </tr>
              <tr>
                <td>LIKE</td>
                <td>Соответствие шаблону</td>
              </tr>
              <tr>
                <td>AND</td>
                <td>Логическое И</td>
              </tr>
              <tr>
                <td>OR</td>
                <td>Логическое ИЛИ</td>
              </tr>
              <tr>
                <td>NOT</td>
                <td>Логическое НЕ</td>
              </tr>
            </tbody>
          </table>
          <table>
            <caption>Спец.символы в шаблонах LIKE:</caption>
            <tbody>
              <tr>
                <td>%</td>
                <td>любое количество символов (можно и без символов)</td>
              </tr>
              <tr>
                <td>_</td>
                <td>ровно один символ</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// Return all customers starting with "a", "b", "c", "d", "e" or "f":
SELECT * FROM Customers
WHERE CustomerName LIKE '[a-f]%';

// Return all customers starting with either "b", "s", or "p":
SELECT * FROM Customers
WHERE CustomerName LIKE '[bsp]%';

// Return all customers starting with NOT either "b", "s", or "p":
SELECT * FROM Customers
WHERE City LIKE '[!bsp]%';

// Выбрать из таблицы table все строки со значениями от value_1 по value_2 в столбце field_2
SELECT *
FROM table
WHERE field_2
BETWEEN value_1 AND value_2;

// Выбрать из таблицы table все строки со значениями по списку IN из столбца field_2
SELECT *
FROM table
WHERE field_2
IN (value_1, value_2, value_3);

// Выбрать из таблицы table все строки, у которых в столбе field_2 значение содержит value
SELECT *
FROM table
WHERE field_2
LIKE '%value%';

// Выбрать из таблицы table все строки, у которых одновременно в столбе field_1 значение value_3 и в столбце field_2 значение value_2
SELECT *
FROM table
WHERE field_1 = value_3
AND field_2 = value_2;
  
// Выбрать из таблицы table все строки, у которых в столбце field_1 значение value_3 либо в столбце field_2 значение value_2
SELECT *
FROM table
WHERE field_1 = value_3
OR field_2 = value_2;

// Выбрать из таблицы table все строки со значениями вне списка IN из столбца field_2
SELECT *
FROM table
WHERE field_2
NOT IN (value_1, value_2, value_3);
</code></pre>
          <table>
            <caption>Порядок сортировки в ORDER BY:</caption>
            <tbody>
              <tr>
                <td>ASC (ascending)</td>
                <td>сортировка по возрастанию (по умолчанию)</td>
              </tr>
              <tr>
                <td>DESC (descending)</td>
                <td>сортировка по убыванию</td>
              </tr>
            </tbody>
          </table>
          <pre><code>// Выбрать из таблицы table все строки и отсортировать их по столбцу field_3
// Сортировка данных по столбцу field_3, по умолчанию это ASC
SELECT *
FROM table
ORDER BY field_3

// Сортировка данных по столбцу field_3 по убыванию
SELECT *
FROM table
ORDER BY field_3 DESC;
  
// Выбрать из таблицы table все строки, у которых в столбце field_1 значение value_3 и отсортировать по столбцу field_3 по убыванию
SELECT *
FROM table
WHERE field_1 = value_3
ORDER BY field_3 DESC;
  
// Выбрать из таблицы table все строки, у которых одновременно в столбе field_1 значение value_3 и в столбце field_2 значение value_2 и отсортировать по столбцу field_3 по убыванию и вывести первые пять строк
SELECT *
FROM table
WHERE field_1 = value_3
AND field_2 = value_2
ORDER BY field_3 DESC
LIMIT 5;
  
// Выбрать из таблицы table все строки и отсортировать по двум столбцам
SELECT *
FROM table
ORDER BY field_3, field_2;
  
// Выбрать из таблицы table столбец field_1 строки в котором не имеют значений
SELECT field_1
FROM table
WHERE field_1 IS NULL; 
  
// Выбрать из таблицы table столбец field_1 строки в котором имеют значения
SELECT field_1
FROM table
WHERE field_1 IS NOT NULL;

// Оператор EXISTS используется для проверки существования любой записи в подзапросе.
// Оператор EXISTS возвращает TRUE, если подзапрос возвращает одну или несколько записей.
SELECT field_1
FROM table
WHERE EXISTS
(SELECT field_2
FROM table
WHERE condition); 

// Вывести id строк, в которых значение temperature больше temperature предыдущего дня
SELECT current_day.id
FROM Weather AS current_day
WHERE EXISTS (
  SELECT 1
  FROM Weather AS yesterday
  WHERE current_day.temperature > yesterday.temperature
  AND current_day.recordDate = yesterday.recordDate + 1
);

// ANY означает, что условие будет истинным, если операция истинна для любого из значений в диапазоне.
SELECT field_1
FROM table
WHERE field_1 = ANY
(SELECT field_1
FROM table
WHERE condition);
  
// ALL означает, что условие будет истинным только в том случае, если операция истинна для всех значений в диапазоне.
SELECT ALL field_1
FROM table
WHERE condition;

SELECT field_1
FROM table
WHERE field_1 = ALL
(SELECT field_2 FROM table WHERE condition);
  
// Скопировать все столбцы в новую таблицу.
SELECT *
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
  
// Следующий оператор SQL использует предложение IN для копирования таблицы в новую таблицу в другой базе данных.
SELECT *
INTO CustomersBackup2017
IN 'Backup.mdb'
FROM Customers;
  
// Следующий оператор SQL копирует только несколько столбцов в новую таблицу.
SELECT CustomerName, ContactName
INTO CustomersBackup2017
FROM Customers;
</code></pre>
          <h3>Индексы</h3>
          <p>
            Индексы - повышают производительность выполнения запросов SELECT.<br />
            СУБД применяют индексы при выполнении операторов автоматически.
          </p>
          <pre><code>// Создать индекс, название индекса table_field_idx, индекс создаётся для столбца field таблицы table
CREATE INDEX table_field_idx
ON table(field)

// Удаление индекса
DROP INDEX table_field_idx;
</code></pre>
          <h3>Агрегатные функции</h3>
          <p>COUNT - считает количество записей в таблице table</p>
          <pre><code>SELECT COUNT(*)
FROM table

// Считает количество записей в столбцe field_2 таблицы table
SELECT COUNT(field_2)
FROM table

// Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам и посчитать сколько записей каждого вида
SELECT field_2,
COUNT(*)
FROM table
GROUP BY field_2
  
// Выбрать столбец field_2, сгруппировать в стобце field_2 значения по видам, посчитать сколько записей каждого вида в столбце field_3 и вывести в новом столбе field_3
SELECT field_2,
COUNT(field_2) AS field_3
FROM table
GROUP BY field_2
</code></pre>
          <p>
            SUM - Возвращает сумму значений в указанном столбце.<br />
            Выбрать столбец field_2, сгруппировать в столбце field_2 значения по видам, посчитать сколько записей каждого вида и суммировать значения в столбце field_3 соответствующих сгруппированным видам.
          </p>
          <pre><code>SELECT field_2,
COUNT(*),
SUM(field_3)
FROM table
GROUP BY field_2
</code></pre>
          <ul>
            <li>AVG - Возвращает среднее значение в указанном столбце.</li>
            <li>Выбрать столбец field_2, сгруппировать в столбце field_2 значения по видам, посчитать среднее значение по каждому виду в столбце field_3.</li>
            <li>Среднее рассчитывается со знаками после запятой.</li>
          </ul>
          <pre><code>SELECT field_2,
AVG(field_3) 
FROM table
GROUP BY field_2
  
// Посчитать среднее без знака после запятой
SELECT field_2,
SUM(field_3)/COUNT(*)
AS average 
FROM table
GROUP BY field_2
</code></pre>
          <ul>
            <li>MIN - Возвращает минимальное значение в указанном столбце.</li>
            <li>Выбрать столбец field_2, сгруппировать в столбце field_2 значения по видам.</li>
            <li>Определить минимальное и максимальное значение каждого вида в столбце field_3.</li>
            <li>Вывести столбец field_2 с группированными значениями, столбец минимальных и столбец максимальных значений каждого вида, отсортировать по убыванию по столбцу максимальных значений.</li>
          </ul>
          <pre><code>SELECT field_2,
MIN(field_3),
MAX(field_3)
FROM table
GROUP BY field_2
ORDER BY MAX(field_3) DESC</code></pre>
          <p>
            MAX - Возвращает максимальное значение в указанном столбце.<br />
            Считает все функции в таблице table
          </p>
          <pre><code>SELECT COUNT(*),
MIN(field_2),
MAX(field_2),
SUM(field_2),
AVG(field_2)
FROM table
</code></pre>
          <p>LENGTH() - возвращает длину строки</p>
          <pre><code>SELECT field_1
FROM table
WHERE LENGTH(field_2) > 15;
</code></pre>
          <h3>Подзапросы (subqueries)</h3>
          <ul>
            <li>Сначала выполняются подзапросы.</li>
            <li>Выбрать из таблицы table все строки со значением value_3 в столбце field_1, отсортировать по видам в столбце field_2, посчитать количество строк по каждому виду, отсортировать виды, у которых количество строк больше 10.</li>
            <li>HAVING работает с результатами группировки.</li>
          </ul>
          <pre><code>SELECT field_2, COUNT(*)
FROM table
WHERE field_1 = value_3
GROUP BY field_2
HAVING COUNT(*) > 10

// Выбрать столбцы field_2 и field_3 из таблицы table и выбрать максимальное значение столбца field_3 таблицы table
SELECT field_2, field_3
FROM table
WHERE field_3 = (
  SELECT MAX(field_3) 
  FROM table)
  
// Выбрать столбцы field_2 и field_3 из таблицы table_1 и отобрать строки, id которых есть в столбце field_table_1_id таблицы table_2
SELECT field_2, field_3
FROM table_1
WHERE id IN (
  SELECT field_table_1_id 
  FROM table_2)

// Выбрать значения id таблицы table_1 у которых в столбце field_3 значение value_1, увеличить значения столбца field_2 на 500 в строках, у которых значение в столбце field_table_1_id равно значениям отобранных id
UPDATE table_2
SET field_2 = field_2 + 500
WHERE field_table_1_id = (
  SELECT id 
  FROM table_1
  WHERE field_3 = value_1)
</code></pre>
          <h3>Представления</h3>
          <ul>
            <li>Представление VIEW - псевдоним для запроса SELECT.</li>
            <li>Данные в представлении не хранятся, представление ссылается на таблицу.</li>
            <li>Представление можно создавать из нескольких таблиц.</li>
            <li>Используется как обычная таблица.</li>
            <li>Применяется для ограничения доступа к данным, сокрытия реализации БД, для избегания повторять выполнение сложных запросов и составных таблиц.</li>
          </ul>
          <pre><code>CREATE VIEW table_v field_1, field_2
AS SELECT field_1, field_2
FROM table

// Удалить представление
DROP VIEW</code></pre>
          <ul>
            <li>Материализованное представление MATERIALIZED VIEW - псевдоним для запроса SELECT.</li>
            <li>Поддерживаются не всеми СУБД.</li>
            <li>Данные хранятся в представлении.</li>
            <li>Представление можно создавать из нескольких таблиц.</li>
            <li>Используется как обычная таблица.</li>
            <li>Применяется для часто используемых запросом с длительным выполнением.</li>
            <li>В случае изменения данных в таблице, на которую ссылается материализованное представление, выполнить REFRESH MATERIALIZED VIEW table_v.</li>
            <li>Удалить материализованное представление DROP MATERIALIZED VIEW.</li>
          </ul>
          <pre><code>CREATE MATERIALIZED VIEW table_v field_1, field_2
AS SELECT field_1, field_2
FROM table
</code></pre>
          <h3>CASE</h3>
          <ul>
            <li>Выражение CASE проходит через условия и возвращает значение, когда выполняется первое условие (как оператор if-then-else).</li>
            <li>Таким образом, как только условие становится истинным, оно прекращает чтение и возвращает результат.</li>
            <li>Если ни одно условие не является истинным, оно возвращает значение в предложении ELSE.</li>
            <li>Если нет части ELSE и ни одно условие не является истинным, оно возвращает NULL.</li>
          </ul>
          <pre><code>CASE
  WHEN condition1 THEN result1
  WHEN condition2 THEN result2
  WHEN conditionN THEN resultN
  ELSE result
END;
</code></pre>
          <h3>JOIN</h3>
          <p>Внутреннее объединение INNER - это соединение строк из одной таблицы для которых есть соответствующие строки из другой таблицы.</p>
          <h4>Неявное объединение</h4>
          <p>Выбрать все столбцы из таблицы table_1 и table_2, строки сопоставить по значению в столбце id (PRIMARY KEY) table_1 равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2</p>
          <pre><code>SELECT *
FROM table_1, table_2
WHERE table_1.id = table_2.field_table_1_id

// либо
SELECT * FROM table_1 
CROSS JOIN table_2 
WHERE table_1.id = table_2.field_table_1_id
</code></pre>
          <h4>Явное объединение</h4>
          <p>Выбрать столбец field.2 из таблицы table_1 и столбец field.3 из table_2, строки сопоставить по значению в столбце id (PRIMARY KEY) table_1 равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2</p>
          <pre><code>SELECT table_1.field.2, table_2.field_3
FROM table_1 JOIN table_2 
ON table_1.id = table_2.field_table_1_id
</code></pre>
          <h4>Псевдонимы</h4>
          <pre><code>SELECT t1.field.2, t2.field_3
FROM table_1 AS t1 
JOIN table_2 AS t2
ON t1.id = t2.field_table_1_id

// либо
SELECT t1.field.2, t2.field_3
FROM table_1 t1 JOIN table_2 t2
ON t1.id = t2.field_table_1_id
</code></pre>
          <ul>
            <li>выбрать столбец field.2 из таблицы table_1 и столбец field.3 из table_2</li>
            <li>строки сопоставить по значению в столбце id (PRIMARY KEY) table_1 равно значению столбца field_table_1_id (FOREIGN KEY) таблицы table_2</li>
            <li>отобрать строки где значение в столбце field_2 таблицы table_1 равно value_1 и где значение в столбце field_3 таблицы table_2 равно value_4</li>
            <li>отсортировать по столбцу field_2 таблицы table_2</li>
          </ul>
          <pre><code>SELECT t1.field.2, t2.field_3
FROM table_1 AS t1 
JOIN table_2 AS t2
ON t1.id = t2.field_table_1_id
WHERE t1.field_2 = value_1
AND t2.field_3 = value_4
ORDER BY t2.field_2 DESC
</code></pre>
          <ul>
            <li>Внутреннее объединение - это соединение строк из одной таблицы для которых нет соответствующих строк из другой таблицы.</li>
            <li>Внешнее объединение {[LEFT] | [RIGHT] | [FULL]} OUTER</li>
          </ul>
          <p>LEFT - все строки таблицы слева от ключевого слова JOIN</p>
          <pre><code>SELECT t1.field.2, t2.field_3
FROM table_1 AS t1 
LEFT OUTER JOIN table_2 AS t2
ON t1.id = t2.field_table_1_id
</code></pre>
          <p>RIGHT - все строки таблицы справа от ключевого слова JOIN</p>
          <pre><code>SELECT t1.field.2, t2.field_3
FROM table_1 AS t1
RIGHT OUTER JOIN< table_2 AS t2
ON t1.id = t2.field_table_1_id
</code></pre>
          <p>FULL - все строки обеих таблиц</p>
          <pre><code>SELECT t1.field.2, t2.field_3
FROM table_1 AS t1 
FULL OUTER JOIN table_2 AS t2
ON t1.id = t2.field_table_1_id
</code></pre>
          <p>Перекрёстное объединение CROSS - это соединение строк из обоих таблиц по принципу каждая с каждой.</p>
          <pre><code>SELECT t1.field.2, t2.field_3
FROM table_1 CROSS JOIN table_2
</code></pre>
          <h3>INSERT</h3>
          <p>INSERT добавляет новые данные</p>
          <pre><code>// Вставить в таблицу table значение value_2 в столбец field_1, value_4 в столбец field_2
INSERT INTO table (field_1, field_2)
VALUES (value_2, value_4);
</code></pre>
          <p>Copy all columns from one table to another table</p>
          <pre><code>INSERT INTO table2
SELECT * FROM table1
WHERE condition;
</code></pre>
          <p>Copy only some columns from one table into another table</p>
          <pre><code>INSERT
INTO table2 (column1, column2, column3, ...)
SELECT column1, column2, column3, ...
FROM table1 WHERE condition;
</code></pre>
          <h3>UPDATE</h3>
          <p>UPDATE изменяет существующие данные</p>
          <pre><code>// Обновить значения value_3 в столбец field_2, value_2 в столбец field_3, в строке с id = 1
UPDATE table
SET field_2 = value_3, field_3 = value_2
WHERE id = 1
</code></pre>
          <p>Обновить значения во всех строках где в столбце field_2 значение value_1, вставить в столбец field_3 значение value_2</p>
          <pre><code>UPDATE table
SET field_3 = value_2
WHERE field_2 = value_1
</code></pre>
          <h3>DELETE</h3>
          <table> 
            <caption>DELETE удаляет данные</caption>
            <tbody> 
              <tr>
                <td>DELETE FROM table WHERE id = 2</td>
                <td>Удалить из таблицы table строку с id = 2</td>
              </tr>
              <tr>
                <td>DELETE FROM table WHERE field_2 = value_1</td>
                <td>Удалить из таблицы table строки со значением value_1 в столбце field_2</td>
              </tr>
              <tr>
                <td>DELETE FROM table</td>
                <td>Удалить из таблицы table все данные</td>
              </tr>
              <tr>
                <td>TRUNCATE TABLE table;</td>
                <td>to delete all data inside a table</td>
              </tr>
            </tbody>
          </table>
          <h3>UNION - объединение</h3>
          <p>
            Применяется для объединения результатов двух SQL-запросов в единую таблицу, состоящую из схожих строк.<br />
            Оба запроса должны возвращать одинаковое число столбцов и совместимые типы данных в соответствующих столбцах!!!
          </p>
          <pre><code>SELECT columns FROM table1
UNION ALL
SELECT columns FROM table2
</code></pre>
          <h3>INTERSECT - пересечение</h3>
          <p>
            Пересечение — множество, состоящее из элементов, которые одновременно принадлежат всем данным множествам.<br />
            INTERSECT, также как и UNION обладает ограничением на результат запросов, которые должны быть совместимы по объединению.
          </p>
          <pre><code>SELECT columns FROM table1
INTERSECT
SELECT columns FROM table2
</code></pre>
          <h3>MINUS или EXCEPT - разность</h3>
          <p>Разность двух множеств — это операция, результатом которой является множество, в которое входят все элементы первого множества, не входящие во второе множество</p>
          <pre><code>SELECT columns FROM table1
MINUS либо EXCEPT
SELECT columns FROM table2
</code></pre>
          <h2>Операторы определения доступа к данным (Data Control Language, DCL)</h2>
          <table> 
            <tbody> 
              <tr>
                <td>GRANT</td>
                <td>предоставляет пользователю (группе) разрешения на определенные операции с объектом</td>
              </tr>
              <tr>
                <td>REVOKE</td>
                <td>отзывает ранее выданные разрешения</td>
              </tr>
              <tr>
                <td>DENY</td>
                <td>задает запрет, имеющий приоритет над разрешением</td>
              </tr>
            </tbody>
          </table>
          <h2>Операторы управления транзакциями (Transaction Control Language, TCL)</h2>
          <p>Транзакция - последовательность команд SQL, которые должны быть выполнены полностью или не выполнены вообще.</p>
          <pre><code>// Например перевод денег со счёта на счёт
START TRANSACTION;
UPDATE accounts
SET balance = balance - 15000
WHERE account_number = 1234567;
UPDATE accounts
SET balance = balance + 15000
WHERE account_number = 9876543;
</code></pre>
          <ul>
            <li>COMMIT применяет транзакцию, записывает изменения в базу данных.</li>
            <li>ROLLBACK откатывает все изменения, сделанные в контексте текущей транзакции.</li>
            <li>В PostgreSQL START TRANSACTION и AUTOCOMMIT включён по умолчанию.</li>
            <li>SET AUTOCOMMIT = value; value может быть 1 (ON) либо 0 (OFF).</li>
            <li>SAVEPOINT - делит транзакцию на более мелкие участки.</li>
          </ul>
        </details>
      </main>
      <menu class="menu">
        <button id="search"><img src="./assets/img/search.svg" alt="search" loading="lazy"/></button>
        <button id="home"><img src="./assets/img/q.svg" alt="home" loading="lazy"/></button>
        <button id="dropup"><img src="./assets/img/menu.svg" alt="menu" loading="lazy"/></button>
      </menu>
    </div>
  </body>
</html>