<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta name="format-detection" content="telephone=no">
    <meta name="robots" content="noindex, nofollow">
    <meta name="robots" content="none">
    <meta name="robots" content="noimageindex, nofollow">
    <link rel="icon" type="image/svg+xml" href="./assets/favicon.svg">
    <link rel="stylesheet" type="text/css" href="./assets/style.css">
    <title>qabook</title>
    <script defer type="module" src="./assets/js/main.js"></script>
  </head>
  <body>
    <nav class="dropup"><a href="./process.html">Process</a><a href="./docs.html">Docs</a><a href="./web.html">Web</a><a href="#!">Project</a><a href="./job.html">Job</a>
    </nav>
    <div class="search">
      <form class="search__content">
        <input type="text" placeholder="search...">
        <button class="search-btn" type="submit"><img src="./assets/img/search.svg" alt="" loading="lazy"/>
        </button>
        <button class="search-reset" type="reset"><img src="./assets/img/close.svg" alt="" loading="lazy"/>
        </button>
      </form>
    </div>
    <button class="close"><img src="./assets/img/close.svg" alt="" loading="lazy"/>
    </button>
    <div class="container">
      <header><nav class="breadcrumbs" id="breadcrumbs-container"></nav>
      </header>
      <main>
        <ul>
          <li><a href="https://vercel.com/home">versel</a>
          </li>
          <li><a href="https://laravel.com">laravel</a>
          </li>
          <li><a href="https://laravel.su/">laravel_ru</a>
          </li>
          <li><a href="https://laracasts.com/">laracasts</a>
          </li>
          <li><a href="https://github.com/illuminate/contracts">Контракты</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/helpers#method-when">глобальные вспомогательные функции</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/http-tests#utverzdeniia-otvetov">доступные утверждения ответов</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/queues#dopolnitelnye-zavisimosti-draiverov">зависимости драйверов</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/queues#xranenie-paketov-v-dynamodb">Хранение пакетов в Amazon DynamoDB</a>
          </li>
          <li><a href="https://supervisord.org/index.html">Supervisor</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/queues#xranenie-neudacnyx-zadanii-v-dynamodb">хранение а Amazon DynamoDB</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/reverb">пакет Laravel Reverb</a>
          </li>
          <li><a href="https://pusher.com/channels/">Pusher Channels</a>
          </li>
          <li><a href="https://ably.io/">Ably</a>
          </li>
          <li><a href="https://github.com/ably/laravel-broadcaster">Ably laravel</a>
          </li>
          <li><a href="https://github.com/laravel/echo">Laravel Echo — библиотека JS для подписки на каналы и прослушивания событий от сервера</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/strings#dostupnye-metody">функции для работы с строковыми значениями</a>
          </li>
          <li><a href="https://www.php.net/manual/ru/pcntl.constants.php">предопределенные константы сигналов процессу</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/scheduling#parametry-periodicnosti-raspisaniia">параметры периодичности расписания</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/scheduling#sobytiia">события планировщика</a>
          </li>
          <li><a href="https://documentation.mailgun.com/en/latest/user_manual.html#tagging-1">Mailgun теги</a>
          </li>
          <li><a href="https://documentation.mailgun.com/en/latest/user_manual.html#attaching-data-to-messages">Mailgun метаданные</a>
          </li>
          <li><a href="https://postmarkapp.com/blog/tags-support-for-smtp">Postmark теги</a>
          </li>
          <li><a href="https://postmarkapp.com/support/article/1125-custom-metadata-faq">Postmark метаданные</a>
          </li>
          <li><a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_MessageTag.html">Amazon SES</a>
          </li>
          <li><a href="https://api.slack.com/apps?new_app=1">создать Slack-приложение</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/socialite">пакет Socialite для OAuth</a>
          </li>
          <li><a href="https://api.slack.com/block-kit">создать уведомление через Slack</a>
          </li>
          <li><a href="https://api.slack.com/interactivity/handling">обработка взаимодействия пользователя</a>
          </li>
          <li><a href="https://alpinejs.dev/">Alpinejs</a>
          </li>
          <li><a href="https://developer.mozilla.org/ru/docs/Web/Events">Events</a>
          </li>
          <li><a href="https://livewire.laravel.com/docs/actions">Cлушатели событий</a>
          </li>
          <li><a href="https://www.youtube.com/watch?v=lCxcTsOHrjo&amp;list=PL0Zuz27SZ-6M8znNpim8dRiICRrP5HPft&amp;index=6">tailwindcss</a>
          </li>
          <li><a href="https://vite.dev/guide/">vite</a>
          </li>
          <li><a href="https://www.youtube.com/watch?v=qVi3vv9K8Fk">laravue</a>
          </li>
          <li><a href="https://www.youtube.com/watch?v=VeNfHj6MhgA">vue</a>
          </li>
          <li><a href="https://www.traversymedia.com/blog/vue-crash-course">vue</a>
          </li>
          <li><a href="https://primevue.org/setup/">prime</a>
          </li>
          <li><a href="https://ui.shadcn.com/docs/installation/vite">shadcn</a>
          </li>
          <li><a href="http://github.com/Mezuno/laravel-collections-doc">Collections</a>
          </li>
          <li><a href="https://laravel.su/docs/12.x/collections#kontrakt-enumerable">методы доступные в классе Collection и LazyCollection</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/pagination#metody-ekzempliara-paginator-i-lengthawarepaginator">экземпляры содержат методы, описывающие результирующий набор</a>
          </li>
          <li><a href="https://laravel.orchid.software/docs/12.x/redis#configuration">настройка Redis</a>
          </li>
          <li><a href="https://pecl.php.net/package/memcached">установить пакет Memcached</a>
          </li>
          <li><a href="https://aws.amazon.com/dynamodb">DynamoDB</a>
          </li>
          <li><a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html">включить TTL</a>
          </li>
          <li><a href="https://www.mongodb.com/docs/drivers/php/laravel-mongodb/current/cache/">MongoDB</a>
          </li>
          <li><a href="https://laravel.orchid.software/docs/12.x/mongodb">Mongodb Laravel</a>
          </li>
          <li><a href="http://laravel.com/docs/12.x/queues#supervisor-configuration">automaticaly ssr on VPS install as root</a>
          </li>
          <li><a href="https://youtu.be/lqKbDEBa2B0">youtube tutorial at 5:20:00</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/eloquent-mutators#privedenie-atributov-k-tipam">Поддерживаемые типы преобразования</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/migrations#dostupnye-psevdonimy-komand">псевдонимы команд</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/migrations#sobytiia">каждая операция миграции отправляет событие</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/migrations#dostupnye-tipy-stolbcov">типы столбцов</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/migrations#modifikatory-stolbca">модификаторы столбцов</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/migrations#dostupnye-tipy-indeksov">типы индексов</a>
          </li>
          <li><a href="http://laravel.su/docs/12.x/migrations#udalenie-indeksov">удалить индекс</a>
          </li>
        </ul>
        <p>
          Laravel  + volt + vue + react + react native (API)<br/>
          блог космополита - описание стран, образа жизни космополита, цифрового кочевника и пилигрима.<br/>
          мобильное приложение - сервисы для экскурсий, паломничества, планирования путешествий и бронирования.<br/>
          
          Laravel - это фреймворк MVC, который использует шаблон проектирования MVC (Model-View-Controller).<br/>
          Разделяет приложение на три основных компонента:
        </p>
        <ul>
          <li>Модель (Model) - отвечает за работу с данными и бизнес-логикой приложения.</li>
          <li>Представление (View) - отвечает за отображение данных пользователю.</li>
          <li>Контроллер (Controller) - связывает модель и представление, обрабатывает запросы и управляет логикой приложения.</li>
        </ul>
        <p>Installing PHP, Composer and the Laravel Installer</p>
        <pre><code>/bin/bash -c "$(curl -fsSL https://php.new/install/linux/8.4)"

laravel new example-app
cd example-app
php artisan sail:install

// добавить псевдоним в ~/.zshrc
alias sail='zsh $([ -f sail ] && echo sail || echo vendor/bin/sail)'
alias sailar='zsh $([ -f sail ] && echo sail artisan || echo vendor/bin/sail artisan)'
sailar list

// запустить фреймворк
sail up -d
sailar migrate
http://localhost

// oбновить образы
docker compose down -v
sail build --no-cache
sail up -d

// установить пакет Telescope</code></pre>
        <table>
          <tbody>
            <tr>
              <td>sail stop</td>
              <td>остановить контейнеры</td>
            </tr>
            <tr>
              <td>sail down</td>
              <td>удалить контейнеры</td>
            </tr>
            <tr>
              <td>sail down -v</td>
              <td>удалить контейнеры и тома</td>
            </tr>
            <tr>
              <td>sail down --rmi all</td>
              <td>удалить контейнеры, тома и образы</td>
            </tr>
            <tr>
              <td>sail down --volumes</td>
              <td>удалить только тома</td>
            </tr>
            <tr>
              <td>sail down --remove-orphans</td>
              <td>удалить контейнеры, которые не определены в docker-compose.yml</td>
            </tr>
            <tr>
              <td>sail build</td>
              <td>пересобрать контейнеры</td>
            </tr>
            <tr>
              <td>sail build --no-cache</td>
              <td>пересобрать контейнеры без кеша</td>
            </tr>
            <tr>
              <td>sail build --pull --no-cache</td>
              <td>пересобрать контейнеры с обновлением образов без кеша</td>
            </tr>
            <tr>
              <td>sail php --version</td>
              <td>версия php</td>
            </tr>
            <tr>
              <td>sail php script.php</td>
              <td>выполнить скрипт php</td>
            </tr>
            <tr>
              <td>sail composer require laravel/sanctum</td>
              <td>установить пакет</td>
            </tr>
            <tr>
              <td>sail npm run dev</td>
              <td>запустить скрипт npm</td>
            </tr>
            <tr>
              <td>sail yarn</td>
              <td>запустить yarn</td>
            </tr>
            <tr>
              <td>sail artisan serve --host=yourhost</td>
              <td>запустить сервер на указанном хосте</td>
            </tr>
            <tr>
              <td>sail artisan queue:work --queue=default=3 --timeout=90 --sleep=3 --delay=0 --max-jobs=1000 --max-time=3600</td>
              <td>запуск очереди</td>
            </tr>
          </tbody>
        </table>
        <h2>Concepts</h2>
        <p>
          Получение запроса<br/>
          index.php получает запрос от веб-сервера (Apache/Nginx):
        </p>
        <ul>
          <li>проверяет, находится ли приложение в режиме обслуживания, запускает автозагрузчик composer, чтобы загрузить установленный фреймворк.</li>
          <li>в переменной app типа Illuminate/Foundation/Application создаёт сервис-контейнер и записывает в него сервис-провайдеры из bootstrap/app.php (маршруты, посредники, исключения), т.е. создаёт приложение: контейнер арр со всеми службами и классами фреймворка.</li>
          <li>передаёт запрос приложению: метод handleRequest() - передаёт запрос HTTP-ядру, метод handleCommand() - передаёт запрос ядру консоли.</li>
        </ul>
        <p>Настройка приложения для обработки запроса</p>
        <ul>
          <li>HTTP-ядро/ядро консоли получает запрос и определяет массив загрузчиков (bootstrappers), для выполнения до обработки запроса.</li>
          <li>Массив загрузчиков (bootstrappers) настраивают обработку ошибок, логирование, определяют среду окружения, конфигурации и стек посредников.</li>
          <li>HTTP-ядро передаёт запрос маршрутизатору, который вернет либо ответ сразу либо запустит посредник для маршрута и отправит запрос на обработку в консоль или контроллер.</li>
          <li>HTTP-ядро передаёт запрос по маршруту через посредников в обработку и возвращает браузеру ответ.</li>
        </ul>
        <p>Обработка запроса</p>
        <ul>
          <li>Стек посредников фильтрует запросы и ответы (Middlewares), обрабатывают чтение и запись сеанса HTTP (Session), проверяет токен CSRF.</li>
          <li>Middleware либо отклонит запрос и перенаправит пользователя либо позволит запросу продолжить работу в приложении.</li>
          <li>Middleware позволяет внести изменения и провести проверки ответа.</li>
          <li>Ответ из middleware поступает в метод handle HTTP-ядра, который вызовит метод send для ответа.</li>
          <li>Метод send отправит содержимое ответа в веб-браузер пользователя.</li>
        </ul>
        <p>Жизненный цикл</p>
        <ul>
          <li>Браузер - запрос пользователя</li>
          <li>Apache / Nginx - веб сервер</li>
          <li>public/index.php - загружает автозагрузчик</li>
          <li>bootstrap/app.php - создаёт экземпляр фреймворка</li>
          <li>laravel - создаёт экземпляр приложения и сервис-контейнер (регистрация всех сервис-провайдеров bootstrap/providers.php)</li>
          <li>НТТР-ядро - запрос поступает НТТР-ядру (либо ядру консоли)</li>
          <li>bootstrappers - массив загрузчиков для обработки ошибок, логирования, среда окружения, middleware</li>
          <li>маршрутизатор - направляет запрос на указанный метод по маршруту</li>
          <li>middleware - фильтрация НТТР-запросов</li>
          <li>контроллер или представление - выполнение метода</li>
          <li>middleware - фильтрация НТТР-ответов</li>
          <li>НТТР-ядро - возвращает объект ответа в экзепмляр приложения</li>
          <li>экземляр приложения - отправляет содержимое ответа в браузер</li>
          <li>Браузер - рендеринг ответа</li>
        </ul>
        <pre><code>Браузер
  Apache / Nginx -> public/index.php -> bootstrap/app.php
    laravel -> экземляр приложения
      НТТР-ядро -> bootstrappers
        маршрутизатор
          middleware
            контроллер -> представление
          middleware
      НТТР-ядро
    экземляр приложения
Браузер
</code></pre>
        <h2>Folder structure</h2>
        <ul>
          <li>app - основная папка приложения, код приложения</li>
          <li>bootstrap - начальная загрузка приложения и кеширование</li>
          <li>config - конфигурация приложения</li>
          <li>database - миграции, фабрики, наполнители (seeders), sqlite</li>
          <li>public - публичная папка приложения, точка входа всех запросов: index.php, оптимизированные ресурсы и автозагрузка</li>
          <li>resources - неотимизированные и нескомпилированные ресурсы: шаблоны, images, js, css</li>
          <li>routes - маршруты приложения на указанный метод</li>
          <li>storage - временные файлы приложения: логи, скомпилированные шаблоны, файлы сессий и кеша</li>
          <li>tests - тесты приложения</li>
          <li>vendor - сomposer-зависимости приложения</li>
          <li>node_modules - node-зависимости приложения</li>
          <li>.gitignore - файл игнорирования git</li>
          <li>.gitattributes - файл атрибутов git</li>
          <li>.dockerignore - файл игнорирования docker</li>
          <li>.docker-compose.yml - файл конфигурации docker</li>
          <li>.env - файл окружения приложения</li>
          <li>.env.example - пример файла окружения приложения</li>
          <li>.editorconfig - файл конфигурации редактора</li>
          <li>artisan - консольная команда приложения</li>
          <li>composer.json - файл сomposer-зависимостей приложения</li>
          <li>package.json - файл node-зависимостей приложения</li>
          <li>phpunit.xml - файл конфигурации тестов приложения</li>
          <li>vite.config.js - файл конфигурации vite приложения</li>
        </ul>
        <h2>Service provider</h2>
        <ul>
          <li>Автозагрузчик для каждого провайдера по списку из bootstrap/app.php, создаст его экземпляр, вызовет метод register и метод boot.</li>
          <li>Сервис-провайдеры отвечают за начальную настройку компонентов фреймворка: база данных, очереди, валидация, маршрутизация и т.д.</li>
          <li>Сервис-провайдеры инициализируют и настраивают множество функций, предоставляемых фреймворком.</li>
          <li>Список пользовательских или сторонних сервис-провайдеров в bootstrap/providers.php</li>
          <li>Cервис-провайдеры созданные пользователем хранятся в каталоге app/Providers.</li>
          <li>Провайдер по умолчанию AppServiceProvider для добавления собственной инициализации и связываний контейнера служб приложения.</li>
        </ul>
        <p>Cгенерировать новый сервис-провайдер в bootstrap/providers.php</p><code>php artisan make:provider RiakServiceProvider</code>
        <p>
          Метод register только для связывания в контейнере служб.<br/>
          В любом из методов сервис-провайдера всегда есть доступ к свойству $app, т.е. к контейнеру служб
          
        </p>
        <pre><code>namespace App\Providers;
use App\Services\Riak\Connection;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\ServiceProvider;

class RiakServiceProvider extends ServiceProvider {
  public function register(): void {
    $this->app->singleton(
      Connection::class,
      function (Application $app) {
        return new Connection(config('riak'));
      }
    );
  }
}
</code></pre>
        <p>Использовать свойства bindings и singletons вместо ручной регистрации каждого связывания контейнера</p>
        <pre><code>namespace App\Providers;
use App\Contracts\DowntimeNotifier;
use App\Contracts\ServerProvider;
use App\Services\DigitalOceanServerProvider;
use App\Services\PingdomDowntimeNotifier;
use App\Services\ServerToolsProvider;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider {
  public $bindings = [ServerProvider::class => DigitalOceanServerProvider::class];
  public $singletons = [
    DowntimeNotifier::class => PingdomDowntimeNotifier::class,
    ServerProvider::class => ServerToolsProvider::class
  ];
}
</code></pre>
        <p>Метод boot вызывается после регистрации всех остальных сервис-провайдеров</p>
        <pre><code>namespace App\Providers;
use Illuminate\Support\Facades\View;
use Illuminate\Support\ServiceProvider;

class ComposerServiceProvider extends ServiceProvider {
  public function boot(): void {
    View::composer('view', function () { ... });
  }
}
</code></pre>
        <p>Внедрение зависимости в методе boot</p>
        <pre><code>use Illuminate\Contracts\Routing\ResponseFactory;

public function boot(ResponseFactory $response): void {
  $response->macro('serialized', function (mixed $value) { ... });
}
</code></pre>
        <p>Регистрация сервис-провайдеров в bootstrap/providers.php</p>
        <ul>
          <li>при команде php artisan make:provider сгенерированный провайдер автоматически добавится в bootstrap/providers.php</li>
          <li>если класс провайдера создан вручную, то вручную добавить класс провайдера в массив в bootstrap/providers.php</li>
        </ul>
        <pre><code>return [
  App\Providers\AppServiceProvider::class,
  App\Providers\ComposerServiceProvider::class
];
</code></pre>
        <p>
          Отложенный сервис-провайдер: регистрирует только связывания в контейнере служб в момент когда это связывание понадобится.  
          Laravel загрузит сервис-провайдер только при необходимости в одной из этих служб.
          
        </p>
        <pre><code>namespace App\Providers;
use App\Services\Riak\Connection;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Contracts\Support\DeferrableProvider;
use Illuminate\Support\ServiceProvider;

class RiakServiceProvider extends ServiceProvider implements DeferrableProvider {
  public function register(): void {
    $this->app->singleton(
      Connection::class,
      function (Application $app) {
        return new Connection($app['config']['riak']);
      }
    );
  }
  public function provides(): array {
    return [Connection::class];
  }
}</code></pre>
        <h2>Service container</h2>
        <p>
          Инструмент для управления зависимостями классов и выполнения внедрения зависимостей.<br/>
          Внедрение зависимостей: зависимости вводятся в класс через конструктор в виде аргументов или через методы-сеттеры.<br/>
          При создании класса или вызове методов фреймворк смотрит на список аргументов, создаёт экземпляры необходимых классов и сам подаёт их на вход конструктора или метода.<br/>
          Контроллеры, слушатели событий, посредники всегда выполняются с помощью контейнера.<br/>
          
        </p>
        <pre><code>namespace App\Http\Controllers;
use App\Services\AppleMusic;
use Illuminate\View\View;

class PodcastController extends Controller {
  public function __construct(protected AppleMusic $apple) {}
  public function show(string $id): View {
    return view(
      'podcasts.show',
      ['podcast' => $this->apple->findPodcast($id)]
    );
  }
}</code></pre>
        <p>
          Неконфигурируемое автоматическое внедрение позволяет получить доступ к объекту не взаимодействуя с контейнером напрямую.<br/>
          Контейнер управляет внедрением зависимостей за кулисами.<br/>
          Благодаря автоматическому внедрению зависимостей и фасадам не нужно вручную связывать или извлекать что-либо из контейнера.
          
        </p>
        <pre><code>// контейнер внедряет объект запроса для обработки функцией маршрута
use Illuminate\Http\Request;
Route::get('/', function (Request $request) { ... });

</code></pre>
        <p>простое связывание: доступ к контейнеру через свойство провайдера $this->app, метод bind - зарегистрировать связывание</p>
        <pre><code>namespace App\Providers;

class AppServiceProvider extends ServiceProvider {
  // имя класса или интерфейса, которые хотим зарегистрировать, $app - контейнер
  $this->app->bind(Transistor::class,
  
    // возвращает экземпляр класса
    function (Application $app) {
      return new Transistor($app->make(PodcastParser::class));
    }
  );
}
</code></pre>
        <p>взаимодействовать с контейнером в других частях приложения через фасад App</p>
        <pre><code>use App\Services\Transistor;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Facades\App;

App::bind(Transistor::class, function (Application $app) { ... });
</code></pre>
        <p>регистрация привязки bindIf только если для данного типа нет зарегистрированной привязки</p>
        <pre><code>$this->app->bindIf(Transistor::class,
  function (Application $app) {
    return new Transistor($app->make(PodcastParser::class));
  }
);
</code></pre>
        <p>связывание одиночек: singleton связывает класс или интерфейс, обращения к которому будут получать один и тот же однажды полученный экземляр</p>
        <pre><code>use App\Services\Transistor;
use App\Services\PodcastParser;
use Illuminate\Contracts\Foundation\Application;

$this->app->singleton(Transistor::class,
  function (Application $app) {
    return new Transistor($app->make(PodcastParser::class));
  }
);
</code></pre>
        <p>singletonIf только если для данного типа нет зарегистрированной привязки</p>
        <pre><code>$this->app->singletonIf(Transistor::class,
  function (Application $app) {
    return new Transistor($app->make(PodcastParser::class));
  }
);
</code></pre>
        <p>связывания одиночек с областью действия:</p>
        <ul>
          <li>scoped связывает класс или интерфейс, экземляр которого получает только один раз в течение жизненного цикла запроса/задания.</li>
          <li>экземпляры, зарегистрированные scoped, сбрасываются каждый раз, когда приложение запускает новый жизненный цикл.</li>
        </ul>
        <pre><code>use App\Services\Transistor;
use App\Services\PodcastParser;
use Illuminate\Contracts\Foundation\Application;

$this->app->scoped(Transistor::class,
  function (Application $app) {
    return new Transistor($app->make(PodcastParser::class));
  }
);
</code></pre>
        <p>scopedIf только если для данного типа нет зарегистрированной привязки с областью действия</p>
        <pre><code>$this->app->scopedIf(Transistor::class,
  function (Application $app) {
    return new Transistor($app->make(PodcastParser::class));
  }
);
</code></pre>
        <p>привязать существующий экземпляр объекта instance: экземпляр всегда будет возвращен из контейнера при последующих вызовах</p>
        <pre><code>use App\Services\Transistor;
use App\Services\PodcastParser;

$service = new Transistor(new PodcastParser);
$this->app->instance(Transistor::class, $service);
</code></pre>
        <p>связывать интерфейс с реализацией: рукописный класс RedisEventPusher реализует интерфейс EventPusher, связать RedisEventPusher</p>
        <pre><code>use App\Contracts\EventPusher;
use App\Services\RedisEventPusher;

$this->app->bind(EventPusher::class, RedisEventPusher::class);
</code></pre>
        <p>это сообщает контейнеру, что он должен внедрить RedisEventPusher, когда требуется реализация EventPusher</p>
        <pre><code>use App\Contracts\EventPusher;
public function __construct(protected EventPusher $pusher) {}
</code></pre>
        <p>
          Контекстная привязка: внедрить разные реализации в каждый класс когда оба класса используют один и тот же интерфейс.<br/>
          Например: два контроллера зависят от разных реализаций контракта Illuminate\Contracts\Filesystem\Filesystem.
          
        </p>
        <pre><code>use App\Http\Controllers\PhotoController;
use App\Http\Controllers\UploadController;
use App\Http\Controllers\VideoController;
use Illuminate\Contracts\Filesystem\Filesystem;
use Illuminate\Support\Facades\Storage;

$this->app->when(PhotoController::class)
  ->needs(Filesystem::class)
  ->give(
  function () {
    return Storage::disk('local');
  }
);
$this->app->when([VideoController::class, UploadController::class])
  ->needs(Filesystem::class)
  ->give(
    function () {
      return Storage::disk('s3');
    }
  );
</code></pre>
        <p>
          атрибуты контекстной привязки позволяют внедрять типы значений без ручного определения контекстных привязок<br/>
          атрибут Storage используется для внедрения диска хранения
          
        </p>
        <pre><code>namespace App\Http\Controllers;
use Illuminate\Container\Attributes\Storage;
use Illuminate\Contracts\Filesystem\Filesystem;

class PhotoController extends Controller {
  public function __construct(#[Storage('local')] protected Filesystem $filesystem) { ... }
}
</code></pre>
        <p>атрибуты</p>
        <pre><code>namespace App\Http\Controllers;
use App\Models\Photo;
use Illuminate\Container\Attributes\Auth;
use Illuminate\Container\Attributes\Cache;
use Illuminate\Container\Attributes\Config;
use Illuminate\Container\Attributes\DB;
use Illuminate\Container\Attributes\Log;
use Illuminate\Container\Attributes\RouteParameter;
use Illuminate\Container\Attributes\Tag;
use Illuminate\Contracts\Auth\Guard;
use Illuminate\Contracts\Cache\Repository;
use Illuminate\Database\Connection;
use Psr\Log\LoggerInterface;

class PhotoController extends Controller {
  public function__construct(
      # [Auth('web')] protected Guard $auth,
      # [Cache('redis')] protected Repository $cache,
      # [Config('app.timezone')] protected string $timezone,
      # [DB('mysql')] protected Connection $connection,
      # [Log('daily')] protected LoggerInterface $log,
      # [RouteParameter('photo')] protected Photo $photo,
      # [Tag('reports')] protected iterable $reports
  ) { ... }
}
</code></pre>
        <p>атрибут CurrentUser для добавления текущего аутентифицированного пользователя в маршрут или класс</p>
        <pre><code>use App\Models\User;
use Illuminate\Container\Attributes\CurrentUser;
Route::get('/user', function (#[CurrentUser] User $user) {return $user;})->middleware('auth');
</code></pre>
        <p>создать свои контекстные атрибуты: метод resolve атрибута разрешит значение, которое должно быть введено в класс</p>
        <pre><code>namespace App\Attributes;
use Illuminate\Contracts\Container\ContextualAttribute;
# [Attribute(Attribute::TARGET_PARAMETER)]

class Config implements ContextualAttribute {
  public function__construct(public string $key, public mixed $default = null) { }
  public static function resolve(self $attribute, Container $container) {
    return $container->make('config')->get($attribute->key, $attribute->default);
  }
}
</code></pre>
        <p>связывание примитивов</p>
        <pre><code>use App\Http\Controllers\UserController;
$this->app->when(UserController::class)->needs('$variableName')->give($value);
</code></pre>
        <p>класс зависит от массива экземпляров, объединенных меткой контейнера</p>
        <pre><code>$this->app->when(ReportAggregator::class)->needs('$reports')->giveTagged('reports');</code></pre>
        <p>внедрить значение из одного из конфигурационных файлов приложения</p>
        <pre><code>$this->app->when(ReportAggregator::class)->needs('$timezone')->giveConfig('app.timezone');</code></pre>
        <p>класс получает массив типизированных объектов с использованием переменного количества аргументов конструктора</p>
        <pre><code>use App\Models\Filter;
use App\Services\Logger;

class Firewall {
  // экземпляры фильтра
  protected $filters;
  public function __construct(protected Logger $logger, Filter ...$filters) {
    $this->filters = $filters;
  }
}
</code></pre>
        <p>внедрить зависимость, используя метод give с замыканием, которое возвращает массив внедряемых экземпляров Filter</p>
        <pre><code>$this->app->when(Firewall::class)
->needs(Filter::class)
->give(
  function (Application $app) {
    return [
      $app->make(NullFilter::class),
      $app->make(ProfanityFilter::class),
      $app->make(TooLongFilter::class)
    ];
  }
);
</code></pre>
        <p>либо передать массив имен классов, которые будут предоставлены контейнером каждый раз, когда для Firewall нужны экземпляры Filter</p>
        <pre><code>$this->app->when(Firewall::class)
->needs(Filter::class)
->give([NullFilter::class, ProfanityFilter::class, TooLongFilter::class]);
</code></pre>
        <p>для класса с вариативной зависимостью Report...$reports внедрить все привязки с меткой для этой зависимости</p>
        <pre><code>$this->app->when(ReportAggregator::class)->needs(Report::class)->giveTagged('reports');</code></pre>
        <p>добавление меток: получить все привязки определенной «категории», назначить метку некоторым реализациям интерфейса Report</p>
        <pre><code>$this->app->bind(CpuReport::class, function () { ... });
$this->app->bind(MemoryReport::class, function () { ... });
$this->app->tag([CpuReport::class, MemoryReport::class], 'reports');
</code></pre>
        <p>получить помеченные реализации интерфейса Report</p>
        <pre><code>$this->app->bind(
  ReportAnalyzer::class,
  function (Application $app) {
    return new ReportAnalyzer($app->tagged('reports'));
  }
);
</code></pre>
        <p>расширяемость связываний: метод extend позволяет модифицировать извлеченные службы</p>
        <pre><code>$this->app->extend(
  Service::class,
  function (Service $service, Application $app) {
    return new DecoratedService($service);
  }
);
</code></pre>
        <p>извлечение экземпляра класса из контейнера</p>
        <pre><code>use App\Services\Transistor;
$transistor = $this->app->make(Transistor::class);
</code></pre>
        <p>либо передать зависимость как ассоциативный массив</p>
        <pre><code>use App\Services\Transistor;
$transistor = $this->app->makeWith(Transistor::class, ['id' => 1]);
</code></pre>
        <p>был ли класс или интерфейс явно привязан в контейнере</p>
        <pre><code>if ($this->app->bound(Transistor::class)) { ... }</code></pre>
        <p>получить экземпляр класса из контейнера без доступа к поставщику служб и переменной $app</p>
        <pre><code>use App\Services\Transistor;
use Illuminate\Support\Facades\App;

$transistor = App::make(Transistor::class);
$transistor = app(Transistor::class);
</code></pre>
        <p>указать класс Illuminate\Container\Container, чтобы экземпляр контейнера был внедрен в класс, извлекаемый контейнером</p>
        <pre><code>use Illuminate\Container\Container;
public function__construct(protected Container $container) {}
</code></pre>
        <p>
          Автоматическое внедрение зависимостей.<br/>
          зависимости лучше объявлять в конструкторе класса, который извлекается контейнером:<br/>
          контроллеры, слушатели событий, посредники и в методе handle обработки заданий в очереди
        </p>
        <pre><code>namespace App\Http\Controllers;
use App\Services\AppleMusic;
class PodcastController extends Controller {
  // сервис будет автоматически получен и внедрен в класс
  public function __construct(protected AppleMusic $apple) {}
  public function show(string $id): Podcast {
    return $this->apple->findPodcast($id);
  }
}
</code></pre>
        <p>Вызов и внедрение метода</p>
        <pre><code>namespace App;
use App\Services\AppleMusic;

class PodcastStats {
  public function generate(AppleMusic $apple): array {return [ ... ];}
}
</code></pre>
        <p>вызвать метод generate через контейнер</p>
        <pre><code>use App\PodcastStats;
use Illuminate\Support\Facades\App;
$stats = App::call([new PodcastStats, 'generate']);

// либо
use App\Services\AppleMusic;
use Illuminate\Support\Facades\App;
$result = App::call(function (AppleMusic $apple) { ...});
</code></pre>
        <p>
          События контейнера: контейнер служб инициирует событие каждый раз, когда извлекает объект.<br/>
          прослушать событие контейнера служб: объект будет передан в замыкание для добавления свойств перед передачей получателю
        </p>
        <pre><code>use App\Services\Transistor;
use Illuminate\Contracts\Foundation\Application;

$this->app->resolving(
  Transistor::class,
  function (Transistor $transistor, Application $app) {
    // Вызывается, когда контейнер извлекает объекты типа `Transistor`
  }
);
$this->app->resolving(
  function (mixed $object, Application $app) {
    // Вызывается, когда контейнер извлекает объект любого типа
  }
);
</code></pre>
        <p>
          перепривязка: rebinding прослушивает повторную привязку службы к контейнеру  
          полезно для обновления зависимостей или изменения поведения при обновлении привязки
        </p>
        <pre><code>use App\Contracts\PodcastPublisher;
use App\Services\SpotifyPublisher;
use App\Services\TransistorPublisher;
use Illuminate\Contracts\Foundation\Application;

$this->app->bind(PodcastPublisher::class, SpotifyPublisher::class);
$this->app->rebinding(PodcastPublisher::class, function (Application $app, PodcastPublisher $newInstance) { });
</code></pre>
        <p>новая привязка вызовет повторное замыкание</p>
        <pre><code>$this->app->bind(PodcastPublisher::class, TransistorPublisher::class);</code></pre>
        <p>контейнер служб Laravel реализует интерфейс PSR-11: получить экземпляр контейнера</p>
        <pre><code>use App\Services\Transistor;
use Psr\Container\ContainerInterface;

Route::get(
  '/',
  function (ContainerInterface $container) {
    $service = $container->get(Transistor::class);
  }
);</code></pre>
        <h2>Facades & Contracts</h2>
        <ul>
          <li>Контракты - набор интерфейсов для основных служб фреймворка.</li>
          <li>Контракты требуют инициализации в конструкторе класса позволяют определять явные зависимости для этого класса.</li>
          <li>Контракты и фасады не исключают друг друга.</li>
          <li>При создании пакета, который будет интегрирован с несколькими PHP-фреймворками, можно указать пакет illuminate/contracts в файле composer.json для интеграции со службами Laravel.</li>
          <li>Чтобы получить экземляр контракта, нужно внедрить интерфейс в конструктор извлекаемого класса, когда слушатель события будет вызван, сервис-контейнер, инициализирует тип Factory в конструкторе класса.</li>
        </ul>
        <ul>
          <li>Фасады - статические прокси для базовых классов в контейнере служб, и обеспечивающих доступ почти ко всему функционалу Laravel.</li>
          <li>Фасад – это класс, который обеспечивает доступ к объекту из контейнера.</li>
          <li>Фасады и хелперы обеспечивают использование сервисов без объявления типа зависимости и извлечения контракта из сервис-контейнера.</li>
        </ul>
        <pre><code>namespace App\Listeners;
use App\Events\OrderWasPlaced;
use App\Models\User;
use Illuminate\Contracts\Redis\Factory;

class CacheOrderInformation {

  // создать экземпляр обработчика событий
  public function __construct(protected Factory $redis) {}

  // обработать событие
  public function handle(OrderWasPlaced $event): void {}
}
</code></pre>
        <p>Фасад и помощники</p>
        <pre><code>use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Route;

// фасад
Route::get('/cache', function () {return Cache::get('key');});

use Illuminate\Support\Facades\Response;

// фасад
Route::get('/users', function () {return Response::json([ .. ]);});
// помощник
Route::get('/users', function () {return response()->json([ ... ]);});

// фасад
return Illuminate\Support\Facades\View::make('profile');
// помощник
return view('profile');

use Illuminate\Support\Facades\Cache;

// фасад
Route::get('/cache', function () {return Cache::get('key');});
// помощник
Route::get('/cache', function () {return cache('key');});
</code></pre>
        <p>тест фасада</p>
        <pre><code>use Illuminate\Support\Facades\Cache;

test('basic example', function () {
  Cache::shouldReceive('get')
  ->with('key')
  ->andReturn('value');
  $response = $this->get('/cache');
  $response->assertSee('value');
});
</code></pre>
        <p>тест помощника</p>
        <pre><code>use Illuminate\Support\Facades\Cache;

public function test_basic_example(): void {
  Cache::shouldReceive('get')
  ->with('key')
  ->andReturn('value');
  $response = $this->get('/cache');
  $response->assertSee('value');
}

</code></pre>
        <p>пример:</p>
        <pre><code>namespace App\Models;
use App\Contracts\Publisher;
use Illuminate\Database\Eloquent\Model;

class Podcast extends Model {
  public function publish(Publisher $publisher): void {
    $this->update(['publishing' => now()]);
    $publisher->publish($this);
  }
}

</code></pre>
        <p>сгенерировать фасад в реальном времени (добавить Facades\ к импорту класса) - экземпляр Publisher получен из контейнера службы</p>
        <pre><code>namespace App\Models;
use Facades\App\Contracts\Publisher;
use Illuminate\Database\Eloquent\Model;

class Podcast extends Model {
  public function publish(): void {
    $this->update(['publishing' => now()]);
    $publisher->publish($this);
    Publisher::publish($this);
  }
}
</code></pre>
        <p>тестировать</p>
        <pre><code>use App\Models\Podcast;
use Facades\App\Contracts\Publisher;
use Illuminate\Foundation\Testing\RefreshDatabase;

uses(RefreshDatabase::class);

test('podcast can be published', function () {
  $podcast = Podcast::factory()->create();
  Publisher::shouldReceive('publish')->once()->with($podcast);
  $podcast->publish();
});</code></pre>
        <table>
          <thead>
            <tr>
              <th>Контракт (Illuminate\Contracts\)</th>
              <th>Фасад</th>
              <th>Класс фасада</th>
              <th>Привязка в контейнере</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Auth\Access\Authorizable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Auth\Access\Gate</td>
              <td>Gate</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Auth\Authenticatable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Auth\CanResetPassword</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Auth\Factory</td>
              <td>Auth</td>
              <td>Illuminate\Auth\AuthManager</td>
              <td>auth</td>
            </tr>
            <tr>
              <td>Auth\Guard</td>
              <td>Auth::guard()</td>
              <td> </td>
              <td>auth.driver</td>
            </tr>
            <tr>
              <td>Auth\PasswordBroker</td>
              <td>Password::broker()</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Auth\PasswordBrokerFactory</td>
              <td>Password</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Auth\StatefulGuard</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Auth\SupportsBasicAuth</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Auth\UserProvider</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Blade</td>
              <td>Illuminate\View\Compilers\BladeCompiler</td>
              <td>blade.compiler</td>
            </tr>
            <tr>
              <td>Broadcasting\Broadcaster</td>
              <td>Broadcast::connection()</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Broadcasting\Factory</td>
              <td>Broadcast</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Broadcasting\ShouldBroadcast</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Broadcasting\ShouldBroadcastNow</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Bus\Dispatcher</td>
              <td>Bus</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Bus\QueueingDispatcher</td>
              <td>Bus::dispatchToQueue()</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Cache\Factory</td>
              <td>Cache</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Cache\Lock</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Cache\LockProvider</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Cache\Repository</td>
              <td>Cache::driver()</td>
              <td>Illuminate\Cache\Repository</td>
              <td>cache.store</td>
            </tr>
            <tr>
              <td>Cache\Store</td>
              <td>Cache</td>
              <td>Illuminate\Cache\CacheManager</td>
              <td>cache</td>
            </tr>
            <tr>
              <td>Config\Repository</td>
              <td>Config</td>
              <td>Illuminate\Config\Repository</td>
              <td>config</td>
            </tr>
            <tr>
              <td>Console\Application</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Console\Kernel</td>
              <td>Artisan</td>
              <td> </td>
              <td>artisan</td>
            </tr>
            <tr>
              <td>Container\Container</td>
              <td>App</td>
              <td>Illuminate\Foundation\Application</td>
              <td>арр</td>
            </tr>
            <tr>
              <td>Foundation\Application</td>
              <td>App</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Context</td>
              <td>Illuminate\Log\Context\Repository</td>
              <td> </td>
            </tr>
            <tr>
              <td>Cookie\Factory</td>
              <td>Cookie</td>
              <td>Illuminate\Cookie\CookieJar</td>
              <td>cookie</td>
            </tr>
            <tr>
              <td>Cookie\QueueingFactory</td>
              <td>Cookie::queue()</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Date</td>
              <td>Illuminate\Support\DateFactory</td>
              <td>date</td>
            </tr>
            <tr>
              <td> </td>
              <td>DB (Instance)</td>
              <td>Illuminate\Database\Connection</td>
              <td>db.connection</td>
            </tr>
            <tr>
              <td> </td>
              <td>DB</td>
              <td>Illuminate\Database\DatabaseManager</td>
              <td>db</td>
            </tr>
            <tr>
              <td>Database\ModelIdentifier</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Debug\ExceptionHandler</td>
              <td>Exceptions (Instance)</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Encryption\Encrypter</td>
              <td>Crypt</td>
              <td>Illuminate\Encryption\Encrypter</td>
              <td>encrypter</td>
            </tr>
            <tr>
              <td>Events\Dispatcher</td>
              <td>Event</td>
              <td>Illuminate\Events\Dispatcher</td>
              <td>events</td>
            </tr>
            <tr>
              <td> </td>
              <td>Exceptions</td>
              <td>Illuminate\Foundation\Exceptions\Handler</td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>File</td>
              <td>Illuminate\Filesystem\Filesystem</td>
              <td>files</td>
            </tr>
            <tr>
              <td> </td>
              <td>Storage</td>
              <td>Illuminate\Filesystem\FilesystemManager</td>
              <td>filesystem</td>
            </tr>
            <tr>
              <td>Filesystem\Cloud</td>
              <td>Storage::cloud()</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Filesystem\Factory</td>
              <td>Storage</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Filesystem\Filesystem</td>
              <td>Storage::disk()</td>
              <td> </td>
              <td>filesystem.disk</td>
            </tr>
            <tr>
              <td>Hashing\Hasher</td>
              <td>Hash</td>
              <td> </td>
              <td>hash</td>
            </tr>
            <tr>
              <td> </td>
              <td>Http</td>
              <td>Illuminate\Http\Client\Factory</td>
              <td> </td>
            </tr>
            <tr>
              <td>Http\Kernel</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Lang</td>
              <td>Illuminate\Translation\Translator</td>
              <td>translator</td>
            </tr>
            <tr>
              <td> </td>
              <td>Log</td>
              <td>Illuminate\Log\LogManager</td>
              <td>log</td>
            </tr>
            <tr>
              <td>Mail\Mailable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Mail\Mailer</td>
              <td>Mail</td>
              <td>Illuminate\Mail\Mailer</td>
              <td>mailer</td>
            </tr>
            <tr>
              <td>Mail\MailQueue</td>
              <td>Mail::queue()</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Notifications\Dispatcher</td>
              <td>Notification</td>
              <td>Illuminate\Notifications\ChannelManager</td>
              <td> </td>
            </tr>
            <tr>
              <td>Notifications\Factory</td>
              <td>Notification</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Pagination\LengthAwarePaginator</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Pagination\Paginator</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Pipeline\Hub</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Pipeline\Pipeline</td>
              <td>Pipeline</td>
              <td>Illuminate\Pipeline\Pipeline</td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Password (Instance)</td>
              <td>Illuminate\Auth\Passwords\PasswordBroker</td>
              <td>auth.password.broker</td>
            </tr>
            <tr>
              <td> </td>
              <td>Password</td>
              <td>Illuminate\Auth\Passwords\PasswordBrokerManager</td>
              <td>auth.password</td>
            </tr>
            <tr>
              <td> </td>
              <td>Process</td>
              <td>Illuminate\Process\Factory</td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Queue</td>
              <td>Illuminate\Queue\Queue</td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Queue</td>
              <td>Illuminate\Queue\QueueManager</td>
              <td>queue</td>
            </tr>
            <tr>
              <td>Queue\EntityResolver</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Queue\Factory</td>
              <td>Queue</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Queue\Job</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Queue\Monitor</td>
              <td>Queue</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Queue\Queue</td>
              <td>Queue::connection()</td>
              <td> </td>
              <td>queue.connection</td>
            </tr>
            <tr>
              <td>Queue\QueueableCollection</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Queue\QueueableEntity</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Queue\ShouldQueue</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>RateLimiter</td>
              <td>Illuminate\Cache\RateLimiter</td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Redirect</td>
              <td>Illuminate\Routing\Redirector</td>
              <td>redirect</td>
            </tr>
            <tr>
              <td> </td>
              <td>Redis (Instance)</td>
              <td>Illuminate\Redis\Connections\Connection</td>
              <td>redis.connection</td>
            </tr>
            <tr>
              <td> </td>
              <td>Redis</td>
              <td>Illuminate\Redis\RedisManager</td>
              <td>redis</td>
            </tr>
            <tr>
              <td>Redis\Factory</td>
              <td>Redis</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Request</td>
              <td>Illuminate\Http\Request</td>
              <td>request</td>
            </tr>
            <tr>
              <td> </td>
              <td>Response (Instance)</td>
              <td>Illuminate\Http\Response</td>
              <td> </td>
            </tr>
            <tr>
              <td>Routing\BindingRegistrar</td>
              <td>Route</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Routing\Registrar</td>
              <td>Route</td>
              <td>Illuminate\Routing\Router</td>
              <td>router</td>
            </tr>
            <tr>
              <td>Routing\ResponseFactory</td>
              <td>Response</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Routing\UrlGenerator</td>
              <td>URL</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Routing\UrlRoutable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Schedule</td>
              <td>Illuminate\Console\Scheduling\Schedule</td>
              <td> </td>
            </tr>
            <tr>
              <td>Schema</td>
              <td>Illuminate\Database\Schema\Builder</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Session\Session</td>
              <td>Session::driver()</td>
              <td>Illuminate\Session\Store</td>
              <td>session.store</td>
            </tr>
            <tr>
              <td> </td>
              <td>Session</td>
              <td>Illuminate\Session\SessionManager</td>
              <td>session</td>
            </tr>
            <tr>
              <td>Support\Arrayable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Support\Htmlable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Support\Jsonable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Support\MessageBag</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Support\MessageProvider</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Support\Renderable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Support\Responsable</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Translation\Loader</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Translation\Translator</td>
              <td>Lang</td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>URL</td>
              <td>Illuminate\Routing\UrlGenerator</td>
              <td>url</td>
            </tr>
            <tr>
              <td>Validation\Factory</td>
              <td>Validator</td>
              <td>Illuminate\Validation\Factory</td>
              <td>validator</td>
            </tr>
            <tr>
              <td>Validation\ValidatesWhenResolved</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Validation\ValidationRule</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>Validation\Validator</td>
              <td>Validator::make()</td>
              <td>Illuminate\Validation\Validator</td>
              <td> </td>
            </tr>
            <tr>
              <td>View\Engine</td>
              <td> </td>
              <td> </td>
              <td> </td>
            </tr>
            <tr>
              <td>View\Factory</td>
              <td>View</td>
              <td>Illuminate\View\Factory</td>
              <td>view</td>
            </tr>
            <tr>
              <td>View\View</td>
              <td>View::make()</td>
              <td>Illuminate\View\View</td>
              <td> </td>
            </tr>
            <tr>
              <td> </td>
              <td>Vite</td>
              <td>Illuminate\Foundation\Vite</td>
              <td> </td>
            </tr>
          </tbody>
        </table>
        <h2>Массивы и объекты</h2>
        <p>Arr::accessible - доступно ли переданное значение массиву (true/false)</p>
        <pre><code>use Illuminate\Support\Arr;
use Illuminate\Support\Collection;

$isAccessible = Arr::accessible(['a' => 1, 'b' => 2]);
$isAccessible = Arr::accessible(new Collection);
$isAccessible = Arr::accessible('abc');
$isAccessible = Arr::accessible(new stdClass);
</code></pre>
        <p>Arr::add - добавляет ключ/значение в массив, если ключа нет в массиве или установлен как null</p>
        <pre><code>$array = Arr::add(['name' => 'Desk'], 'price', 100);
$array = Arr::add(['name' => 'Desk', 'price' => null], 'price', 100);
</code></pre>
        <p>Arr::collapse - сворачивает массив массивов в один массив</p>
        <pre><code>// [1, 2, 3, 4, 5, 6, 7, 8, 9]
$array = Arr::collapse([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);
</code></pre>
        <p>Arr::crossJoin - перекрестно соединяет массивы</p><code>$matrix = Arr::crossJoin([1, 2], ['a', 'b']);</code>
        <p>Arr::divide - возвращает два массива: один содержит ключи, другой – значения</p><code>[$keys, $values] = Arr::divide(['name' => 'Desk']);</code>
        <p>Arr::dot - объединяет многомерный массив в одноуровневый</p>
        <pre><code>$array = ['products' => ['desk' => ['price' => 100]]];

// ['products.desk.price' => 100]
$flattened = Arr::dot($array);
</code></pre>
        <p>Arr::undot - расширяет одномерный массив в многомерный</p>
        <pre><code>$array = ['user.name' => 'Kevin Malone', 'user.occupation' => 'Accountant'];

// ['user' => ['name' => 'Kevin Malone', 'occupation' => 'Accountant']]
$array = Arr::undot($array);
</code></pre>
        <p>Arr::except - удаляет переданные пары ключ/значение из массива</p>
        <pre><code>$array = ['name' => 'Desk', 'price' => 100];

// ['name' => 'Desk']
$filtered = Arr::except($array, ['price']);
</code></pre>
        <p>Arr::only - возвращает только указанные пары ключ/значение</p>
        <pre><code>$array = ['name' => 'Desk', 'price' => 100, 'orders' => 10];

// ['name' => 'Desk', 'price' => 100]
$slice = Arr::only($array, ['name', 'price']);
</code></pre>
        <p>Arr::exists - проверяет, существует ли ключ в массиве</p>
        <pre><code>$array = ['name' => 'John Doe', 'age' => 17];

// true
$exists = Arr::exists($array, 'name');

// false
$exists = Arr::exists($array, 'salary');
</code></pre>
        <p>Arr::first - возвращает первый элемент массива, соответствующий условию</p>
        <pre><code>$array = [100, 200, 300];
$first = Arr::first($array, function (int $value, int $key) {return $value >= 150;});

// 200 либо со значением по умолчанию, на случай если нет соответствий с условием
$first = Arr::first($array, $callback, $default);
</code></pre>
        <p>Arr::last - возвращает последний элемент массива, соответствующий условию</p>
        <pre><code>$array = [100, 200, 300, 110];
$last = Arr::last($array, function (int $value, int $key) {return $value >= 150;});

// 300 либо со значением по умолчанию, на случай если нет соответствий с условием
$last = Arr::last($array, $callback, $default);
</code></pre>
        <p>Arr::flatten - объединяет многомерный массив в одноуровневый</p>
        <pre><code>$array = ['name' => 'Joe', 'languages' => ['PHP', 'Ruby']];

// ['Joe', 'PHP', 'Ruby']
$flattened = Arr::flatten($array);
</code></pre>
        <p>Arr::forget - удаляет ключ/значение из глубоко вложенного массива</p>
        <pre><code>$array = ['products' => ['desk' => ['price' => 100]]];

// ['products' => []]
Arr::forget($array, 'products.desk');
</code></pre>
        <p>Arr::get - извлекает значение из глубоко вложенного массива</p>
        <pre><code>use Illuminate\Support\Arr;

$array = ['products' => ['desk' => ['price' => 100]]];

// 100
$price = Arr::get($array, 'products.desk.price');

// либо со значением по умолчанию, если указанный ключ отсутствует в массиве, вернёт 0
$discount = Arr::get($array, 'products.desk.discount', 0);
</code></pre>
        <p>Arr::has - проверяет, существует ли переданный элемент или элементы в массиве</p>
        <pre><code>$array = ['product' => ['name' => 'Desk', 'price' => 100]];

// true
$contains = Arr::has($array, 'product.name');

// false
$contains = Arr::has($array, ['product.price', 'product.discount']);
</code></pre>
        <p>Arr::hasAny - проверяет, существует ли какой-либо элемент в переданном наборе в массиве</p>
        <pre><code>$array = ['product' => ['name' => 'Desk', 'price' => 100]];

// true
$contains = Arr::hasAny($array, 'product.name');

// true
$contains = Arr::hasAny($array, ['product.name', 'product.discount']);

// false
$contains = Arr::hasAny($array, ['category', 'product.discount']);
</code></pre>
        <p>Arr::isAssoc - массив считается ассоциативным, если в нем нет последовательных цифровых ключей, начинающихся с нуля</p>
        <pre><code>// true
$isAssoc = Arr::isAssoc(['product' => ['name' => 'Desk', 'price' => 100]]);

// false
$isAssoc = Arr::isAssoc([1, 2, 3]);
</code></pre>
        <p>Arr::isList - ключи массива - последовательные целые числа, начиная с нуля</p>
        <pre><code>// true
$isList = Arr::isList(['foo', 'bar', 'baz']);

// false
$isList = Arr::isList(['product' => ['name' => 'Desk', 'price' => 100]]);
</code></pre>
        <p>Arr::join - объединяет элементы массива в строку</p>
        <pre><code>$array = ['Tailwind', 'Alpine', 'Laravel', 'Livewire'];

// Tailwind, Alpine, Laravel, Livewire
$joined = Arr::join($array, ', ');

// Tailwind, Alpine, Laravel and Livewire
$joined = Arr::join($array, ', ', ' and ');
</code></pre>
        <p>Arr::keyBy - присваивает ключи элементам базового массива</p>
        <pre><code>$array = [
  ['product_id' => 'prod-100', 'name' => 'Desk'],
  ['product_id' => 'prod-200', 'name' => 'Chair']
];

/** вернёт  [
  *   'prod-100' => ['product_id' => 'prod-100', 'name' => 'Desk'],
  *   'prod-200' => ['product_id' => 'prod-200', 'name' => 'Chair']
  * ]
  */
$keyed = Arr::keyBy($array, 'product_id');
</code></pre>
        <p>Arr::map - проходит по массиву и применяет функцию к каждому элементу</p>
        <pre><code>$array = ['first' => 'james', 'last' => 'kirk'];

// ['first' => 'James', 'last' => 'Kirk']
$mapped = Arr::map(
  $array,
  function (string $value, string $key) {
    return ucfirst($value);
  }
);
</code></pre>
        <p>Arr::mapSpread - формирует новый массив, применяя функцию к значениям вложенных элементов</p>
        <pre><code>$array = [[0, 1], [2, 3], [4, 5], [6, 7], [8, 9]];

// [1, 5, 9, 13, 17]
$mapped = Arr::mapSpread(
  $array,
  function (int $even, int $odd) {
    return $even + $odd;
  }
);
</code></pre>
        <p>Arr::mapWithKeys - формирует новый массив, применяя функцию к ключам вложенных элементов</p>
        <pre><code>$array = [
  ['name' => 'John', 'department' => 'Sales', 'email' => 'john@example.com'],
  ['name' => 'Jane', 'department' => 'Marketing', 'email' => 'jane@example.com']
];

// ['john@example.com' => 'John', 'jane@example.com' => 'Jane']
$mapped = Arr::mapWithKeys(
  $array,
  function (array $item, int $key) {
    return [$item['email'] => $item['name']];
  }
);
</code></pre>
        <p>Arr::pluck - извлекает все значения указанного ключа</p>
        <pre><code>$array = [
  ['developer' => ['id' => 1, 'name' => 'Taylor']],
  ['developer' => ['id' => 2, 'name' => 'Abigail']]
];

// ['Taylor', 'Abigail']
$names = Arr::pluck($array, 'developer.name');

// либо, вернёт [1 => 'Taylor', 2 => 'Abigail']
$names = Arr::pluck($array, 'developer.name', 'developer.id');
</code></pre>
        <p>Arr::prepend - помещает элемент в начало массива</p>
        <pre><code>use Illuminate\Support\Arr;

$array = ['one', 'two', 'three', 'four'];

// ['zero', 'one', 'two', 'three', 'four']
$array = Arr::prepend($array, 'zero');

// либо
$array = ['price' => 100];

// ['name' => 'Desk', 'price' => 100]
$array = Arr::prepend($array, 'Desk', 'name');
</code></pre>
        <p>Arr::prependKeysWith - добавляет указанный префикс ко всем именам ключей ассоциативного массива</p>
        <pre><code>$array = ['name' => 'Desk', 'price' => 100];

// ['product.name' => 'Desk', 'product.price' => 100]
$keyed = Arr::prependKeysWith($array, 'product.');
</code></pre>
        <p>Arr::pull - возвращает и удаляет пару ключ/значение из массива</p>
        <pre><code>$array = ['name' => 'Desk', 'price' => 100];

// $name: Desk    $array: ['price' => 100]
$name = Arr::pull($array, 'name');

// либо значение по умолчанию, если ключ не существует
$value = Arr::pull($array, $key, $default);
</code></pre>
        <p>Arr::query - преобразует массив в строку запроса</p>
        <pre><code>$array = ['name' => 'Taylor', 'order' => ['column' => 'created_at', 'direction' => 'desc']];

// name=Taylor&order[column]=created_at&order[direction]=desc
Arr::query($array);
</code></pre>
        <p>Arr::random - возвращает случайное значение из массива</p>
        <pre><code>$array = [1, 2, 3, 4, 5];

// 4
$random = Arr::random($array);

// либо вернуть несколько случайных значений из массива, вернёт [2, 5]
$items = Arr::random($array, 2);
</code></pre>
        <p>Arr::set - устанавливает значение во вложенном массиве</p>
        <pre><code>$array = ['products' => ['desk' => ['price' => 100]]];

// ['products' => ['desk' => ['price' => 200]]]
Arr::set($array, 'products.desk.price', 200);
</code></pre>
        <p>Arr::shuffle - случайным образом перемешивает элементы в массиве</p>
        <pre><code>// [3, 2, 5, 1, 4]
$array = Arr::shuffle([1, 2, 3, 4, 5]);
</code></pre>
        <p>Arr::sort - сортирует массив по возрастанию</p>
        <pre><code>$array = ['Desk', 'Table', 'Chair'];

// ['Chair', 'Desk', 'Table']
$sorted = Arr::sort($array);

// либо с применением функции
$array = [['name' => 'Desk'], ['name' => 'Table'], ['name' => 'Chair']];

// [['name' => 'Chair'], ['name' => 'Desk'], ['name' => 'Table']]
$sorted = array_values(Arr::sort(
  $array,
  function (array $value) {
    return $value['name'];
  }
));
</code></pre>
        <p>Arr::sortDesc - сортирует массив по убыванию</p>
        <pre><code>$array = ['Desk', 'Table', 'Chair'];

// ['Table', 'Desk', 'Chair']
$sorted = Arr::sortDesc($array);

// либо с применением функции
$array = [['name' => 'Desk'], ['name' => 'Table'], ['name' => 'Chair']];

// [['name' => 'Table'], ['name' => 'Desk'], ['name' => 'Chair']]
$sorted = array_values(Arr::sortDesc(
  $array,
  function (array $value) {
    return $value['name'];
  }
));
</code></pre>
        <p>Arr::sortRecursive - рекурсивно сортирует массив</p>
        <pre><code>// с помощью метода sort для числовых подмассивов и ksort для ассоциативных подмассивов
$array = [
  ['Roman', 'Taylor', 'Li'],
  ['PHP', 'Ruby', 'JavaScript'],
  ['one' => 1, 'two' => 2, 'three' => 3]
];

// вернёт [['JavaScript', 'PHP', 'Ruby'], ['one' => 1, 'three' => 3, 'two' => 2], ['Li', 'Roman', 'Taylor']]
$sorted = Arr::sortRecursive($array);

// либо по убыванию
$sorted = Arr::sortRecursiveDesc($array);
</code></pre>
        <p>Arr::take - возвращает новый массив с указанным количеством элементов</p>
        <pre><code>$array = [0, 1, 2, 3, 4, 5];

// [0, 1, 2]
$chunk = Arr::take($array, 3);

// либо указанное количество элементов с конца массива, вернёт [4, 5]
$chunk = Arr::take($array, -2);
</code></pre>
        <p>Arr::toCssClasses - составляет строку классов CSS исходя из заданных условий</p>
        <pre><code>$isActive = false;
$hasError = true;
$array = ['p-4', 'font-bold' => $isActive, 'bg-red' => $hasError];

// 'p-4 bg-red'
$classes = Arr::toCssClasses($array);
</code></pre>
        <p>Arr::toCssStyles - условно компилирует строку стилей CSS</p>
        <pre><code>$hasColor = true;
$array = ['background-color: blue', 'color: blue' => $hasColor];

// 'background-color: blue; color: blue;'
$classes = Arr::toCssStyles($array);
</code></pre>
        <p>Arr::where - фильтрует массив, используя функцию</p>
        <pre><code>$array = [100, '200', 300, '400', 500];
$filtered = Arr::where(
  $array,

  // [1 => '200', 3 => '400']
  function (string|int $value, int $key) {
    return is_string($value);
  }
);
</code></pre>
        <p>Arr::whereNotNull - удаляет все значения null из массива</p>
        <pre><code>$array = [0, null];

// [0 => 0]
$filtered = Arr::whereNotNull($array);
</code></pre>
        <p>Arr::wrap - оборачивает переданное значение в массив</p>
        <pre><code>$string = 'Laravel';

// ['Laravel']
$array = Arr::wrap($string);

// либо если передан null, вернёт []
$array = Arr::wrap(null);
</code></pre>
        <p>data_fill - устанавливает отсутствующее значение во вложенном массиве или объекте</p>
        <pre><code>$data = ['products' => ['desk' => ['price' => 100]]];

// ['products' => ['desk' => ['price' => 100]]]
data_fill($data, 'products.desk.price', 200);

// ['products' => ['desk' => ['price' => 100, 'discount' => 10]]]
data_fill($data, 'products.desk.discount', 10);

// либо
$data = ['products' => [['name' => 'Desk 1', 'price' => 100], ['name' => 'Desk 2']]];

// вернёт ['products' => [['name' => 'Desk 1', 'price' => 100], ['name' => 'Desk 2', 'price' => 200]]]
data_fill($data, 'products.*.price', 200);
</code></pre>
        <p>data_get - возвращает значение из вложенного массива или объекта</p>
        <pre><code>$data = ['products' => ['desk' => ['price' => 100]]];

// 100
$price = data_get($data, 'products.desk.price');

// либо значение по умолчанию, которое будет возвращено, если указанный ключ не найден: 0
$discount = data_get($data, 'products.desk.discount', 0);

// либо для любого ключа массива или объекта
$data = [
  'product-one' => ['name' => 'Desk 1', 'price' => 100],
  'product-two' => ['name' => 'Desk 2', 'price' => 150]
];

// ['Desk 1', 'Desk 2'];
data_get($data, '*.name');

// либо {first} и {last} для получения первого или последнего элемента массива
$flight = ['segments' => [
  ['from' => 'LHR', 'departure' => '9:00', 'to' => 'IST', 'arrival' => '15:00'],
  ['from' => 'IST', 'departure' => '16:00', 'to' => 'PKX', 'arrival' => '20:00']
]];

  // 15:00
  data_get($flight, 'segments.{first}.arrival');
</code></pre>
        <p>data_set - устанавливает значение во вложенном массиве или объекте</p>
        <pre><code>$data = ['products' => ['desk' => ['price' => 100]]];

// ['products' => ['desk' => ['price' => 200]]]
data_set($data, 'products.desk.price', 200);

// либо с *
$data = ['products' => [['name' => 'Desk 1', 'price' => 100], ['name' => 'Desk 2', 'price' => 150]]];
data_set($data, 'products.*.price', 200);
//вернёт 
['products' => [['name' => 'Desk 1', 'price' => 200], ['name' => 'Desk 2', 'price' => 200]]]

// либо false в качестве четвертого аргумента чтобы существующие значения не перезаписывались
$data = ['products' => ['desk' => ['price' => 100]]];

// ['products' => ['desk' => ['price' => 100]]]
data_set($data, 'products.desk.price', 200, overwrite: false);
</code></pre>
        <p>data_forget - удаляет значение внутри вложенного массива или объекта</p>
        <pre><code>$data = ['products' => ['desk' => ['price' => 100]]];

// ['products' => ['desk' => []]]
data_forget($data, 'products.desk.price');

// либо с *
$data = ['products' => [['name' => 'Desk 1', 'price' => 100], ['name' => 'Desk 2', 'price' => 150]]];

// ['products' => [['name' => 'Desk 1'], ['name' => 'Desk 2']]]
data_forget($data, 'products.*.price');
</code></pre>
        <p>head - возвращает первый элемент переданного массива</p>
        <pre><code>$array = [100, 200, 300];

// 100
$first = head($array);
</code></pre>
        <p>last - возвращает последний элемент переданного массива</p>
        <pre><code>$array = [100, 200, 300];

// 300
$last = last($array);</code></pre>
        <h2>Числа</h2>
        <p>Number::abbreviate - возвращает числовое значение в удобочитаемом формате с сокращением для единиц измерения</p>
        <pre><code>use Illuminate\Support\Number;

// 1K
$number = Number::abbreviate(1000);

// 490K
$number = Number::abbreviate(489939);

// 1.23M
$number = Number::abbreviate(1230000, precision: 2);
</code></pre>
        <p>Number::clamp - если заданное число меньше минимума, возвращается минимальное значение, если больше максимума - максимальное</p>
        <pre><code>// 100
$number = Number::clamp(105, min: 10, max: 100);

// 10
$number = Number::clamp(5, min: 10, max: 100);

// 10
$number = Number::clamp(10, min: 10, max: 100);

// 20
$number = Number::clamp(20, min: 10, max: 100);
</code></pre>
        <p>Number::currency - возвращает значение в виде валюты</p>
        <pre><code>// $1,000.00
$currency = Number::currency(1000);

// €1,000.00
$currency = Number::currency(1000, in: 'EUR');

// 1.000,00 €
$currency = Number::currency(1000, in: 'EUR', locale: 'de');
</code></pre>
        <p>Number::defaultCurrency - возвращает валюту по умолчанию, используемую классом Number, вернёт USD</p>
        <pre><code>$currency = Number::defaultCurrency();</code></pre>
        <p>Number::defaultLocale - возвращает локаль по умолчанию, используемую классом Number, вернёт en</p>
        <pre><code>$locale = Number::defaultLocale();</code></pre>
        <p>Number::fileSize - для указанного значения в байтах возвращает представление размера файла в виде строки</p>
        <pre><code>// 1 KB
$size = Number::fileSize(1024);

// 1 MB
$size = Number::fileSize(1024 * 1024);

// 1.00 KB
$size = Number::fileSize(1024, precision: 2);
</code></pre>
        <p>Number::forHumans - возвращает числовое значение в удобочитаемом формате</p>
        <pre><code>// 1 thousand
$number = Number::forHumans(1000);

// 490 thousand
$number = Number::forHumans(489939);

// 1.23 million
$number = Number::forHumans(1230000, precision: 2);
</code></pre>
        <p>Number::format - форматирует предоставленное число в строку с учетом локализации</p>
        <pre><code>// 100,000
$number = Number::format(100000);

// 100,000.00
$number = Number::format(100000, precision: 2);

// 100,000.12
$number = Number::format(100000.123, maxPrecision: 2);

// 100.000
$number = Number::format(100000, locale: 'de');
</code></pre>
        <p>Number::ordinal - возвращает порядковое представление числа</p>
        <pre><code>// 1st
$number = Number::ordinal(1);

// 2nd
$number = Number::ordinal(2);

// 21st
$number = Number::ordinal(21);
</code></pre>
        <p>Number::pairs - генерирует массив пар чисел (поддиапазонов) на основе указанного диапазона и значения шага</p>
        <pre><code>// [[1, 10], [11, 20], [21, 25]]
$result = Number::pairs(25, 10);

// [[0, 10], [10, 20], [20, 25]]
$result = Number::pairs(25, 10, offset: 0);
</code></pre>
        <p>Number::percentage - возвращает процентное представление указанного значения в виде строки</p>
        <pre><code>// 10%
$percentage = Number::percentage(10);

// 10.00%
$percentage = Number::percentage(10, precision: 2);

// 10.12%
$percentage = Number::percentage(10.123, maxPrecision: 2);

// 10,00%
$percentage = Number::percentage(10, precision: 2, locale: 'de');
</code></pre>
        <p>Number::spell - возвращает заданное число прописью</p>
        <pre><code>// one hundred and two
$number = Number::spell(102);

// quatre-vingt-huit
$number = Number::spell(88, locale: 'fr');

// либо after позволяет указать значение, после которого все числа должны быть прописью
// 10
$number = Number::spell(10, after: 10);

// eleven
$number = Number::spell(11, after: 10);

// либо until позволяет указать значение, до которого все числа должны быть прописью
// five
$number = Number::spell(5, until: 10);

// 10
$number = Number::spell(10, until: 10);
</code></pre>
        <p>Number::trim - удаляет все конечные нулевые цифры после десятичной точки заданного числа</p>
        <pre><code>// 12
$number = Number::trim(12.0);

// 12.3
$number = Number::trim(12.30);
</code></pre>
        <p>Number::useLocale - глобально устанавливает языковой стандарт чисел по умолчанию в AppServiceProvider</p>
        <pre><code>use Illuminate\Support\Number;
public function boot(): void {Number::useLocale('de');}
</code></pre>
        <p>Number::withLocale - выполняет функцию с использованием указанного языкового стандарта, после выполнения восстанавливает исходный</p>
        <pre><code>$number = Number::withLocale('de', function () {return Number::format(1500);});
</code></pre>
        <p>Number::useCurrency - устанавливает глобальную числовую валюту по умолчанию</p>
        <pre><code>public function boot(): void {Number::useCurrency('GBP');}
</code></pre>
        <p>Number::withCurrency - выполняет функцию с использованием указанн ую валюту, после выполнения восстанавливает исходную</p>
        <pre><code>$number = Number::withCurrency('GBP', function () { ... });</code></pre>
        <h2>Пути</h2>
        <p>app_path - возвращает полный путь к каталогу app</p>
        <pre><code>$path = app_path();
$path = app_path('Http/Controllers/Controller.php');
</code></pre>
        <p>base_path - возвращает полный путь к корневому каталогу</p>
        <pre><code>$path = base_path();
$path = base_path('vendor/bin');
</code></pre>
        <p>config_path - возвращает полный путь к каталогу config</p>
        <pre><code>$path = config_path();
$path = config_path('app.php');
</code></pre>
        <p>database_path - возвращает полный путь к каталогу database</p>
        <pre><code>$path = database_path();
$path = database_path('factories/UserFactory.php');
</code></pre>
        <p>lang_path - возвращает полный путь к каталогу lang</p>
        <pre><code>$path = lang_path();
$path = lang_path('en/messages.php');
</code></pre>
        <p>mix - возвращает путь к версионированному файлу Mix</p>
        <pre><code>$path = mix('css/app.css');</code></pre>
        <p>public_path - возвращает полный путь к каталогу public</p>
        <pre><code>$path = public_path();
$path = public_path('css/app.css');
</code></pre>
        <p>resource_path - возвращает полный путь к каталогу resources</p>
        <pre><code>$path = resource_path();
$path = resource_path('sass/app.scss');
</code></pre>
        <p>storage_path - возвращает полный путь к каталогу storage</p>
        <pre><code>$path = storage_path();
$path = storage_path('app/file.txt');
</code></pre>
        <p>action - генерирует URL-адрес для переданного действия контроллера</p>
        <pre><code>use App\Http\Controllers\HomeController;

$url = action([HomeController::class, 'index']);

// либо
$url = action([UserController::class, 'profile'], ['id' => 1]);
</code></pre>
        <p>asset -  генерирует URL для исходника (из директории resources), используя текущую схему запроса (HTTP или HTTPS)</p>
        <pre><code>// хост URL исходников указан в переменной ASSET_URL в .env
$url = asset('img/photo.jpg');

// например
ASSET_URL=http://example.com/assets

// http://example.com/assets/img/photo.jpg
$url = asset('img/photo.jpg');
</code></pre>
        <p>route - генерирует URL для переданного именованного маршрута</p>
        <pre><code>// абсолютный URL
$url = route('route.name');

// либо
$url = route('route.name', ['id' => 1]);

// относительный URL
$url = route('route.name', ['id' => 1], false);
</code></pre>
        <p>secure_asset - генерирует URL для исходника, используя HTTPS</p>
        <pre><code>$url = secure_asset('img/photo.jpg');</code></pre>
        <p>secure_url - генерирует полный URL-адрес для указанного пути, используя HTTPS</p>
        <pre><code>$url = secure_url('user/profile');
$url = secure_url('user/profile', [1]);
</code></pre>
        <p>to_route - генерирует перенаправление для заданного именованного маршрута</p>
        <pre><code>return to_route('users.show', ['user' => 1]);

// либо с кодом состояния и заголовками
return to_route('users.show’, ['user’ => 1], 302, ['X-Framework’ => 'Laravel’]);
</code></pre>
        <p>url - генерирует полный URL-адрес для указанного пути</p>
        <pre><code>$current = url()->current();
$full = url()->full();
$previous = url()->previous();</code></pre>
        <h2>Методы</h2>
        <p>abort - генерирует HTTP-исключение, которое будет обработано обработчиком исключения, abort(403);</p>
        <pre><code>// либо с текстом ответа и заголовками
abort(403, 'Unauthorized.', $headers);
</code></pre>
        <p>abort_if - генерирует исключение HTTP, если условие true, можно с текстом ответа и заголовками</p>
        <pre><code>abort_if(! Auth::user()->isAdmin(), 403);</code></pre>
        <p>abort_unless - генерирует исключение HTTP, если условие false, можно с текстом ответа и заголовками</p>
        <pre><code>abort_unless(Auth::user()->isAdmin(), 403);</code></pre>
        <p>app - возвращает экземпляр контейнера служб</p>
        <pre><code>$container = app();

// либо передать имя класса или интерфейса для извлечения его экземпляра из контейнера служб
$api = app('HelpSpot\API');
</code></pre>
        <p>resolve - извлекает экземпляр класса или интерфейса из контейнера служб</p>
        <pre><code>$api = resolve('HelpSpot\API');</code></pre>
        <p>auth - возвращает экземпляр аутентификатора, альтернатива фасада Auth</p>
        <pre><code>$user = auth()->user();

// либо указать, к какому экземпляру охранника получить доступ
$user = auth('admin')->user();
</code></pre>
        <p>back - генерирует перенаправление в предыдущее расположение пользователя</p>
        <pre><code>return back($status = 302, $headers = [], $fallback = '/');
return back();
</code></pre>
        <p>bcrypt - хеширует переданное значение, используя Bcrypt, альтернатива фасада Hash</p>
        <pre><code>$password = bcrypt('my-secret-password');</code></pre>
        <p>blank - проверяет, является ли переданное значение «пустым»</p>
        <pre><code>// true
blank('');
blank('   ');
blank(null);
blank(collect());

// false
blank(0);
blank(true);
blank(false);
</code></pre>
        <p>filled - проверяет, является ли переданное значение не «пустым»</p>
        <pre><code>// true
filled(0);
filled(true);
filled(false);

// false
filled('');
filled('   ');
filled(null);
filled(collect());
</code></pre>
        <p>broadcast -  транслирует переданное событие своим слушателям</p>
        <pre><code>broadcast(new UserRegistered($user));
broadcast(new UserRegistered($user))->toOthers();
</code></pre>
        <p>cache - получение значений из кеша</p>
        <pre><code>$value = cache('key');
$value = cache('key', 'default');
// либо добавлять элементы в кеш
cache(['key' => 'value'], 300);
cache(['key' => 'value'], now()->addSeconds(10));
</code></pre>
        <p>class_uses_recursive - возвращает все трейты, используемые классом и его родителями</p>
        <pre><code>$traits = class_uses_recursive(App\Models\User::class);</code></pre>
        <p>collect - создает экземпляр коллекции</p>
        <pre><code>$collection = collect(['taylor', 'abigail']);</code></pre>
        <p>config - получить значение переменной конфигурации</p>
        <pre><code>$value = config('app.timezone');
$value = config('app.timezone', $default);

// установить переменные конфигурации на время выполнения текущего запроса
config(['app.debug' => true]);
</code></pre>
        <p>context - получает значение из текущего контекста</p>
        <pre><code>$value = context('trace_id');
$value = context('trace_id', $default);

//установить значения контекста
use Illuminate\Support\Str;

context(['trace_id' => Str::uuid()->toString()]);
</code></pre>
        <p>cookie - создает новый экземпляр Cookie</p>
        <pre><code>$cookie = cookie('name', 'value', $minutes);</code></pre>
        <p>csrf_field - генерирует HTML «скрытого» поля ввода, содержащее значение токена CSRF</p>
        <pre><code>{{ csrf_field() }}</code></pre>
        <p>csrf_token - возвращает значение текущего токена CSRF</p>
        <pre><code>$token = csrf_token();</code></pre>
        <p>decrypt - расшифровывает, альтернатива фасада Crypt</p>
        <pre><code>$password = decrypt($value);</code></pre>
        <p>encrypt - шифрует, альтернатива фасада Crypt</p>
        <pre><code>$secret = encrypt('my-secret-value');</code></pre>
        <p>dd - выводит переданные переменные и завершает выполнение скрипта</p>
        <pre><code>dd($value);
dd($value1, $value2, $value3, ...);
</code></pre>
        <p>dump - выводит переданные переменные</p>
        <pre><code>dump($value);
dump($value1, $value2, $value3, ...);
</code></pre>
        <p>dispatch - поместить задание в очередь</p>
        <pre><code>dispatch(new App\Jobs\SendEmails);</code></pre>
        <p>dispatch_sync - поместить задачу в очередь синхронно для немедленной обработки</p>
        <pre><code>dispatch_sync(new App\Jobs\SendEmails);</code></pre>
        <p>
          env - возвращает значение переменной окружения или значение по умолчанию</br>
          при кешировании конфигурации файл .env не будет загружаться
        </p>
        <pre><code>$env = env('APP_ENV');
$env = env('APP_ENV', 'production');
</code></pre>
        <p>event - отправить событие</p>
        <pre><code>event(new UserRegistered($user));</code></pre>
        <p>fake - получает экземпляр Faker из контейнера</p>
        <pre><code>@for($i = 0; $i < 10; $i++)
  &lt;dl&gt;
    &lt;dt&gt;Name&lt;/dt&gt;
    &lt;dd&gt;{{ fake()->name() }}&lt;/dd&gt;
    &lt;dt&gt;Email&lt;/dt&gt;
    &lt;dd&gt;{{ fake()->unique()->safeEmail() }}&lt;/dd&gt;
  &lt;/dl&gt;
@endfor

// локализация fake указана в APP_FAKER_LOCALE в .env, указать локализацию
fake('nl_NL')->name()
</code></pre>
        <p>info - запишет информацию в журнал</p>
        <pre><code>info('Some helpful information!');

// либо
info('User login attempt failed.', ['id' => $user->id]);
</code></pre>
        <p>literal - создает новый экземпляр stdClass с заданными именованными аргументами в качестве свойств</p>
        <pre><code>$obj = literal(name: 'Joe', languages: ['PHP', 'Ruby']);

// 'Joe'
$obj->name;

// ['PHP', 'Ruby']
$obj->languages;
</code></pre>
        <p>logger - запись сообщения уровня debug в журнал</p>
        <pre><code>logger('Debug message');

// либо
logger('User has logged in.', ['id' => $user->id]);

// либо
logger()->error('You are not allowed here.');
</code></pre>
        <p>method_field - генерирует HTML «скрытого» поле ввода, содержащее поддельное значение HTTP-метода формы</p>
        <pre><code>< form method="POST">{{ method_field('DELETE') }}</ form>;</code></pre>
        <p>now - создает новый экземпляр Illuminate\Support\Carbon для текущего времени</p>
        <pre><code>$now = now();</code></pre>
        <p>today - создает новый экземпляр Illuminate\Support\Carbon для текущей даты</p>
        <pre><code>$today = today();</code></pre>
        <p>old - значение прежнего ввода, краткосрочно сохраненное в сессии</p>
        <pre><code>$value = old('value');
$value = old('value', 'default');

// либо
{{ old('name', $user) }}

//либо
{{ old('name', $user->name) }}
</code></pre>
        <p>once - выполняет заданный обратный вызов и кэширует результат в памяти на время запроса</p>
        <pre><code>function random(): int {
  return once(
    function () {
      return random_int(1, 1000);
    }
  );
}
random();  // 123
random();  // 123 (cached result)
random();  // 123 (cached result)
</code></pre>
        <p>once выполняется из экземпляра объекта и кеширует для каждого экземпляра своё значение</p>
        <pre><code>class NumberService {
  public function all(): array {
    return once(fn () => [1, 2, 3]);
  }
}
$service = new NumberService;
$service->all();
$service->all();  // (cached result)

$secondService = new NumberService;
$secondService->all();
$secondService->all();  // (cached result)
</code></pre>
        <p>optional - получать доступ к свойствам или вызывать методы переданного объекта</p>
        <pre><code>return optional($user->address)->street;
{!! old('name', optional($user)->name) !!}

// функция срабатывает, если первый аргумент не null
return optional(User::find($id), function (User $user) {return $user->name;});
</code></pre>
        <p>policy - извлекает экземпляр политики для переданного класса</p>
        <pre><code>$policy = policy(App\Models\User::class);</code></pre>
        <p>redirect - возвращает перенаправление или возвращает экземпляр перенаправителя, если вызывается без аргументов</p>
        <pre><code>return redirect($to = null, $status = 302, $headers = [], $https = null);
return redirect('/home');
return redirect()->route('route.name');
</code></pre>
        <p>report - сообщит об исключении, используя обработчик исключений</p>
        <pre><code>report($e);

// либо с переданной строкой в качестве сообщения
report('Something went wrong.');
</code></pre>
        <p>report_if - сообщит об исключении, используя обработчик исключений, если условие true</p>
        <pre><code>report_if($shouldReport, $e);
report_if($shouldReport, 'Something went wrong.');
</code></pre>
        <p>report_unless - сообщит об исключении, используя обработчик исключений, если условие false</p>
        <pre><code>report_unless($reportingDisabled, $e);
report_unless($reportingDisabled, 'Something went wrong.');
</code></pre>
        <p>request - возвращает экземпляр текущего запроса или получает значение поля ввода из текущего запроса</p>
        <pre><code>$request = request();
$value = request('key', $default);
</code></pre>
        <p>rescue - выполняет функцию и отправляет исключения обработчику и продолжает обработку запроса</p>
        <pre><code>return rescue(
  function () {
    return $this->method();
  }
);

// либо со значением по умолчанию при возникновении исключения
return rescue(
  function () {
    return $this->method();
  },
false);

return rescue(
  function () {
    return $this->method();
  },
  
  function () {
    return $this->failure();
  }
);

// либо сообщить об исключении чрез функцию report
return rescue(
  function () {
    return $this->method();
  },
  report: function (Throwable $throwable) {
    return $throwable instanceof InvalidArgumentException;
  }
);
</code></pre>
        <p>response - создает экземпляр ответа или получает экземпляр фабрики ответов</p>
        <pre><code>return response('Hello World', 200, $headers);
return response()->json(['foo' => 'bar'], 200, $headers);
</code></pre>
        <p>retry - пытается выполнить переданную функцию, пока не будет достигнут указанный лимит попыток</p>
        <pre><code>// 5 поппыток с интервалом 100 милисекунд
return retry(5, function () { }, 100);

// либо
use Exception;
return retry(
  5,
  function () { ... },
  function (int $attempt, Exception $exception) {
    return $attempt * 100;
  }
);

// либо пауза 100 мс после первой попытки, 200 мс после второй
return retry([100, 200], function () { });

// либо повторить попытку только при определенных условиях
return retry(
  5,
  function () { ... },
  100,
  function (Exception $exception) {
    return $exception instanceof RetryException;
  }
);
</code></pre>
        <p>session - получение или запись значений сессии</p>
        <pre><code>// получить значение
$value = session('key');

// записать значение
session(['chairs' => 7, 'instruments' => 3]);

// получить экземпляр хранилища сессий и вызвать метод
$value = session()->get('key');

// получить экземпляр хранилища сессий и записать значение
session()->put('key', $value);
</code></pre>
        <p>tap - передаёт первый аргумент в функцию</p>
        <pre><code>$user = tap(User::first(), function (User $user) {
  $user->name = 'taylor';
  $user->save();
});

// либо
$user = tap($user)->update(['name' => $name, 'email' => $email]);

// либо
use Illuminate\Support\Traits\Tappable
return $user->tap(function (User $user) { ... });
</code></pre>
        <p>transform - выполняет функцию для переданного значения, если значение не пустое</p>
        <pre><code>$callback = function (int $value) {return $value * 2;};

// 10
$result = transform(5, $callback);

// либо вернет значение третьего аргумента если переданное значение пустое, вернёт The value is blank
$result = transform(null, $callback, 'The value is blank');
</code></pre>
        <p>throw_if - выбрасывает переданное исключение, если указанное логическое выражение true</p>
        <pre><code>throw_if(! Auth::user()->isAdmin(), AuthorizationException::class);

// либо
throw_if(! Auth::user()->isAdmin(), AuthorizationException::class, 'You are not allowed to access this page.');
</code></pre>
        <p>throw_unless - выбрасывает переданное исключение, если указанное логическое выражение false</p>
        <pre><code>throw_unless(Auth::user()->isAdmin(), AuthorizationException::class);

// либо
throw_unless(Auth::user()->isAdmin(), AuthorizationException::class, 'You are not allowed to access this page.');
</code></pre>
        <p>trait_uses_recursive - возвращает все трейты, используемые трейтом</p>
        <pre><code>$traits = trait_uses_recursive(\Illuminate\Notifications\Notifiable::class);</code></pre>
        <p>validator - создает новый экземпляр валидатора с указанными аргументами, альтернатива ыасда Validator</p>
        <pre><code>$validator = validator($data, $rules, $messages);</code></pre>
        <p>value - возвращает переданное значение</p>
        <pre><code>// true
$result = value(true);

// либо, вернёт false
$result = value(function () {return false;});

// либо, вернёт 'Taylor'
$result = value(function (string $name) {return $name;}, 'Taylor');
</code></pre>
        <p>view - возвращает экземпляр представления</p>
        <pre><code>return view('auth.login');</code></pre>
        <p>with - возвращает переданное значение</p>
        <pre><code>$callback = function (mixed $value) {return is_numeric($value) ? $value * 2 : 0;};

// 10
$result = with(5, $callback);

// либо, вернёт 0
$result = with(null, $callback);

// либо, вернёт 5
$result = with(5, null);
</code></pre>
        <p>when - возвращает заданное значение, если заданное условие true, в противном случае возвращается null</p>
        <pre><code>$value = when(true, 'Hello World');

// либо
$value = when(true, fn () => 'Hello World');

// либо
< div {!! when($condition, 'wire:poll="calculate"') !!}>...</ div></code></pre>
        <h2>Время</h2>
        <p>Измерения времени выполнения переданных обратных вызовов в миллисекундах</p>
        <pre><code>use App\Models\User;
use Illuminate\Support\Benchmark;

Benchmark::dd(fn () => User::find(1));                  // 0.1 ms
Benchmark::dd(['Scenario 1' => fn () => User::count(),  // 0.5 ms
'Scenario 2' => fn () => User::all()->count()]);        // 20.0 ms

// либо указать количество итераций, вернёт среднее значение 0.5 ms
Benchmark::dd(fn () => User::count(), iterations: 10);

// либо вернуть значение из функции и количество миллисекунд, затраченных на выполнение функции
[$count, $duration] = Benchmark::value(fn () => User::count());
</code></pre>
        <p>Создать новый экземпляр Carbon</p>
        <pre><code>$now = now();

// либо
use Illuminate\Support\Carbon;
$now = Carbon::now();
</code></pre>
        <p>Функции позволяют отложить выполнение закрытия до тех пор, пока HTTP-ответ не будет отправлен пользователю без использования очереди, отложенные функции выполняются когда HTTP-ответ, команда Artisan или задание в очереди, из которого вызывается Illuminate\Support\defer, завершаются успешно</p>
        <pre><code>use App\Services\Metrics;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use function Illuminate\Support\defer;
Route::post('/orders', function (Request $request) {

  // Create order...
  defer(fn () => Metrics::reportOrder($order));
  return $order;
});

// либо отложенная функция выполнялась всегда, не завися от успешного завершения HTTP-ответа
defer(fn () => Metrics::reportOrder($order))->always();

// либо отменить отложенную функцию до ее выполнения
defer(fn () => Metrics::report(), 'reportMetrics');
defer()->forget('reportMetrics');

// либо отключить отложенные функции в тестах
test('without defer', function () {$this->withoutDefer();});

// либо отключить отложенные функции для всех тестов
namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
abstract class TestCase extends BaseTestCase {
  protected function setUp(): void {
    parent::setUp();
    $this->withoutDefer();
  }
}
</code></pre>
        <p>Код только для определенного процента входящих запросов</p>
        <pre><code>use Illuminate\Support\Lottery;
Lottery::odds(1, 20)->winner(fn () => $user->won())->loser(fn () => $user->lost())->choose();

// либо сообщать обработчику исключений только о небольшом проценте медленных запросов
use Carbon\CarbonInterval;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Lottery;
DB::whenQueryingForLongerThan(
  CarbonInterval::seconds(2),
  Lottery::odds(1, 100)->winner(fn () => report('Querying > 2 seconds.')));

// либо тестировать вызовы лотереи
Lottery::alwaysWin();                 // Лотерея всегда вииграшная...
Lottery::alwaysLose();                // Лотерея всегда проиграшная...
Lottery::fix([true, false]);          // Выигрыш, проигрыш, затем вернуться к нормальному поведению...
Lottery::determineResultsNormally();  // Вернуться к нормальному поведению...
</code></pre>
        <p>Проброс ввода через вызовы функций или объекты, с возможностью проверить или изменить входные данные и вызвать следующий элемент</p>
        <pre><code>use Closure;
use App\Models\User;
use Illuminate\Support\Facades\Pipeline;
$user = Pipeline::send($user)->through([
  function (User $user, Closure $next) {return $next($user);},
  function (User $user, Closure $next) {return $next($user);}])->then(fn (User $user) => $user);
// либо
$user = Pipeline::send($user)->through([
  GenerateProfilePhoto::class,
  ActivateSubscription::class,
  SendWelcomeEmail::class])->then(fn (User $user) => $user);
</code></pre>
        <p>Обертка нативных функций PHP sleep и usleep предоставляет методы работы с различными единицами времени</p>
        <pre><code>use Illuminate\Support\Sleep;
$waiting = true;
while ($waiting) {
  Sleep::for(1)->second();
  $waiting = /* ... */;
}
// Вернуть значение после сна...
$result = Sleep::for(1)->second()->then(fn () => 1 + 1);

// Спать, пока заданное значение истинно...
Sleep::for(1)->second()->while(fn () => shouldKeepSleeping());

// Приостановите выполнение на 90 секунд...
Sleep::for(1.5)->minutes();

// Приостановите выполнение на 2 секунды...
Sleep::for(2)->seconds();

// Приостановите выполнение на 500 миллисекунд...
Sleep::for(500)->milliseconds();

// Приостановите выполнение на 5000 миллисекунд...
Sleep::for(5000)->microseconds();

// Приостановить выполнение до заданного времени...
Sleep::until(now()->addMinute());

// Псевдоним функции PHP "sleep"...
Sleep::sleep(2);

// Псевдоним функции PHP  "usleep"
Sleep::usleep(5000);

// либо объединить единицы времени
Sleep::for(1)->second()->and(10)->milliseconds();

// либо
it('checks if ready three times', function () {
  // “подделать” задержку, чтобы тест оставался быстрым
  Sleep::fake();

  // приостановить выполнение кода 3 раза, каждая пауза на секунду больше
  Sleep::assertSequence([
    Sleep::for(1)->second(),
    Sleep::for(2)->seconds(),
    Sleep::for(3)->seconds()]);
}

// либо
use Carbon\CarbonInterval as Duration;
use Illuminate\Support\Sleep;

// утверждение: sliip вызывали 3 раза
Sleep::assertSleptTimes(3);

// утверждение: продолжительность сна
Sleep::assertSlept(
  function (Duration $duration): bool {
    return /* ... */;
  },
times: 1);

// утверждение: класс Sleep никогда не вызывался
Sleep::assertNeverSlept();

// утверждение: даже если был вызван Sleep, пауза в выполнении не наступила
Sleep::assertInsomniac();

// либо продвинуть время на продолжительность каждого ожидания
use Carbon\CarbonInterval as Duration;
$this->freezeTime();
Sleep::fake();

// Progress time when faking sleep
Sleep::whenFakingSleep(function (Duration $duration) {
  $this->travel($duration->totalMilliseconds)->milliseconds();
});   

// либо синхронизировать Carbon во время сна в тесте
Sleep::fake(syncWithCarbon: true);
$start = now();
Sleep::for(1)->second();

// 1 second ago
$start->diffForHumans();</code></pre>
        <h2>Artisan – интерфейс командной строки</h2>
        <table>
          <tbody>
            <tr>
              <td>php artisan list</td>
              <td>списка всех доступных команд Artisan</td>
            </tr>
            <tr>
              <td>php artisan help migrate</td>
              <td>вызвать справку</td>
            </tr>
            <tr>
              <td>php artisan tinker</td>
              <td>взаимодействовать с приложением из командной строки</td>
            </tr>
            <tr>
              <td>php artisan vendor:publish --provider="Laravel\Tinker\TinkerServiceProvider"</td>
              <td>конфигурационный файл Tinker</td>
            </tr>
            <tr>
              <td>'commands' => [App\Console\Commands\ExampleCommand::class]</td>
              <td>добавление команд в config/tinker.php</td>
            </tr>
            <tr>
              <td>'dont_alias' => [App\Models\User::class]</td>
              <td>черный список псевдонимов классов в config/tinker.php</td>
            </tr>
            <tr>
              <td>php artisan make:command SendEmails</td>
              <td>сгенерировать новую команду в app/Console/Commands</td>
            </tr>
          </tbody>
        </table>
        <p>Определить команду artisan в виде класса</p>
        <pre><code>namespace App\Console\Commands;
use App\Models\User;
use App\Support\DripEmailer;
use Illuminate\Console\Command;

class SendEmails extends Command {

  // имя команды и вводимые данные
  protected $signature = 'mail:send {user}';

  // описание команды для list
  protected $description = 'Отправка письма пользователю';
  public function handle(DripEmailer $drip): void {

    // выполнение команды
    $drip->send(User::find($this->argument('user')));
  }
}
</code></pre>
        <p>Коды завершения команды:</p>
        <pre><code>// 0 - команда выполнена успешно
// вернуть ошибку из public function handle()
$this->error('Что-то пошло не так.');
return 1;

// прервать выполнение команды и вернуть код завершения 1
$this->fail('Что-то пошло не так.');
</code></pre>
        <p>Определить команду artisan в routes/console.php</p><code>Artisan::command('mail:send {user}', function (string $user) {$this->info("Отправка почты на: {$user}!");});</code>
        <p>Типизация зависимостей</p>
        <pre><code>use App\Models\User;
use App\Support\DripEmailer;

Artisan::command(
  'mail:send {user}',
  function (DripEmailer $drip, string $user) {
    $drip->send(User::find($user));
  }
);
</code></pre>
        <p>Добавить описание команды</p>
        <pre><code>Artisan::command(
  'mail:send {user}',
  function (string $user) { }
)->purpose('Отправка письма пользователю');
</code></pre>
        <p>Изолированные команды: одновременно выполняется только один экземпляр команды</p>
        <pre><code>namespace App\Console\Commands;
use Illuminate\Console\Command;
use Illuminate\Contracts\Console\Isolatable;
class SendEmails extends Command implements Isolatable { }

// выполнить изолированную команду: блокировка других экземпляров этой команды в кэш-драйвере
php artisan mail:send 1 --isolated

// указать код статуса завершения, если команда не может выполниться
php artisan mail:send 1 --isolated=12

// задать id команды для изоляции в кэше (по умолчанию - имя команды)
public function isolatableId(): string {return $this->argument('user');}

// время блокировки истекает либо по завершению команды либо через час после прерывания выполнения команды настроить время блокировки
use DateTimeInterface;
use DateInterval;
public function isolationLockExpiresAt(): DateTimeInterface|DateInterval {return now()->addMinutes(5);}
</code></pre>
        <table>
          <caption>Вводимые данные (использовать пакет Prompts)</caption>
          <tbody>
            <tr>
              <td>protected $signature = 'mail:send {user}';</td>
              <td>один обязательный аргумент user</td>
            </tr>
            <tr>
              <td>protected $signature = 'mail:send {user?}';</td>
              <td>один необязательный аргумент user</td>
            </tr>
            <tr>
              <td>protected $signature = 'mail:send {user=foo}';</td>
              <td>один необязательный аргумент user со значением по умолчанию</td>
            </tr>
            <tr>
              <td>protected $signature = 'mail:send {user} {--queue}';</td>
              <td>параметр {--queue} как логический переключатель</td>
            </tr>
            <tr>
              <td>php artisan mail:send 1</td>
              <td>вызов команды: user = 1, --queue = false</td>
            </tr>
            <tr>
              <td>php artisan mail:send 1 --queue</td>
              <td>вызов команды: user = 1, --queue = true</td>
            </tr>
            <tr>
              <td>protected $signature = 'mail:send {user} {--queue=}';</td>
              <td> параметр {--queue=} ожидает значение</td>
            </tr>
            <tr>
              <td>php artisan mail:send 1</td>
              <td>вызов команды: user = 1, --queue = null</td>
            </tr>
            <tr>
              <td>php artisan mail:send 1 --queue=foo</td>
              <td>вызов команды: user = 1, --queue = foo</td>
            </tr>
            <tr>
              <td>protected $signature = 'mail:send {user} {--queue=default}';</td>
              <td>параметр --queue со значением по умолчанию</td>
            </tr>
            <tr>
              <td>protected $signature = 'mail:send {user} {--Q!queue}';</td>
              <td>назначить псевдоним Q для параметра --queue</td>
            </tr>
            <tr>
              <td>php artisan mail:send 1 -Qfoo</td>
              <td>вызов команды: user = 1, --queue = foo</td>
            </tr>
          </tbody>
        </table>
        <p>Назначить описания входным аргументам и параметрам</p>
        <pre><code>protected $signature = 'mail:send {user : Идентификатор пользователя} {--queue : Поставить ли задание в очередь}';</code></pre>
        <table>
          <caption>Массивы вводимых данных</caption>
          <tbody>
            <tr>
              <td>protected $signature = 'mail:send {user*}'</td>
              <td>аргумент ожидает массив данных</td>
            </tr>
            <tr>
              <td>php artisan mail:send 1 2</td>
              <td>вызов команды: user = [1, 2]</td>
            </tr>
            <tr>
              <td>protected $signature = 'mail:send {user?*}'</td>
              <td>необязательный аргумент ожидает массив данных</td>
            </tr>
            <tr>
              <td>protected $signature = 'mail:send {--id*}'</td>
              <td>параметр ожидает массив данных</td>
            </tr>
            <tr>
              <td>php artisan mail:send --id=1 --id=2</td>
              <td>вызов команды: id = [1, 2]</td>
            </tr>
          </tbody>
        </table>
        <p>Запрос отсутствующего ввода</p>
        <pre><code>// запросить у пользователя ввод значения аргумента
namespace App\Console\Commands;
use Illuminate\Console\Command;
use Illuminate\Contracts\Console\PromptsForMissingInput;
class SendEmails extends Command implements PromptsForMissingInput {
  protected $signature = 'mail:send {user}';
}

// настроить вопрос для пользователя
protected function promptForMissingArgumentsUsing(): array {
  return ['user' => 'Какой идентификатор пользователя должен получать почту?'];
}

// настроить вопрос для пользователя с заполнителем
return ['user' => 'Какой идентификатор пользователя должен получать почту?', 'Например: 123'];}

// полный контроль запроса на ввод данных пользователем
use App\Models\User;
use function Laravel\Prompts\search;
return [
  'user' => fn () => search(
    label: 'Найдите пользователя:',
    placeholder: 'Например: Тейлор Отвелл',
    options: fn ($value) => strlen($value) > 0 ? User::where('name', 'like', "%{$value}%")->pluck('name', 'id')->all() : []
  )
];

// запрашивать у пользователя только после автоматического запроса ввести отсутствующие аргументы
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use function Laravel\Prompts\confirm;
protected function afterPromptingForMissingArguments(InputInterface $input, OutputInterface $output): void {
  $input->setOption('queue', confirm(
    label: 'Хотите поставить почту в очередь?',
    default: $this->option('queue'))
  );
}
</code></pre>
        <p>Получить доступ к значениям введенных аргументов и параметров (методы argument и option)</p>
        <pre><code>public function handle(): void {$userId = $this->argument('user');}

// получить все аргументы в виде массива
$arguments = $this->arguments();

// получить параметр
$queueName = $this->option('queue');

// получить массив
$options = $this->options();

// запросить у пользователя данные во время выполнения команды
public function handle(): void {$name = $this->ask('Как вас зовут?');}

// со значением по умолчанию
$name = $this->ask('Как вас зовут?', 'Тейлор');

// вводимые символы не отображаются
$password = $this->secret('Какой пароль?');

// запрос подтверждения «yes or no»
if ($this->confirm('Хотите продолжить?')) { }

// со значением по умолчанию
if ($this->confirm('Хотите продолжить?', true)) { }

// возможные варианты автоматического завершения
$name = $this->anticipate('Как вас зовут?', ['Тейлор', 'Дэйл']);

// принимать введенные пользователем данные, и возвращать массив вариантов для автозавершения
$name = $this->anticipate('Какой у вас адрес?', function (string $input) { вернуть массив вариантов... });

// предопределенный набор вариантов 
$name = $this->choice(

  // вопрос пользователю
  'Как вас зовут?',

  // массив предопределенных вариантов
  ['Тейлор', 'Дэйл'],

  // индекс значения по умолчанию из массива вариантов
  $defaultIndex,

  // максимальное количество попыток
  $maxAttempts = null,

  // множественный выбор
  $allowMultipleSelections = false
);
</code></pre>
        <p>Вывод данных в консоль (методы line, info, comment, question, warn и error)</p>
        <pre><code>public function handle(): void {$this->info('Команда выполнена успешно!');}
$this->error('Something went wrong!');
$this->line('Отобразить это на экране');

// отобразить пустую строку
$this->newLine();

// отобразить 3 пустые строки
$this->newLine(3);

// форматирование нескольких строк / столбцов данных ('Name', 'Email' - имена столбцов)
use App\Models\User;
$this->table(['Name', 'Email'], User::all(['name', 'email'])->toArray());

// отображать индикатор выполнения
use App\Models\User;
$users = $this->withProgressBar(User::all(), function (User $user) {$this->performTask($user);});

// настроить индикатор вручную
$users = App\Models\User::all();
$bar = $this->output->createProgressBar(count($users));
$bar->start();
foreach ($users as $user) {
  $this->performTask($user);
  $bar->advance();
}
$bar->finish();
</code></pre>
        <p>В bootstrap/app.php</p>
        <pre><code>// сканировать каталоги на наличие команд (по умолчанию в app/Console/Commands)
->withCommands([__DIR__.'/../app/Domain/Orders/Commands'])

// зарегистрировать команду вручную
use App\Domain\Orders\Commands\SendEmails;
->withCommands([SendEmails::class])
</code></pre>
        <p>Запустить команду Artisan в маршруте или контроллере</p>
        <pre><code>use Illuminate\Support\Facades\Artisan;
Route::post('/user/{user}/mail', function (string $user) {
  $exitCode = Artisan::call('mail:send', ['user' => $user, '--queue' => 'default']);});

// либо
Artisan::call('mail:send 1 --queue=default');

// либо с массивом
Route::post('/mail', function () {$exitCode = Artisan::call('mail:send', ['--id' => [5, 13]]);});

// либо с логическим переключателем
$exitCode = Artisan::call('migrate:refresh', ['--force' => true,]);
</code></pre>
        <p>Поставить команды Artisan в очередь для обработки в фоновом режиме</p>
        <pre><code>use Illuminate\Support\Facades\Artisan;
Route::post('/user/{user}/mail', function (string $user) {
  Artisan::queue('mail:send', ['user' => $user, '--queue' => 'default']);
});

// указать соединение или очередь, в которую должна быть отправлена команда
Artisan::queue('mail:send', ['user' => 1, '--queue' => 'default'])->onConnection('redis')->onQueue('commands');

// вызвать другие команды из существующей
public function handle(): void {$this->call('mail:send', ['user' => 1, '--queue' => 'default']);}

// вызвать команду в тихом режиме
$this->callSilently('mail:send', ['user' => 1, '--queue' => 'default']);
</code></pre>
        <p>Прослушивать сигналы операционных систем в командах Artisan и выполнять код при их возникновении</p>
        <pre><code>public function handle(): void {
  $this->trap(SIGTERM, fn () => $this->shouldKeepRunning = false);
  while ($this->shouldKeepRunning) { }
}

// прослушивания нескольких сигналов сразу
$this->trap([SIGTERM, SIGQUIT], function (int $signal) {
  $this->shouldKeepRunning = false;
  dump($signal);
});
</code></pre>
        <p>Опубликовать заготовки создания классов командой make для их изменения</p>
        <pre><code>php artisan stub:publish</code></pre>
        <p>Artisan запускает три события при выполнении команд:</p>
        <ul>
          <li>Illuminate\Console\Events\ArtisanStarting - после запуска Artisan</li>
          <li>Illuminate\Console\Events\CommandStarting - перед запуском команды</li>
          <li>Illuminate\Console\Events\CommandFinished - после завершения команды</li>
        </ul>
        <h2>Configuration</h2>
        <table>
          <caption>Config</caption>
          <tbody>
            <tr>
              <td>config/app.php</td>
              <td>конфигурация приложения</td>
            </tr>
            <tr>
              <td>config/database.php</td>
              <td>конфигурация БД</td>
            </tr>
            <tr>
              <td>config/queue.php</td>
              <td>конфигурация очередей</td>
            </tr>
            <tr>
              <td>config/mail.php</td>
              <td>конфигурация почты</td>
            </tr>
            <tr>
              <td>config/broadcasting.php</td>
              <td>конфигурация широковещательных каналов</td>
            </tr>
            <tr>
              <td>config/filesystems.php</td>
              <td>конфигурация файловых систем</td>
            </tr>
            <tr>
              <td>config/logging.php</td>
              <td>конфигурация логирования</td>
            </tr>
            <tr>
              <td>config/session.php</td>
              <td>конфигурация сессий</td>
            </tr>
            <tr>
              <td>config/services.php</td>
              <td>конфигурация сервисов</td>
            </tr>
            <tr>
              <td>config/queue.php</td>
              <td>конфигурация очередей</td>
            </tr>
            <tr>
              <td>config/cors.php</td>
              <td>конфигурация CORS</td>
            </tr>
            <tr>
              <td>config/sanctum.php</td>
              <td>конфигурация Sanctum</td>
            </tr>
            <tr>
              <td>config/schedule.php</td>
              <td>конфигурация планировщика задач</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>ENV</caption>
          <tbody>
            <tr>
              <td>.env</td>
              <td>файл окружения приложения</td>
            </tr>
            <tr>
              <td>.env.example</td>
              <td>пример файла окружения приложения</td>
            </tr>
            <tr>
              <td>.env.testing</td>
              <td>файл окружения для тестов</td>
            </tr>
            <tr>
              <td>.env.dusk.local</td>
              <td>файл окружения для Dusk-тестов</td>
            </tr>
            <tr>
              <td>.env.dusk.example</td>
              <td>пример файла окружения для Dusk-тестов</td>
            </tr>
            <tr>
              <td>.env.dusk.testing</td>
              <td>файл окружения для Dusk-тестов</td>
            </tr>
            <tr>
              <td>$_ENV</td>
              <td>суперглобальная переменная содержит все переменные, перечисленные в файле .env</td>
            </tr>
            <tr>
              <td>'debug' => env('APP_DEBUG', false)</td>
              <td>использовать только в конфигурационных файлах для получения значений переменных конфигурации, второй параметр - значение по умолчанию если нет значения переменной</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>Artisan</caption>
          <tbody>
            <tr>
              <td>php artisan about</td>
              <td>обзор конфигурации</td>
            </tr>
            <tr>
              <td>php artisan about --only=environment</td>
              <td>обзор определенного раздела конфигурации</td>
            </tr>
            <tr>
              <td>php artisan config:show database</td>
              <td>обзор  определенного файла конфигурации</td>
            </tr>
            <tr>
              <td>php artisan env:encrypt</td>
              <td>шифрование файла .env</td>
            </tr>
            <tr>
              <td>php artisan config:cache</td>
              <td>кешировать все конфигурационные файлы в один файл при деплое</td>
            </tr>
            <tr>
              <td>php artisan config:clear</td>
              <td>очистки кэша конфигурации</td>
            </tr>
            <tr>
              <td>php artisan config:publish</td>
              <td>публикация файлов конфигурации для модификации</td>
            </tr>
            <tr>
              <td>php artisan down</td>
              <td>включить режим обслуживания</td>
            </tr>
            <tr>
              <td>php artisan up</td>
              <td>отключить режим обслуживания</td>
            </tr>
            <tr>
              <td>php artisan optimize</td>
              <td>оптимизация приложения</td>
            </tr>
            <tr>
              <td>php artisan optimize:clear</td>
              <td>очистка кеша приложения</td>
            </tr>
          </tbody>
        </table>
        <p>Текущее окружение</p>
        <pre><code>use Illuminate\Support\Facades\App;
$environment = App::environment();
</code></pre>
        <p>Доступ к значениям конфигурации</p>
        <pre><code>use Illuminate\Support\Facades\Config;
$value = Config::get('app.timezone');
$value = config('app.timezone');</code></pre>
        <h2>Logging</h2>
        <ul>
          <li>логирование - запись сообщений в журнал</li>
          <li>лог-файл - файл, в который записываются сообщения</li>
          <li>уровень логирования - уровень важности сообщения</li>
          <li>канал (драйвер) логирования - способ записи сообщений в журнал</li>
          <li>драйверы логирования: single, daily, syslog, errorlog, monolog, null, custom</li>
          <li>конфигурация ведения журнала config/logging.php</li>
          <li>изменить имя канала</li>
        </ul>
        <pre><code>'stack' => [
  'driver' => 'stack',
  'name' => 'channel-name',
  'channels' => ['single', 'slack'],
]
</code></pre>
        <p>Конфигурация для продакшина</p>
        <pre><code>'channels' => [
  'stack' => [
    'driver' => 'stack',
    'channels' => ['syslog', 'slack'],  
    'ignore_exceptions' => false,
  ],
  'syslog' => [
    'driver' => 'syslog',
    'level' => env('LOG_LEVEL', 'debug'),
    'facility' => env('LOG_SYSLOG_FACILITY', LOG_USER),
    'replace_placeholders' => true,
  ],
  'slack' => [
    'driver' => 'slack',
    'url' => env('LOG_SLACK_WEBHOOK_URL'),
    'username' => env('LOG_SLACK_USERNAME', 'Laravel Log'),
    'emoji' => env('LOG_SLACK_EMOJI', ':boom:'),
    'level' => env('LOG_LEVEL', 'critical'),
    'replace_placeholders' => true,
  ],
]
</code></pre>
        <ul>
          <li>уровни журнала в порядке убывания критичности: emergency, alert, critical, error, warning, notice, info, и debug</li>
          <li>уровень по умолчанию - debug</li>
          <li>методы записи по уровням</li>
        </ul>
        <pre><code>use Illuminate\Support\Facades\Log;
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);
</code></pre>
        <p>В контроллере</p>
        <pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Support\Facades\Log;
use Illuminate\View\View;
class UserController extends Controller
{
  // Показать профиль конкретного пользователя.
  public function show(string $id): View
  {
    Log::info('Showing the user profile for user: {id}', ['id' => $id]);
    return view('user.profile', [
      'user' => User::findOrFail($id)
    ]);
  }
}
</code></pre>
        <p>Регистрировать в журнале id каждого запроса</p>
        <pre><code>namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;
use Symfony\Component\HttpFoundation\Response;
class AssignRequestId
{
  // Обработчик входящего запроса - @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next): Response
  {
    $requestId = (string) Str::uuid();
    Log::withContext([
      'request-id' => $requestId
    ]);
    $response = $next($request);
    $response->headers->set('Request-Id', $requestId);
    return $response;
  }
}
</code></pre>
        <p>Регистрировать id каждого запроса по всем каналам</p>
        <pre><code>public function handle(Request $request, Closure $next): Response {
  $requestId = (string) Str::uuid();
  Log::shareContext([
    'request-id' => $requestId
  ]);
}
</code></pre>
        <p>Запись в указанный канал</p>
        <pre><code>use Illuminate\Support\Facades\Log;
Log::channel('slack')->info('Something happened!');
</code></pre>
        <p>Запись в несколько каналов</p>
        <pre><code>Log::stack(['single', 'slack'])->info('Something happened!');
</code></pre>
        <p>Создать канал по запросу</p>
        <pre><code>use Illuminate\Support\Facades\Log;
Log::build([
  'driver' => 'single',
  'path' => storage_path('logs/custom.log'),
])->info('Something happened!');
</code></pre>
        <p>Создать канал по запросу и включить в стэк</p>
        <pre><code>use Illuminate\Support\Facades\Log;
$channel = Log::build([
  'driver' => 'single',
  'path' => storage_path('logs/custom.log'),
]);
Log::stack(['slack', $channel])->info('Something happened!');
</code></pre>
        <p>Настроить канал вручную через свой класс</p>
        <pre><code>'single' => [
  'driver' => 'single',
  'tap' => [App\Logging\CustomizeFormatter::class],
  'path' => storage_path('logs/laravel.log'),
  'level' => env('LOG_LEVEL', 'debug'),
  'replace_placeholders' => true,
]
</code></pre>
        <p>Свой класс</p>
        <pre><code>namespace App\Logging;
use Illuminate\Log\Logger;
use Monolog\Formatter\LineFormatter;
class CustomizeFormatter
{
  // настроить переданный экземпляр регистратора.
  public function __invoke(Logger $logger): void
  {
    foreach ($logger->getHandlers() as $handler) {
      $handler->setFormatter(new LineFormatter(
        '[%datetime%] %channel%.%level_name%: %message% %context% %extra%'
      ));
    }
  }
}
</code></pre>
        <p>Указать обработчик</p>
        <pre><code>'logentries' => [
  'driver'  => 'monolog',
  'handler' => Monolog\Handler\SyslogUdpHandler::class,
  'with' => [
    'host' => 'my.logentries.internal.datahubhost.company.com',
    'port' => '10000',
  ],
]
</code></pre>
        <p>Задать форматирование</p>
        <pre><code>'browser' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\BrowserConsoleHandler::class,
  'formatter' => Monolog\Formatter\HtmlFormatter::class,
  'formatter_with' => [
    'dateFormat' => 'Y-m-d',
  ],
],

// либо
'newrelic' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\NewRelicHandler::class,
  'formatter' => 'default',
]
</code></pre>
        <p>Обрабатывать сообщения перед их записью в журнал</p>
        <pre><code>'memory' => [
  'driver' => 'monolog',
  'handler' => Monolog\Handler\StreamHandler::class,
  'with' => [
    'stream' => 'php://stderr',
  ],
  'processors' => [
    // Simple syntax
    Monolog\Processor\MemoryUsageProcessor::class,

    // With options
    [
    'processor' => Monolog\Processor\PsrLogMessageProcessor::class,
    'with' => ['removeUsedContextFields' => true],
    ],
  ],
]
</code></pre>
        <p>Создать канал через фабрику</p>
        <pre><code>'channels' => [
  'example-custom-channel' => [
    'driver' => 'custom',
    'via' => App\Logging\CreateCustomLogger::class,
  ],
]
</code></pre>
        <p>Класс фабрика</p>
        <pre><code>namespace App\Logging;
use Monolog\Logger;
class CreateCustomLogger
{
  // cоздать экземпляр собственного регистратора Monolog
  public function __invoke(array $config): Logger
  {
    return new Logger(/* ... */);
  }
}
</code></pre>
        <p>Просмотр сообщений в журнале</p>
        <pre><code>composer require laravel/pail
php artisan pail

// либо
php artisan pail -v
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>php artisan pail --filter="QueryException"</td>
              <td>фильтровать вывод инфы</td>
            </tr>
            <tr>
              <td>php artisan pail --message="User created" created"</td>
              <td>фильтровать по сообщениям</td>
            </tr>
            <tr>
              <td>php artisan pail --level=error</td>
              <td>фильтровать по уровням</td>
            </tr>
            <tr>
              <td>php artisan pail --user=1</td>
              <td>фильтровать по пользователю</td>
            </tr>
          </tbody>
        </table>
        <h2>Packages</h2>
        <p>Это основной способ добавления функциональности в Laravel.</p>
        <ul>
          <li>Cashier (Stripe) - платежная система Stripe</li>
          <li>Cashier (Paddle) - платежная система Paddle</li>
          <li>Dusk - автоматизация и тестирование браузеров</li>
          <li>Envoy - выполнение задач на удаленных серверах</li>
          <li>Fortify - backend реализация authentication</li>
          <li>Folio - роутер, основанный на страницах для упрощения маршрутизации</li>
          <li>Homestead - локальная среда разработки на Vagrant</li>
          <li>Horizon - панель управления и конфигурацию для Redis системы очередей</li>
          <li>Mix - компиляция и минимизация файлов CSS и JavaScript</li>
          <li>Octane - увеличивает производительность приложения</li>
          <li>Passport - обеспечивает полную реализацию OAuth2 сервера для приложения</li>
          <li>Pennant - комплект флагов без крафт. Флаги позволяют постепенно внедрять новые функции приложений, А/Б тестировать новые интерфейсы, дополнять стратегию развития на основе ствола</li>
          <li>Pint - стиль кода, устанавливается по умолчанию</li>
          <li>Precognition - предвидеть результат будущего HTTP-запроса, выполнит всю промежуточную обработку маршрута и разрешит зависимости контроллера, включая валидацию запросов формы без выполнения метода контроллера.</li>
          <li>Prompts - добавление красивых и удобных форм и подсказок к приложениям командной строки с функциями браузера</li>
          <li>Pulse - сведения о производительности и использовании приложения</li>
          <li>Reverb - масштабируемый в реальном времени WebSocket коммуникаций</li>
          <li>Sail - взаимодействие со средой разработки Docker</li>
          <li>Sanctum - система аутентификации для SPA (приложения с одной страницей), мобильные приложения и простые токены-API</li>
          <li>Scout - полнотекстовоый поиск</li>
          <li>Socialite - аутентификация через соц.сети</li>
          <li>Telescope - предоставляет информацию о поступающих запросах, исключениях, записях записей, баз данных, задаваемых заданий, почтовых сообщений, уведомлениях, операциях кэша, запланированных задачах, переменных дампов и т.д.</li>
          <li>Valet - среда разработки для мак</li>
          <li>Orchestral Testbench - эмулирует приложения Laravel для написания тестов для пакета</li>
        </ul>
        <pre><code>// регистрация сервис-провайдеров и фасадов в composer.json пакета для автозагрузки в Laravel
"extra": {
  "laravel": {
    "providers": ["Barryvdh\\Debugbar\\ServiceProvider"],
    "aliases": {"Debugbar": "Barryvdh\\Debugbar\\Facade"}
  }
}

// отключить в composer.json приложения обнаружение пакета
"extra": {
  "laravel": {
    "dont-discover": ["barryvdh/laravel-debugbar"]
  }
}

// либо отключить обнаружение всех пакетов
"extra": {
  "laravel": {
    "dont-discover": ["*"]
  }
}

// обязательно добавить в зависимости пакета
use Illuminate\Support\ServiceProvider;

// разрешить публикацию файлов конфигурации в ServiceProvider пакета
public function boot(): void {
  $this->publishes([
    __DIR__.'/../config/courier.php' => config_path('courier.php'),
  ]);
}
</code></pre>
        <h3>Конфигурация</h3>
        <p>опубликовать конфигурационный файл пакета в каталог config приложения</p>
        <pre><code>php artisan vendor:publish</code></pre>
        <p>доступ к опубликованному файлу конфигурации пакета из приложения</p>
        <pre><code>$value = config('courier.option');

// объединить конфигурационный файл пакета с конфигурационным файлом приложения в ServiceProvider пакета
public function register(): void {
  $this->mergeConfigFrom(

    // первый параметр: конфиг пакета, второй - конфиг приложения
    __DIR__.'/../config/courier.php', 'courier'
  );
}

//если пакет содержит маршруты, то закеширует их
public function boot(): void {$this->loadRoutesFrom(__DIR__.'/../routes/web.php');}

//если пакет содержит миграции БД, то сообщить Laravel, что указанный каталог или файл содержит миграции
public function boot(): void {
  $this->publishesMigrations([
    __DIR__.'/../database/migrations' => database_path('migrations'),
  ]);
}

//если пакет содержит языковые файлы, то сообщить Laravel как их загрузить
public function boot(): void {$this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');}

// ссылка на перевод: package::file.line, например загрузить строку приветствия пакета courier из файла messages
echo trans('courier::messages.welcome');

// зарегистрировать файлы перевода пакета в формате JSON
public function boot(): void {$this->loadJsonTranslationsFrom(__DIR__.'/../lang');}

// опубликовать языковые файлы пакета в каталоге resources/lang/vendor приложения
public function boot(): void {
  $this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');
  $this->publishes([

    // путь пакета и желаемое место публикации
    __DIR__.'/../lang' => $this->app->langPath('vendor/courier'),
  ]);
}
</code></pre>
        <p>опубликовать (скопировать в resources/lang/vendor/courier)</p>
        <pre><code>php artisan vendor:publish</code></pre>
        <h3>Шаблоны</h3>
        <pre><code>// зарегистрировать шаблоны пакета в ServiceProvider пакета укзать путь к шаблонам и имя пакета
public function boot(): void {$this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');}

// ссылка на шаблон: package::view, например загрузить шаблон dashboard пакета courier
Route::get('/dashboard', function () {return view('courier::dashboard');});

// публикации шаблонов в resources/views/vendor
public function boot(): void {
  $this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');
  $this->publishes([
    __DIR__.'/../resources/views' => resource_path('views/vendor/courier'),
  ]);
}
</code></pre>
        <p>опубликовать (скопировать в resources/views/vendor/courier)</p>
        <pre><code>php artisan vendor:publish

// чтобы Laravel знал, где найти компонент, зарегистрировать его в ServiceProvider пакета
use Illuminate\Support\Facades\Blade;
use VendorPackage\View\Components\AlertComponent;
public function boot(): void
{Blade::component('package-alert', AlertComponent::class);}
</code></pre>
        <p>использовать компонент</p>
        <pre><code>< x-package-alert/>

// метод componentNamespace автоматически загрузить классы компонентов из пакета Nightshade
компоненты Calendar и ColorPicker находятся в пространстве имен Nightshade\Views\Components
use Illuminate\Support\Facades\Blade;
public function boot(): void {
  Blade::componentNamespace('Nightshade\\Views\\Components', 'nightshade');
}
</code></pre>
        <p>использовать компоненты пакета</p>
        <pre><code>< x-nightshade::calendar />
< x-nightshade::color-picker />
</code></pre>
        <h3>Команды</h3>
        <pre><code>// добавить информацию о пакете в вывод команды Artisan about: краткое описание окружения и конфигурации приложения
use Illuminate\Foundation\Console\AboutCommand;
public function boot(): void
{AboutCommand::add('Мой Пакет', fn () => ['Версия' => '1.0.0']);}

// зарегистрировать Artisan-команды пакета в Laravel: указать массив классов команд
use Courier\Console\Commands\InstallCommand;
use Courier\Console\Commands\NetworkCommand;
public function boot(): void {
  if ($this->app->runningInConsole()) {
    $this->commands([
      InstallCommand::class,
      NetworkCommand::class
    ]);
  }
}
</code></pre>
        <p>команда Laravel optimize кэширует конфигурацию приложения, события, маршруты и представления</p>
        <pre><code>// указать команды пакета для выполнения при вызове optimize и clear
public function boot(): void {
  if ($this->app->runningInConsole()) {
    $this->optimizes(
      optimize: 'package:optimize',
      clear: 'package:clear-optimizations'
    );
  }
}
</code></pre>
        <p>опубликовать публичные ресурсы пакета (изображения и скомпилированные JavaScript, CSS) с префиксом public</p>
        <pre><code>public function boot(): void {$this->publishes([__DIR__.'/../public' => public_path('vendor/courier')], 'public');}</code></pre>
        <p>опубликовать (скопировать в public/vendor/courier)</p>
        <pre><code>php artisan vendor:publish

// перезаписывать ресурсы каждый раз при обновлении пакета
php artisan vendor:publish --tag=public --force
</code></pre>
        <p>публикация указанных файлов</p>
        <pre><code>public function boot(): void {
  $this->publishes([__DIR__.'/../config/package.php' => config_path('package.php')], 'courier-config');
  $this->publishesMigrations([__DIR__.'/../database/migrations/' => database_path('migrations')], 'courier-migrations');
}
</code></pre>
        <p>опубликовать группы файлов отдельно, ссылаясь на их теги</p>
        <pre><code>php artisan vendor:publish --tag=courier-config</code></pre>
        <h2>Testing</h2>
        <ul>
          <li>pest: это обёртка для phpunit</li>
          <li>файл tests/Pest.php - конфигурация тестов</li>
          <li>настроить переменные окружения testing можно в phpunit.xml</li>
          <li>после внесения изменений выполнить очистку кэша</li>
        </ul>
        <pre><code>php artisan config:clear</code></pre>
        <p>при тестировании вместо .env можно использовать .env.testing, сгенерировать новый тестовый файл .env.testing</p>
        <pre><code>cp .env.example .env.testing

// в UserTest

test('basic', function () {
  expect(true)->toBeTrue();
});
</code></pre>
        <p>создание и запуск тестов</p>
        <pre><code>// создаю тест
php artisan make:test

// запускаю тест
php artisan test

// создание теста в tests/Feature
php artisan make:test UserTest

// создание теста в tests/Unit
php artisan make:test UserTest --unit

// создание юнит-теста с использованием Pest, если файл уже существует, без вывода сообщений в консоль, без интерактивного ввода и без ANSI-вывода
php artisan make:test UserTest --pest --unit --force --quiet --no-interaction --no-ansi

// запуск тестов
php artisan test
./vendor/bin/phpunit
./vendor/bin/pest
./vendor/bin/phpunit tests/Feature/UserTest.php::testBasic
./vendor/bin/phpunit tests/Unit/UserTest.php::testBasic

// передать аргументы
php artisan test --testsuite=Feature --stop-on-failure

// параллельный запуск тестов
composer require brianium/paratest --dev
php artisan test --parallel

// настроить количество процессов - не более количества ядер ЦП на компьюторе
php artisan test --parallel --processes=4

// пересоздать тестовые БД
php artisan test --parallel --recreate-databases
</code></pre>
        <p>хуки параллельного тестирования</p>
        <pre><code>$token       - токен процесса
$testCase    - текущий тестовый класс

namespace App\Providers;
use Illuminate\Support\Facades\Artisan;
use Illuminate\Support\Facades\ParallelTesting;
use Illuminate\Support\ServiceProvider;
use PHPUnit\Framework\TestCase;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {
    ParallelTesting::setUpProcess(function (int $token) {});
    ParallelTesting::setUpTestCase(function (int $token, TestCase $testCase) {});

    // Выполнится при создании тестовой БД...
    ParallelTesting::setUpTestDatabase(function (string $database, int $token) {
      Artisan::call('db:seed');
    });

    ParallelTesting::tearDownTestCase(function (int $token, TestCase $testCase) {});
    ParallelTesting::tearDownProcess(function (int $token) {});
  }
}

// доступ к текущему “токену” параллельного процесса из любого места приложения
$token = ParallelTesting::token();

// отчет о покрытии тестами (требуется Xdebug или PCOV.)
php artisan test --coverage

// задать минимальный порог покрытия тестами
php artisan test --coverage --min=80.3

// получить список десяти самых медленных тестов
php artisan test --profile
</code></pre>
        <p>сделать запрос к приложению - вызвать в тесте методы get, post, put, patch, или delete: один тест - один запрос</p>
        <pre><code>test('the application returns a successful response', function () {
  $response = $this->get('/');
  $response->assertStatus(200);
});

// настройки заголовков запроса
test('interacting with headers', function () {
  $response = $this->withHeaders([
    'X-Header' => 'Value',
  ])->post('/user', ['name' => 'Sally']);
  $response->assertStatus(201);
});

// установить значения файлов Cookies
test('interacting with cookies', function () {
  $response = $this->withCookie('color', 'blue')->get('/');
  $response = $this->withCookies([
    'color' => 'blue',
    'name' => 'Taylor',
  ])->get('/');
});

// установить данные сессии
test('interacting with the session', function () {
  $response = $this->withSession(['banned' => false])->get('/');
});

// actingAs – аутентифицировать указанного пользователя как текущего
use App\Models\User;
test('an action that requires authentication', function () {
  $user = User::factory()->create();
  $response = $this->actingAs($user)
            ->withSession(['banned' => false])
            ->get('/');
});

// с использованием гэйта
code $this->actingAs($user, 'web')

// проверка и отладка содержимого ответа
test('basic test', function () {
  $response = $this->get('/');
  $response->dumpHeaders();
  $response->dumpSession();
  $response->dump();
});

// либо
test('basic test', function () {
  $response = $this->get('/');
  $response->ddHeaders();
  $response->ddSession();
  $response->dd();
});
</code></pre>
        <p>тесты исключений</p>
        <pre><code>use App\Exceptions\InvalidOrderException;
use Illuminate\Support\Facades\Exceptions;
test('exception is thrown', function () {
  Exceptions::fake();
  $response = $this->get('/order/1');

  // Было ли выброшено исключение InvalidOrderException
  Exceptions::assertReported(InvalidOrderException::class);
  
  // Было ли выброшено исключение InvalidOrderException с заданным сообщением
  Exceptions::assertReported(function (InvalidOrderException $e) {
    return $e->getMessage() === 'The order was invalid.';
  });
});

// указанное исключение и никаких исключений не было создано во время запроса
Exceptions::assertNotReported(InvalidOrderException::class);
Exceptions::assertNothingReported();

// отключить обработку исключений для данного запроса
$response = $this->withoutExceptionHandling()->get('/');

// проверить, что приложение не использует устаревшие функции
$response = $this->withoutDeprecationHandling()->get('/');

// проверить, что код внутри замыкания генерирует исключение указанного типа
$this->assertThrows(
  fn () => (new ProcessOrder)->execute(),
  OrderInvalid::class
);

// проверить, что код внутри замыкания генерирует исключение указанного типа, а исключение равно заданому значению
$this->assertThrows(
  fn () => (new ProcessOrder)->execute(),
  fn (OrderInvalid $e) => $e->orderId() === 123;
);
</code></pre>
        <p>методы для тестирования API-интерфейсов JSON и их ответов: json, getJson, postJson, putJson, patchJson, deleteJson, и optionsJson</p>
        <pre><code>// сделать запрос POST к /api/user
test('making an api request', function () {
  $response = $this->postJson('/api/user', ['name' => 'Sally']);
  $response->assertStatus(201)
  
    // метод assertJson используется для подтверждения наличия фрагмента JSON в ответе JSON
    ->assertJson([
      'created' => true,
    ]);
});

// получить доступ к данным ответа JSON как к массиву
expect($response['created'])->toBeTrue();

// проверить, что массив в точности соответствует JSON
test('asserting an exact json match', function () {
  $response = $this->postJson('/user', ['name' => 'Sally']);
  $response
    ->assertStatus(201)
    ->assertExactJson([
      'created' => true,
    ]);
});

// убедиться, что ответ JSON содержит данные по указанному пути
test('asserting a json path value', function () {
  $response = $this->postJson('/user', ['name' => 'Sally']);
  $response
    ->assertStatus(201)
    ->assertJsonPath('team.owner.name', 'Darian');
});

// динамическое определение, должно ли утверждение выполниться
$response->assertJsonPath('team.owner.name', fn (string $name) => strlen($name) >= 3);

// последовательное тестирование ответов JSON
use Illuminate\Testing\Fluent\AssertableJson;
test('fluent json', function () {
  $response = $this->getJson('/users/1');
  $response
    ->assertJson(fn (AssertableJson $json) => $json->where('id', 1)

      // where - для присутствующего атрибута 
      ->where('name', 'Victoria Faith')
      ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
      ->whereNot('status', 'pending')

      // missing - для отсутствующего атрибута JSON
      ->missing('password')
      
      // etc - в объекте JSON могут присутствовать другие атрибуты
      ->etc()
    );
});

// проверить, что атрибут присутствует или отсутствует (has и missing)
$response->assertJson(fn (AssertableJson $json) => $json->has('data')->missing('message'));

// наличие или отсутствие нескольких атрибутов (hasAll и missingAll)
$response->assertJson(fn (AssertableJson $json) => $json->hasAll(['status', 'data'])->missingAll(['message', 'code']));

// присутствует ли хотя бы один из заданного списка
$response->assertJson(fn (AssertableJson $json) => $json->has('status')->hasAny('data', 'message', 'code'));

// проверить маршрут, который возращает всех пользователей
Route::get('/users', function () {return User::all();});

// тест по первому пользователю
$response
  ->assertJson(fn (AssertableJson $json) => $json->has(3)
    ->first(fn (AssertableJson $json) => $json->where('id', 1)
      ->where('name', 'Victoria Faith')
      ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
      ->missing('password')
      ->etc()
    )
  );

// проверить маршрут, который возвращает коллекцию JSON с именованными ключами
Route::get('/users', function () {
  return [
    'meta' => [...],
    'users' => User::all(),
  ];
})

// тест
$response
  ->assertJson(fn (AssertableJson $json) =>
    $json->has('meta')
      ->has('users', 3)
      ->has('users.0', fn (AssertableJson $json) =>
        $json->where('id', 1)
          ->where('name', 'Victoria Faith')
          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
          ->missing('password')
          ->etc()
      )
  );

// либо
$response
  ->assertJson(fn (AssertableJson $json) =>
    $json->has('meta')
      ->has('users', 3, fn (AssertableJson $json) =>
        $json->where('id', 1)
          ->where('name', 'Victoria Faith')
          ->where('email', fn (string $email) => str($email)->is('victoria@gmail.com'))
          ->missing('password')
          ->etc()
      )
  );

// проверить тип
$response->assertJson(fn (AssertableJson $json) =>
  $json->whereType('id', 'integer')
    ->whereAllType([
      'users.0.name' => 'string',
      'meta' => 'array'
    ])
);

// проверить наличие одного из типов, допустимые типы: string, integer, double, boolean, array, и null
$response->assertJson(fn (AssertableJson $json) =>
  $json->whereType('name', 'string|null')
    ->whereType('id', ['string', 'integer'])
);
</code></pre>
        <p>тесты загрузки файлов: протестировать форму загрузки аватара, метод fake есть у класса UploadedFile и у фасада Storage</p>
        <pre><code>use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
test('avatars can be uploaded', function () {
  Storage::fake('avatars');
  $file = UploadedFile::fake()->image('avatar.jpg');
  $response = $this->post('/avatar', ['avatar' => $file]);
  Storage::disk('avatars')->assertExists($file->hashName());
});

// подтвердить, что переданный файл не существует
Storage::fake('avatars');
Storage::disk('avatars')->assertMissing('missing.jpg');

// указать ширину, высоту и размер изображения (в килобайтах)
UploadedFile::fake()->image('avatar.jpg', $width, $height)->size(100);

// создать pdf
UploadedFile::fake()->create('document.pdf', $sizeInKilobytes);

// явно определить MIME-тип файла
UploadedFile::fake()->create('document.pdf', $sizeInKilobytes, 'application/pdf');
</code></pre>
        <p>тесты шаблонов: assertSee, assertSeeInOrder, assertSeeText, assertSeeTextInOrder, assertDontSee и assertDontSeeText</p>
        <pre><code>test('a welcome view can be rendered', function () {
  $view = $this->view('welcome', ['name' => 'Taylor']);
  $view->assertSee('Taylor');
});

// получить необработанное отрисованное содержимое шаблона
$contents = (string) $this->view('welcome');

// добавить в глобальную коллекцию ошибок сообщения об ошибках
$view = $this->withViewErrors([
  'name' => ['Please provide a valid name.']
])->view('form');
$view->assertSee('Please provide a valid name.');

// метод blade возвращает экземпляр Illuminate\Testing\TestView
$view = $this->blade(
  '&lt;x-component :name="$name" /&gt;',
  ['name' => 'Taylor']
);
$view->assertSee('Taylor');

// метод component возвращает экземпляр Illuminate\Testing\TestComponent
$view = $this->component(Profile::class, ['name' => 'Taylor']);
$view->assertSee('Taylor');
</code></pre>
        <p>тесты аутентификации</p>
        <pre><code>// пользователь аутентифицирован
$this->assertAuthenticated($guard = null);

// пользователь не аутентифицирован
$this->assertGuest($guard = null);

// конкретный пользователь аутентифицирован
$this->assertAuthenticatedAs($user, $guard = null);
</code></pre>
        <p>тесты валидации: ответ содержит ошибки валидации для указанных ключей</p>
        <pre><code>$response->assertInvalid(['name', 'email']);

// либо
$response->assertInvalid([
  'name' => 'The name field is required.',
  'email' => 'valid email address',
]);
</code></pre>
        <p>тесты консоли</p>
        <ul>
          <li>метод artisan для вызова Artisan-команды из теста,</li>
          <li>метод assertExitCode, проверить, что команда завершилась с указанным кодом (код 0 - успех, остальное - нет)</li>
        </ul>
        <pre><code>test('console command', function () {
  $this->artisan('inspire')->assertExitCode(0);
});

// команда не завершилась с заданным кодом
$this->artisan('inspire')->assertNotExitCode(1);

// либо
$this->artisan('inspire')->assertSuccessful();
$this->artisan('inspire')->assertFailed();

// включить генерацию консольных событий при выполнении тестов
use Illuminate\Foundation\Testing\WithConsoleEvents;
uses(WithConsoleEvents::class);
</code></pre>
        <p>тесты ввода/вывода</p>
        <ul>
          <li>метод expectsQuestion - имитировать ввод пользователя в консольных командах</li>
          <li>метод assertExitCode - ожидаемый код завершения команды</li>
          <li>метод expectsOutput - ожидаемый при выполнении команды текст</li>
        </ul>
        <pre><code>// консольная команда
Artisan::command('question', function () {
  $name = $this->ask('What is your name?');
  $language = $this->choice('Which language do you prefer?', [
    'PHP',
    'Ruby',
    'Python',
  ]);
  $this->line('Your name is '.$name.' and you prefer '.$language.'.');
});

// проверить команду
test('console command', function () {
  $this->artisan('question')
    ->expectsQuestion('What is your name?', 'Taylor Otwell')
    ->expectsQuestion('Which language do you prefer?', 'PHP')
    ->expectsOutput('Your name is Taylor Otwell and you prefer PHP.')
    ->doesntExpectOutput('Your name is Taylor Otwell and you prefer Ruby.')
    ->assertExitCode(0);
});

// expectsSearch, чтобы имитировать ввод пользователя, результаты поиска и выбор
test('console command', function () {
  $this->artisan('example')
    ->expectsSearch('What is your name?', search: 'Tay', answers: [
      'Taylor Otwell',
      'Taylor Swift',
      'Darian Taylor'
    ], answer: 'Taylor Otwell')
    ->assertExitCode(0);
});

// проверить, что команда не генерирует никакого вывода
test('console command', function () {
  $this->artisan('example')
    ->doesntExpectOutput()
    ->assertExitCode(0);
});

// проверить часть вывода
test('console command', function () {
  $this->artisan('example')
    ->expectsOutputToContain('Taylor')
    ->assertExitCode(0);
});

// команда ожидает ответа «да» или «нет»
$this->artisan('module:import')
  ->expectsConfirmation('Do you really wish to run this command?', 'no')
  ->assertExitCode(1);

// проверить таблицу
$this->artisan('users:all')
  ->expectsTable([
    'ID',
    'Email',
  ], [
    [1, 'taylor@example.com'],
    [2, 'abigail@example.com'],
  ]);
</code></pre>
        <p>тесты БД</p>
        <pre><code>// сброс БД после каждого теста
use Illuminate\Foundation\Testing\RefreshDatabase;
uses(RefreshDatabase::class);
test('basic example', function () {
  $response = $this->get('/');
});
</code></pre>
        <p>полностью сбросить БД</p>
        <ul>
          <li>использовать трейты Illuminate\Foundation\Testing\DatabaseMigrations или Illuminate\Foundation\Testing\DatabaseTruncation</li>
          <li>использовать фабрику в тестах</li>
        </ul>
        <pre><code>use App\Models\User;
test('models can be instantiated', function () {
  $user = User::factory()->create();
});

// использовать наполнитель в тестах
use Database\Seeders\OrderStatusSeeder;
use Database\Seeders\TransactionStatusSeeder;
use Illuminate\Foundation\Testing\RefreshDatabase;
uses(RefreshDatabase::class);
test('orders can be created', function () {
  // Run the DatabaseSeeder...
  $this->seed();
  // Run a specific seeder...
  $this->seed(OrderStatusSeeder::class);
  Run an array of specific seeders...
    $this->seed([
      OrderStatusSeeder::class,
      TransactionStatusSeeder::class,
  ]);
});

// автоматически заполнять базу данных перед каждым тестом
namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
abstract class TestCase extends BaseTestCase
{
  // Указывает, следует ли запускать наполнитель по умолчанию перед каждым тестом.
  // @var bool
  protected $seed = true;
}

// либо
use Database\Seeders\OrderStatusSeeder;
protected $seeder = OrderStatusSeeder::class;

// таблица в базе данных содержит указанное количество записей
$this->assertDatabaseCount('users', 5);

// таблица в базе данных не содержит записей
$this->assertDatabaseEmpty('users');

// таблица в базе данных содержит записи, соответствующие переданным ключ/значение
$this->assertDatabaseHas('users', [
  'email' => 'sally@example.com',
]);

// таблица в базе данных не содержит записей, соответствующих переданным ключ/значение
$this->assertDatabaseMissing('users', [
  'email' => 'sally@example.com',
]);

// модель была «программно удалена»
$this->assertSoftDeleted($user);

// модель не была «программно удалена»
$this->assertNotSoftDeleted($user);

// данная модель существует в базе данныхuse App\Models\User;
$user = User::factory()->create();
$this->assertModelExists($user);

// данной модели не существует в базе данных
use App\Models\User;
$user = User::factory()->create();
$user->delete();
$this->assertModelMissing($user);

// ожидаемое числа запросов к базе данных во время выполнения теста
$this->expectsDatabaseQueryCount(5);
</code></pre>
        <p>имитация</p>
        <pre><code>// использовать подставной экземпляр объекта вместо создания самого объекта
use App\Service;
use Mockery;
use Mockery\MockInterface;
test('something can be mocked', function () {
  $this->instance(
    Service::class,
    Mockery::mock(Service::class, function (MockInterface $mock) {
      $mock->shouldReceive('process')->once();
    })
  );
});

// либо
use App\Service;
use Mockery\MockInterface;
$mock = $this->mock(Service::class, function (MockInterface $mock) {
  $mock->shouldReceive('process')->once();
});

// имитировать несколько методов объекта
use App\Service;
use Mockery\MockInterface;
$mock = $this->partialMock(Service::class, function (MockInterface $mock) {
  $mock->shouldReceive('process')->once();
});

// шпионы записывают любое взаимодействие между шпионом и тестируемым кодом
use App\Service;
$spy = $this->spy(Service::class);
$spy->shouldHaveReceived('process');

// для контроллера
namespace App\Http\Controllers;
use Illuminate\Support\Facades\Cache;
class UserController extends Controller
{
  //  Получить список всех пользователей приложения
  public function index(): array
  {
    $value = Cache::get('key');
    return [];
  }
}

// имитировать вызов фасада Cache
use Illuminate\Support\Facades\Cache;
test('get index', function () {
  Cache::shouldReceive('get')
        ->once()
        ->with('key')
        ->andReturn('value');
  $response = $this->get('/users');
});

// шпионить за фасадом
use Illuminate\Support\Facades\Cache;
test('values are be stored in cache', function () {
  Cache::spy();
  $response = $this->get('/');
  $response->assertStatus(200);
  Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);
});
</code></pre>
        <p>управлять текущим временем</p>
        <pre><code>test('time can be manipulated', function () {
  // Travel into the future...
  $this->travel(5)->milliseconds();
  $this->travel(5)->seconds();
  $this->travel(5)->minutes();
  $this->travel(5)->hours();
  $this->travel(5)->days();
  $this->travel(5)->weeks();
  $this->travel(5)->years();

  // Travel into the past...
  $this->travel(-5)->hours();

  // Travel to an explicit time...
  $this->travelTo(now()->subHours(6));

  // Return back to the present time...
  $this->travelBack();
});

// либо
$this->travel(5)->days(function () {
  // Test something five days into the future...
});
$this->travelTo(now()->subDays(10), function () {
  // Test something during a given moment...
});

// либо
use Illuminate\Support\Carbon;

// Freeze time and resume normal time after executing closure...
$this->freezeTime(function (Carbon $time) { });

// Freeze time at the current second and resume normal time after executing closure...
$this->freezeSecond(function (Carbon $time) { })

// блокировка неактивных сообщений на форуме
use App\Models\Thread;
test('forum threads lock after one week of inactivity', function () {
  $thread = Thread::factory()->create();
  $this->travel(1)->week();
  expect($thread->isLockedByInactivity())->toBeTrue();
});
</code></pre>
        <p>тесты событий</p>
        <pre><code>use App\Events\OrderFailedToShip;
use App\Events\OrderShipped;
use Illuminate\Support\Facades\Event; 
test('orders can be shipped', function () {

  // вызвать после использования фабрик
  Event::fake();

  // подтвердить, что событие было отправлено
  Event::assertDispatched(OrderShipped::class);

  // подтвердить, что событие было отправлено дважды
  Event::assertDispatched(OrderShipped::class, 2);

  // подтвердить, что событие не было отправлено
  Event::assertNotDispatched(OrderFailedToShip::class);

  // подтвердить, что не было отправлено ни одного события
  Event::assertNothingDispatched();
});

// либо подтвердить, что было отправлено событие, которое соответствует данному условию
Event::assertDispatched(function (OrderShipped $event) use ($order) {return $event->order->id === $order->id;});

// либо подтвердить, что слушатель слушает указанное событие
Event::assertListening(OrderShipped::class, SendShipmentNotification::class);

// подменить слушателей событий только для указанного набора событий
test('orders can be processed', function () {
  Event::fake([OrderCreated::class]);
  $order = Order::factory()->create();
  Event::assertDispatched(OrderCreated::class);
  $order->update([...]);});

// либо подменить все события, кроме указанных
Event::fake()->except([OrderCreated::class]);

// подменить слушателей событий только в определенной части теста: метод fakeFor()
use App\Events\OrderCreated;
use App\Models\Order;
use Illuminate\Support\Facades\Event;
test('orders can be processed', function () {
  $order = Event::fakeFor(function () {
    $order = Order::factory()->create();
    Event::assertDispatched(OrderCreated::class);
    return $order;});
  $order->update([...]);});</code></pre>
        <h2>Exceptions</h2>
        <ul>
          <li>метод withExceptions в bootstrap/app.php управляет исключениями и выводом сообщений о них</li>
          <li>$exceptions - экземпляр IlluminateFoundationConfigurationExceptions</li>
          <li>debug в config/app.php определяет сколько показать информации об ошибке</li>
          <li>переменная окружения APP_DEBUG в .env при разработке = true, на продакшине false</li>
          <li>выполняться, когда необходимо сообщить об исключении определенного типа</li>
          <li>сообщения об исключениях записываются в журнал с указанием уровня серьезности и важности</li>
          <li>по умолчанию Laravel преобразует исключения в HTTP-ответ</li>
        </ul>
        <h2>Exceptions</h2>
        <p>создать исключения с методами render и report, если файл уже существует, без вывода сообщений в консоль, без интерактивного ввода и без ANSI-вывода</p>
        <pre><code>php artisan make:exception CustomException --render --report --force --quiet --no-interaction --no-ansi</code></pre>
        <p>опубликовать стандартные шаблоны страниц ошибок</p>
        <pre><code>php artisan vendor:publish --tag=laravel-errors</code></pre>
        <p>шаблоны страниц ошибок если нет страницы для нужного кода ошибки:</p>
        <ul>
          <li>resources/views/errors/4xx.blade.php</li>
          <li>resources/views/errors/5xx.blade.php</li>
        </ul>
        <pre><code>// вывести ошибку в resources/views/errors/404.blade.php
< h2>{{ $exception->getMessage() }}< /h2>

// вызвать исключение
abort(404);
abort(403, 'Unauthorized action.');
abort(403, 'Unauthorized action.', ['X-Header' => 'Value']);

// управлять исключениями в bootstrap/app.php
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->report(
    function (InvalidOrderException $e) { }
  );
})

// остановить регистрацию исключения в стек журналов логирования по умолчанию
->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->report(
      function (InvalidOrderException $e) { })->stop();
    })

// либо
$exceptions->report(function (InvalidOrderException $e) {return false;});

// определить свои собственные глобальные контекстные данные
->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->context(fn () => ['foo' => 'bar']);
  })

// об одном экземпляре исключения сообщать только один раз
->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->dontReportDuplicates();
  })

// применить
$original = new RuntimeException('Whoops!');
report($original);           // сообщено

try {throw $original;}
catch (Throwable $caught) {
  report($caught);}          // проигнорировано

report($original);           // проигнорировано
report($caught);             // проигнорировано

// задать сообщению уровень для записи
use PDOException;
use Psr\Log\LogLevel;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->level(PDOException::class, LogLevel::CRITICAL);
  })

// игнорировать исключения
use App\Exceptions\InvalidOrderException;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->dontReport([InvalidOrderException::class]);
  })

// либо
namespace App\Exceptions;
use Exception;
use Illuminate\Contracts\Debug\ShouldntReport;

class PodcastProcessingException extends Exception implements ShouldntReport { }

// прекратить игнорировать определенный тип исключения
use Symfony\Component\HttpKernel\Exception\HttpException;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->stopIgnoring(HttpException::class);
  })

// изменить тип исключения
use App\Exceptions\InvalidOrderException;
use Illuminate\Http\Request;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->render(
      function (InvalidOrderException $e, Request $request) {
        return response()->view('errors.invalid-order', status: 500);
      });})

// либо
use Illuminate\Http\Request;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->render(
      function (NotFoundHttpException $e, Request $request) {
        if ($request->is('api/*')) {
          return response()->json(['message' => 'Record not found.'], 404);
        }});})

// отобразить исключение в формате JSON
use Illuminate\Http\Request;
use Throwable;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->shouldRenderJsonWhen(
      function (Request $request, Throwable $e) {
        if ($request->is('admin/*')) {return true;}
        return $request->expectsJson();
      });})

// настроить HTTP-ответ на исключение
use Symfony\Component\HttpFoundation\Response;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->respond(
      function (Response $response) {
        if ($response->getStatusCode() === 419) {
          return back()->with(['message' => 'The page expired, please try again.']);
        }
        return $response;
      });})

// выбрать случайное количество исключений
use Illuminate\Support\Lottery;
use Throwable;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->throttle(
      function (Throwable $e) {
        return Lottery::odds(1, 1000);
      });})

// выбрать исключения определённого типа
use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Throwable;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->throttle(
      function (Throwable $e) {
        if ($e instanceof BroadcastException) {
          return Limit::perMinute(300);
        }});})

// либо
use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Throwable;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->throttle(
      function (Throwable $e) {
        if ($e instanceof BroadcastException) {
          return Limit::perMinute(300)->by($e->getMessage());
        }});})

// либо
use App\Exceptions\ApiMonitoringException;
use Illuminate\Broadcasting\BroadcastException;
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Lottery;
use Throwable;

->withExceptions(
  function (Exceptions $exceptions) {
    $exceptions->throttle(
      function (Throwable $e) {
        return match (true) {
          $e instanceof BroadcastException => Limit::perMinute(300),
          $e instanceof ApiMonitoringException => Lottery::odds(1, 1000),
          default => Limit::none(),
        };});})

// добавить уникальный контекст для конкретного исключения
namespace App\Exceptions;
use Exception;

class InvalidOrderException extends Exception
{
  public function context(): array
  {return ['order_id' => $this->orderId];}
}

// сообщить об исключении и продолжить обработку текущего запроса, не отображая страницу с ошибкой
public function isValid(string $value): bool
{
  try {
    // Проверка `$value`
  } catch (Throwable $e) {
    report($e);
    return false;
  }
}

// поведение отчетов и отображение ошибок определено методами report и render
namespace App\Exceptions;
use Exception;
use Illuminate\Http\Request;
use Illuminate\Http\Response;

class InvalidOrderException extends Exception
{
  public function report(): void { }                  // отчитаться об исключении
  public function render(Request $request): Response  // преобразовать исключение в HTTP-ответ
  {return response();}
}</code></pre>
        <h2>Queue</h2>
        <ul>
          <li>Laravel позволяет создавать задания (jobs) в очереди (queue), которые могут обрабатываться в фоновом режиме.</li>
          <li>Конфигурации очереди в config/queue.php.</li>
          <li>Драйвер sync является драйвером очереди по-умолчанию.</li>
          <li>Пакет Horizon - панель мониторинга и система настройки для очередей на базе Redis.</li>
          <li>Соединение может иметь несколько очередей и определяет параметры подключения к серверным службам очередей, таким как Amazon SQS, Beanstalk или Redis.</li>
          <li>Очередь - это стек или пачка заданий.</li>
          <li>Бинарные данные, например, необработанное содержимое изображения, передавать заданию через функцию base64_encode.</li>
        </ul>
        <pre><code>use App\Jobs\ProcessPodcast;

// Это задание отправляется в очередь `default` соединения по умолчанию
ProcessPodcast::dispatch();

// Это задание отправляется в очередь `emails` соединения по умолчанию
ProcessPodcast::dispatch()->onQueue('emails');

// определить приоритет обработки очередей
php artisan queue:work --queue=high,default

// создать таблицу БД для драйвера очереди database (создаётся по умолчанию)
php artisan make:queue-table

// сгенерировать новое задание в app/Jobs
php artisan make:job ProcessPodcast

// в App\Providers\AppServiceProvider сервис-контейнер автоматически внедряет зависимости, внедрять зависимости вручную:
use App\Jobs\ProcessPodcast;
use App\Services\AudioProcessor;
use Illuminate\Contracts\Foundation\Application;

$this->app->bindMethod(
  [ProcessPodcast::class, 'handle'],
  function (ProcessPodcast $job, Application $app) {
    return $job->handle($app->make(AudioProcessor::class));
  });</code></pre>
        <ul>
          <li>чтобы использовать драйвер очереди database нужна таблица БД 0001_01_01_000002_create_jobs_table.php</li>
          <li>Чтобы использовать драйвер очереди redis, настроить соединение с БД Redis в config/database.php</li>
        </ul>
        <pre><code>'redis' => [
  'driver' => 'redis',
  'connection' => env('REDIS_QUEUE_CONNECTION', 'default'),
  'queue' => env('REDIS_QUEUE', '{default}'),
  'retry_after' => env('REDIS_QUEUE_RETRY_AFTER', 90),
  'block_for' => null,
  'after_commit' => false]

// предотвратить обработку сигнала SIGTERM пока не будет обработано следующее задание.
// драйвер блокируется на пять секунд, ожидая, пока задание станет доступным
'block_for' => 5,

//  обработчики очереди блокируются пока задание не станет доступным.           
'block_for' => 0,
</code></pre>
        <p>посредник (middleware) задания позволяет обернуть пользовательскую логику вокруг выполнения заданий в очереди, при использовании Redis лучше использовать посредника Illuminate\Queue\Middleware\RateLimitedWithRedis</p>
        <pre><code>// ограничения частоты в методе handle
use Illuminate\Support\Facades\Redis;
public function handle(): void {
  Redis::throttle('key')->block(0)->allow(1)->every(5)->then(
    function () {
      info('Lock obtained...');
      // Обработка задания
    },

    // Не удалось получить блокировку
    function () {
      // обрабатывать только одно задание каждые пять секунд
      return $this->release(5);
    }
  );
}

// определить посредника задания
namespace App\Jobs\Middleware;
use Closure;
use Illuminate\Support\Facades\Redis;

class RateLimited {
  public function handle(object $job, Closure $next): void {
    Redis::throttle('key')->block(0)->allow(1)->every(5)
      ->then(

        // Блокировка получена
        function () use ($job, $next) {
          $next($job);
        },

        // Не удалось получить блокировку
        function () use ($job) {
          $job->release(5);
        }
      );
  }
}

// применить посредника
use App\Jobs\Middleware\RateLimited;
public function middleware(): array {return [new RateLimited];}

// в App\Providers\AppServiceProvider ограничить частоту выполнения задания
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Facades\RateLimiter;

public function boot(): void {
  RateLimiter::for(
    'backups',
    function (object $job) {
      return $job->user->vipCustomer()
        ? Limit::none() : Limit::perHour(1)->by($job->user->id);});}

// либо
  return Limit::perMinute(50)->by($job->user->id);

// применить ограничение
use Illuminate\Queue\Middleware\RateLimited;
public function middleware(): array {
  return [new RateLimited('backups')];}

// чтобы задание не возвращалось в очередь
public function middleware(): array {
  return [(new RateLimited('backups'))->dontRelease()];}

// предотвращение дублирования задания
use Illuminate\Queue\Middleware\WithoutOverlapping;
public function middleware(): array {
  return [new WithoutOverlapping($this->user->id)];}

// время до повторной попытки выполнения возвращенного в очередь задания
public function middleware(): array {
  return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];}

// удалить все дублирующиеся задания
public function middleware(): array {
  return [(new WithoutOverlapping($this->order->id))->dontRelease()];}

// определить время истечения блокировки
public function middleware(): array {
  return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];}

// применять ключ блокировки ко всем классам заданий
use Illuminate\Queue\Middleware\WithoutOverlapping;
class ProviderIsDown {
  public function middleware(): array {
    return [(new WithoutOverlapping("status:{$this->provider}"))->shared()];}}
class ProviderIsUp {
  public function middleware(): array {
    return [(new WithoutOverlapping("status:{$this->provider}"))->shared()];}}
</code></pre>
        <p>ограничение частоты генерации исключений</p>
        <pre><code>// после вызова указанного количества исключений выполнение задания на время откладывается
use DateTime;
use Illuminate\Queue\Middleware\ThrottlesExceptions;

// после 10 исключений подряд, прервать выполнение на 5 минут
public function middleware(): array {
  return [new ThrottlesExceptions(10, 5 * 60)];}

// пытаться выполнить задание в течении 30 минут
public function retryUntil(): DateTime {
  return now()->addMinutes(30);}

// после каждого исключения повторить попытку выполнить задание через 5 минут
public function middleware(): array {
  return [(new ThrottlesExceptions(10, 5 * 60))->backoff(5)];}

// по умолчанию имя класса задания - это ключ кеша, переопределить ключ кеша
use Illuminate\Queue\Middleware\ThrottlesExceptions;
public function middleware(): array {
  return [(new ThrottlesExceptions(10, 10 * 60))->by('key')];}

// применить посредника по условию
use Illuminate\Http\Client\HttpClientException;
use Illuminate\Queue\Middleware\ThrottlesExceptions;
public function middleware(): array {
  return [(new ThrottlesExceptions(10, 10 * 60))->when(
    fn (Throwable $throwable) => $throwable instanceof HttpClientException)];}

// либо
use Illuminate\Http\Client\HttpClientException;
use Illuminate\Queue\Middleware\ThrottlesExceptions;
public function middleware(): array {
  return [(new ThrottlesExceptions(10, 10 * 60))->report(
    fn (Throwable $throwable) => $throwable instanceof HttpClientException)];}

более эффективно управление ограничениями исключений с помощью Redis - класс Illuminate\Queue\Middleware\ThrottlesExceptionsWithRedis
</code></pre>
        <p>задание</p>
        <pre><code>// метод handle, который вызывается, когда задание обрабатывается очередью
namespace App\Jobs;
use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;

class ProcessPodcast implements ShouldQueue {
  use Queueable;

  // создать новый экземпляр задания
  public function __construct(public Podcast $podcast) { }

  // Выполнить задание
  public function handle(AudioProcessor $processor): void { }
}
</code></pre>
        <p>отношения в очереди</p>
        <pre><code>// предотвратить сериализацию отношений
public function __construct(Podcast $podcast) {
  $this->podcast = $podcast->withoutRelations();}

// либо
use Illuminate\Queue\Attributes\WithoutRelations;

public function __construct(
  # [WithoutRelations]
  public Podcast $podcast) {}</code></pre>
        <ul>
          <li>для уникальных заданий требуется драйвер кеша, поддерживающий блокировки</li>
          <li>уникальность заданий не учитывается при пакетной обработке</li>
          <li>интерфейс ShouldBeUnique гарантирует, что только один экземпляр задания находится в очереди</li>
        </ul>
        <pre><code>use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique { }

// определить идентификатор или время уникальности задания
use App\Models\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;
class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique {

  // экземпляр продукта
  public $product;

  // количество секунд, по истечении которых уникальная блокировка задания будет снята
  public $uniqueFor = 3600;

  public function uniqueId(): string {

    // получить уникальный идентификатор продукта, задания с тем же идентификатором продукта будут игнорироваться
    return $this->product->id;
  }
}

// разблокировать уникальное задание перед его обработкой
use App\Models\Product;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUniqueUntilProcessing;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUniqueUntilProcessing { }

// использовать другой драйвер для получения блокировки уникального задания
use Illuminate\Contracts\Cache\Repository;
use Illuminate\Support\Facades\Cache;

class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique {
  public function uniqueVia(): Repository {
    return Cache::driver('redis');}}
</code></pre>
        <p>шифрование данных задания</p>
        <pre><code>use Illuminate\Contracts\Queue\ShouldBeEncrypted;
use Illuminate\Contracts\Queue\ShouldQueue;

class UpdateSearchIndex implements ShouldQueue, ShouldBeEncrypted { }

</code></pre>
        <p>пропуск заданий</p>
        <pre><code>// Skip::when удаляет задание, если условие  true, а Skip::unless если условие false
use Illuminate\Queue\Middleware\Skip;
public function middleware(): array {
  return [Skip::when($someCondition)];}

// либо
use Illuminate\Queue\Middleware\Skip;
public function middleware(): array {
  return [Skip::when(function (): bool {
    return $this->shouldSkip();})];}
</code></pre>
        <p>отправка заданий</p>
        <pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatch($podcast);
    return redirect('/podcasts');}}

// отправить задание по условию
ProcessPodcast::dispatchIf($accountActive, $podcast);
ProcessPodcast::dispatchUnless($accountSuspended, $podcast);

// отложенная отправка - задание будет доступно для обработки через 10 минут после его отправки
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatch($podcast)->delay(now()->addMinutes(10));
    return redirect('/podcasts');}}

// отправить задание на немедленную обработку
ProcessPodcast::dispatch($podcast)->withoutDelay();

// отправка задания после отправки ответа в браузер
use App\Jobs\SendNotification;
SendNotification::dispatchAfterResponse();

// либо
use App\Mail\WelcomeMessage;
use Illuminate\Support\Facades\Mail;
dispatch(function () {Mail::to('taylor@example.com')->send(new WelcomeMessage);})->afterResponse();

// синхронная отправка: задание не будет поставлено в очередь, а выполнено немедленно в текущем процессе
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatchSync($podcast);
    return redirect('/podcasts');}}
</code></pre>
        <p>задания и транзакции базы данных</p>
        <pre><code>// Laravel отправит задание после завершения родительской транзакции БД: в config/database.php
'redis' => ['driver' => 'redis', 'after_commit' => true]

// либо
use App\Jobs\ProcessPodcast;
ProcessPodcast::dispatch($podcast)->afterCommit();

// отправить задание не дожидаясь завершения транзакций БД: при 'after_commit' => true в config/database.php
ProcessPodcast::dispatch($podcast)->beforeCommit();
</code></pre>
        <p>цепочка заданий - список заданий в очереди, которые должны выполняться друг за другом после успешного выполнения основного задания</p>
        <pre><code>// Bus - компонент нижнего уровня, на котором построена диспетчеризация заданий в очереди
use App\Jobs\OptimizePodcast;
use App\Jobs\ProcessPodcast;
use App\Jobs\ReleasePodcast;
use Illuminate\Support\Facades\Bus;
Bus::chain([new ProcessPodcast, new OptimizePodcast, new ReleasePodcast])->dispatch();

// либо
Bus::chain([new ProcessPodcast, new OptimizePodcast, function () {Podcast::update( ... );}])->dispatch();

// соединения и очередь цепочки заданий
Bus::chain([new ProcessPodcast, new OptimizePodcast, new ReleasePodcast])
  ->onConnection('redis')->onQueue('podcasts')->dispatch();

// добавить задание в существующую цепочку
public function handle(): void {
  $this->prependToChain(new TranscribePodcast);
  $this->appendToChain(new TranscribePodcast);}

// указать функцию, которая вызывается, если задание в цепочке провалилось
use Illuminate\Support\Facades\Bus;
use Throwable;
Bus::chain([new ProcessPodcast, new OptimizePodcast, new ReleasePodcast])
  ->catch(function (Throwable $e) { })->dispatch();
</code></pre>
        <p>настройка соединения и очереди</p>
        <pre><code>// отправка заданий в разные очереди, позволяет группировать задания и определять приоритеты, назначать разные обработчики в разные очереди.
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatch($podcast)->onQueue('processing');
    return redirect('/podcasts');}}

// либо
namespace App\Jobs;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;

class ProcessPodcast implements ShouldQueue {
  use Queueable;
  public function __construct() {$this->onQueue('processing');}}

// указать, на какое соединение отправить задание
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Jobs\ProcessPodcast;
use App\Models\Podcast;
use Illuminate\Http\RedirectResponse, Illuminate\Http\Request;

class PodcastController extends Controller {
  public function store(Request $request): RedirectResponse {
    $podcast = Podcast::create(/* ... */);
    ProcessPodcast::dispatch($podcast)->onConnection('sqs');
    return redirect('/podcasts');}}

// либо
ProcessPodcast::dispatch($podcast)->onConnection('sqs')->onQueue('processing');

// либо в задании
namespace App\Jobs;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;

class ProcessPodcast implements ShouldQueue {
  use Queueable;
  public function __construct() {$this->onConnection('sqs');}}
</code></pre>
        <p>максимальное количество попыток</p>
        <pre><code>// применяется ко всем заданиям обработчика, --tries=0 - задание будет повторяться бесконечно
php artisan queue:work --tries=3

// указанное количество попыток в классе задания имеет приоритет над значением --tries
namespace App\Jobs;
class ProcessPodcast implements ShouldQueue {public $tries = 5;}

// управлять динамически числом попыток выполнения задания из класса задания
public function tries(): int {return 5;}
</code></pre>
        <p>максимальное время для попыток выполнения задания, для таймаута необходимо расширение pcntl, а значение таймаута в задании всегда меньше "retry after"</p>
        <pre><code>// максимальное количество секунд для выполнения задания
php artisan queue:work --timeout=30

// таймаут указанный в классе задания имеет приоритет над значением --timeout
namespace App\Jobs;
class ProcessPodcast implements ShouldQueue {public $timeout = 120;}

// пометить задание как failed по истечении таймаута
public $failOnTimeout = true;

// либо через DateTime
use DateTime;
public function retryUntil(): DateTime {return now()->addMinutes(10);}
</code></pre>
        <p>максимальное количество исключений</p>
        <pre><code>namespace App\Jobs;
use Illuminate\Support\Facades\Redis;

class ProcessPodcast implements ShouldQueue {

  // 25 попыток выполнения с интервалом в 10 секунд
  public $tries = 25;

  // до трёх необработанных исключений
  public $maxExceptions = 3;
  public function handle(): void {
    Redis::throttle('key')->allow(10)->every(60)->then(
      function () {
        // Блокировка получена, обрабатываем подкаст
      },
      function () {
        // Невозможно получить блокировку
        return $this->release(10);
      });}}
</code></pre>
        <p>обработка ошибок</p>
        <pre><code>// вернуть задание в очередь вручную
public function handle(): void {$this->release();}

// обработать задание через указанное количество секунд
$this->release(10);
$this->release(now()->addSeconds(10));

// пометить задание как «неудачное» вручную
public function handle(): void {$this->fail();}

// передать исключение
$this->fail($exception);

// передать строковое сообщение об ошибке
$this->fail('Something went wrong.');
</code></pre>
        <p>анонимные очереди</p>
        <pre><code>// вместо задания в очередь можно отправить функцию для быстрых и простых задач вне текущего цикла запроса
$podcast = App\Podcast::find(1);
dispatch(function () use ($podcast) {$podcast->publish();});

// catch определяет функцию для обработки неудачного завершения анонимной очереди
use Throwable;
dispatch(function () use ($podcast) {$podcast->publish();})->catch(function (Throwable $e) { });
</code></pre>
        <p>пакетная обработка заданий позволяет совершить действия после выполнения пакета заданий</p>
        <pre><code>// построить таблицу с метаинформацией о пакетах заданий
php artisan make:queue-batches-table
php artisan migrate

// определить задание с возможностью пакетной передачи
namespace App\Jobs;

// обеспечивает доступ к методу batch
use Illuminate\Bus\Batchable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;

class ImportCsv implements ShouldQueue {
  use Batchable, Queueable;
  
  // batch используется для получения текущего пакета, в котором выполняется задание
  public function handle(): void {

    // был ли пакет отменен
    if ($this->batch()->cancelled()) {return;}
    // выполняю задание
  }
}

// отправить в очередь пакет заданий
use App\Jobs\ProcessPodcast;
use Illuminate\Support\Facades\Bus;
Bus::batch([
  new ProcessPodcast($podcast),
  new ProcessPodcast($podcast2),
  new ProcessPodcast($podcast3),
])->dispatch();

// отправить в очередь пакет заданий, каждое из которых обрабатывает часть строк из файла CSV
use App\Jobs\ImportCsv;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;
use Throwable;
$batch = Bus::batch([
  new ImportCsv(1, 100),
  new ImportCsv(101, 200),
  new ImportCsv(201, 300),
  new ImportCsv(301, 400),
  new ImportCsv(401, 500),

// Пакет заданий создан, но не добавлено ни одно задание
])->before(function (Batch $batch) {

// Одна задача успешно завершена
})->progress(function (Batch $batch) {

// Все задания успешно завершены
})->then(function (Batch $batch) {

// Обнаружено первое проваленное задание из пакета
})->catch(function (Batch $batch, Throwable $e) {

// Завершено выполнение пакета
})->finally(function (Batch $batch) {
})->dispatch();
return $batch->id;

// получить доступ к идентификатору пакета
$batch->id

// присвоить пакету произвольное имя
$batch = Bus::batch([...])->then(function (Batch $batch) {...})->name('Import CSV')->dispatch();

// указать соединение и очередь, все пакетные задания выполняются в одном соединении и в одной очереди
$batch = Bus::batch([...])->then(function (Batch $batch) {...})->onConnection('redis')->onQueue('imports')->dispatch();

// определить набор связанных заданий в пакете
use App\Jobs\ReleasePodcast;
use App\Jobs\SendPodcastReleaseNotification;
use Illuminate\Bus\Batch;
use Illuminate\Support\Facades\Bus;

// выполнить две цепочки заданий параллельно и после выполнить замыкание
Bus::batch([
  [new ReleasePodcast(1), new SendPodcastReleaseNotification(1)],
  [new ReleasePodcast(2), new SendPodcastReleaseNotification(2)]])
  ->then(function (Batch $batch) {...})->dispatch();

// объединить пакеты в цепочку
use App\Jobs\FlushPodcastCache;
use App\Jobs\ReleasePodcast;
use App\Jobs\SendPodcastReleaseNotification;
use Illuminate\Support\Facades\Bus;

Bus::chain([
  new FlushPodcastCache,
  Bus::batch([new ReleasePodcast(1), new ReleasePodcast(2)]),
  Bus::batch([new SendPodcastReleaseNotification(1), new SendPodcastReleaseNotification(2)])])->dispatch();

// добавлять задания в пакет можно только из задания, которое принадлежит к тому же пакету
$batch = Bus::batch([
  new LoadImportBatch,
  new LoadImportBatch,
  new LoadImportBatch,
])->then(function (Batch $batch) {...})->name('Import Contacts')->dispatch();

// add метод экземпляра пакета, к которому можно получить доступ через метод batch задания
use App\Jobs\ImportContacts;
use Illuminate\Support\Collection;

public function handle(): void {
  if ($this->batch()->cancelled()) {return;}
  $this->batch()->add(Collection::times(1000, function () {return new ImportContacts;}));}</code></pre>
        <table>
          <caption>экземпляр Illuminate\Bus\Batch передается замыканиям по завершению пакета и предоставляет:</caption>
          <tbody>
            <tr>
              <td>$batch->id;</td>
              <td>UUID пакета</td>
            </tr>
            <tr>
              <td>$batch->name;</td>
              <td>Название пакета (если применимо)</td>
            </tr>
            <tr>
              <td>$batch->totalJobs;</td>
              <td>Количество заданий, назначенных пакету</td>
            </tr>
            <tr>
              <td>$batch->pendingJobs;</td>
              <td>Количество заданий, которые не были обработаны очередью</td>
            </tr>
            <tr>
              <td>$batch->failedJobs;</td>
              <td>Количество неудачных заданий</td>
            </tr>
            <tr>
              <td>$batch->processedJobs();</td>
              <td>Количество заданий, обработанных на данный момент</td>
            </tr>
            <tr>
              <td>$batch->progress();</td>
              <td>Процент завершения пакетной обработки (0-100)</td>
            </tr>
            <tr>
              <td>$batch->finished();</td>
              <td>Указывает, завершено ли выполнение пакета</td>
            </tr>
            <tr>
              <td>$batch->cancel();</td>
              <td>Отменить выполнение пакета</td>
            </tr>
            <tr>
              <td>$batch->cancelled();</td>
              <td>Указывает, был ли пакет отменен</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// возврат пакетов заданий из маршрутов
use Illuminate\Support\Facades\Bus, Illuminate\Support\Facades\Route;
Route::get('/batch/{batchId}', function (string $batchId) {return Bus::findBatch($batchId);});

// отменить выполнение пакета
public function handle(): void {
  if ($this->user->exceedsImportLimit()) {return $this->batch()->cancel();}

  // был ли соответствующий пакет отменен
  if ($this->batch()->cancelled()) {return;}}

// определять был ли соответствующий пакет отменен в посреднике
use Illuminate\Queue\Middleware\SkipIfBatchCancelled;
public function middleware(): array {return [new SkipIfBatchCancelled];}

// разрешить невыполнение задания в пакете
$batch = Bus::batch([...])->then(function (Batch $batch) {...})->allowFailures()->dispatch();

// повторить все неудачные задания для пакета с UUID 32dbc76c-4f82-4749-b610-a639fe0099b5
php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5

// запланировать очистку таблицы job_batches от записей о пакетах
use Illuminate\Support\Facades\Schedule;
Schedule::command('queue:prune-batches')->daily();

// либо очищать каждые 48 часов
Schedule::command('queue:prune-batches --hours=48')->daily();

// либо очистить записи о невыполненных и незавершённых пакетах
Schedule::command('queue:prune-batches --hours=48 --unfinished=72')->daily();

// либо очистить записи об отмененных пакетах
Schedule::command('queue:prune-batches --hours=48 --cancelled=72')->daily();
</code></pre>
        <table>
          <caption>обработчики очереди – это долгоживущие процессы, которые хранят состояние загруженного приложения в памяти.</caption>
          <tbody>
            <tr>
              <td>php artisan queue:work</td>
              <td>запускает обработчика очереди и обрабатывает новые задания пока не остановят</td>
            </tr>
            <tr>
              <td>php artisan queue:work -v</td>
              <td>выводить идентификаторы обработанных заданий</td>
            </tr>
            <tr>
              <td>php artisan queue:listen</td>
              <td>менее эффективна, чем queue:work, но учитывает обновленный код и состояние приложения</td>
            </tr>
            <tr>
              <td>php artisan queue:work redis</td>
              <td>указать обработчику соединение (одно из config/queue.php)</td>
            </tr>
            <tr>
              <td>php artisan queue:work redis --queue=emails</td>
              <td>обрабатывать только очередь emails из соединения redis</td>
            </tr>
            <tr>
              <td>php artisan queue:work --once</td>
              <td>обработать только одно задание из очереди</td>
            </tr>
            <tr>
              <td>php artisan queue:work --max-jobs=1000</td>
              <td>обработать 1000 заданий и выйти</td>
            </tr>
            <tr>
              <td>php artisan queue:work --stop-when-empty</td>
              <td>обработать все задания и затем корректно завершить работу</td>
            </tr>
            <tr>
              <td>php artisan queue:work --max-time=3600</td>
              <td>обрабатывать задания в течение заданных секунд и выйти</td>
            </tr>
            <tr>
              <td>php artisan queue:work --sleep=3</td>
              <td>сколько секунд обработчик будет «спать», если нет заданий</td>
            </tr>
            <tr>
              <td>php artisan queue:work --force</td>
              <td>обрабатывать задания в очереди, даже если включён режим обслуживания</td>
            </tr>
            <tr>
              <td>dispatch((new Job)->onQueue('high'));</td>
              <td>поместить задание в очередь с «высоким» (high) приоритетом</td>
            </tr>
            <tr>
              <td>php artisan queue:work --queue=high,low</td>
              <td>задания очереди high будут обработаны, прежде чем в очереди low</td>
            </tr>
            <tr>
              <td>php artisan queue:restart</td>
              <td>перезапустить всех обработчиков, нужен диспетчер процессов Supervisor для запуска</td>
            </tr>
          </tbody>
        </table>
        <p>сроки и таймауты задания: параметр retry_after в config/queue.php указывает сколько секунд ждать до повторной попытки выполнения задания</p>
        <pre><code>// количество секунд на обработку задания, --timeout всегда должно быть меньше, чем значение retry_after
php artisan queue:work --timeout=60
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-jobs=1000
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-time=3600
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-failures=5
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-batches=10
php artisan queue:work --queue=emails --tries=3 --timeout=90 --sleep=3 --max-batch-size=1000
</code></pre>
        <p>supervisor - диспетчер процессов: запускать одновременно и перезапускает процессы queue:work</p>
        <pre><code>// установить Supervisor
sudo apt-get install supervisor

// создать файл конфигурации laravel-worker.conf в /etc/supervisor/conf.d для запуска и отслеживания queue:work

[program:laravel-worker]
process_name=%(program_name)s_%(process_num)02d

// подключить соединение
command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=forge

// запустить и отслеживать 8 процессов queue:work
numprocs=8
redirect_stderr=true
stdout_logfile=/home/forge/app.com/worker.log

// должно быть большего самого продолжительного задания
stopwaitsecs=3600

// обновить конфигурацию Supervisor и запустить процессы
sudo supervisorctl reread
sudo supervisorctl update
sudo supervisorctl start "laravel-worker:*"
</code></pre>
        <p>неудачные задания</p>
        <ul>
          <li>неудачное асинхронное задание будет помещено в таблицу БД failed_jobs</li>
          <li>исключения синхронного задания обрабатываются немедленно</li>
          <li>таблица БД failed_jobs создаётся по умолчанию</li>
        </ul>
        <table>
          <caption>создать таблицу БД failed_jobs вручную</caption>
          <tbody>
            <tr>
              <td>php artisan make:queue-failed-table</td>
              <td></td>
            </tr>
            <tr>
              <td>php artisan migrate</td>
              <td></td>
            </tr>
            <tr>
              <td>php artisan queue:failed</td>
              <td>просмотреть таблицу БД failed_jobs</td>
            </tr>
            <tr>
              <td>php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece</td>
              <td>повторить неудачное задание с идентификатором ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece</td>
            </tr>
            <tr>
              <td>php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c-34f94a33c24d</td>
              <td>либо повторить два</td>
            </tr>
            <tr>
              <td>php artisan queue:retry --queue=name</td>
              <td>повторить все из очереди name</td>
            </tr>
            <tr>
              <td>php artisan queue:retry all</td>
              <td>повторить все</td>
            </tr>
            <tr>
              <td>php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d</td>
              <td>удалить неудачное задание</td>
            </tr>
            <tr>
              <td>php artisan queue:flush</td>
              <td>удалить все неудачные задания из таблицы failed_jobs</td>
            </tr>
            <tr>
              <td>php artisan queue:prune-failed</td>
              <td>удалить все записи в таблице failed_jobs</td>
            </tr>
            <tr>
              <td>php artisan queue:prune-failed --hours=48</td>
              <td>удалить записи старше 48 часов в таблице failed_jobs</td>
            </tr>
            <tr>
              <td>php artisan queue:work redis --tries=3</td>
              <td>максимальное количество попыток выполнения задания</td>
            </tr>
            <tr>
              <td>php artisan queue:work redis --tries=3 --backoff=3</td>
              <td>сколько секунд ждать перед повторной попыткой</td>
            </tr>
            <tr>
              <td>public $backoff = 3;</td>
              <td>в классе задания в виде переменной</td>
            </tr>
            <tr>
              <td>public function backoff(): int {return 3;}</td>
              <td>либо в классе задания в виде функции</td>
            </tr>
            <tr>
              <td>public function backoff(): array {return [1, 5, 10];}</td>
              <td>либо повторная попытка для первой попытки через 1 секунду, для второй через 5, для третьей и последующих через 10</td>
            </tr>
          </tbody>
        </table>
        <p>отправить предупреждение о сбое и отменить действия частично выполненые заданием</p>
        <pre><code>namespace App\Jobs;
use App\Models\Podcast;
use App\Services\AudioProcessor;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Queue\Queueable;
use Throwable;

class ProcessPodcast implements ShouldQueue {
  use Queueable;

  // создать новый экземпляр задания
  public function __construct(public Podcast $podcast) { }
  public function handle(AudioProcessor $processor): void { выполнить задание }
  public function failed(?Throwable $exception): void { обработать провал задания }}

// автоматическое удаление заданий с отсутствующими моделями
public $deleteWhenMissingModels = true;

// отбрасывать невыполненные задания без сохранения: установить параметр конфигурации queue.failed.driver
QUEUE_FAILED_DRIVER=null
</code></pre>
        <table>
          <caption>удалить задания из очереди</caption>
          <table>
            <tr>
              <td>php artisan queue:clear</td>
              <td>удалить все задания из соединения и очереди по умолчанию</td>
            </tr>
            <tr>
              <td>php artisan queue:clear redis --queue=emails</td>
              <td>удалить все задания из соединения redis и очереди emails</td>
            </tr>
          </table>
        </table>
        <p>события и слушатели в очереди</p>
        <pre><code>use App\Events\OrderShipped;
use App\Listeners\SendOrderShippedNotification;
Event::listen(OrderShipped::class, SendOrderShippedNotification::class);

// зарегистрировать слушатель событий, который будет вызываться при сбое задания
namespace App\Providers;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobFailed;

class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void {
    Queue::failing(function (JobFailed $event) {
      // $event->connectionName
      // $event->job
      // $event->exception});
    }
  }

// указать функции, которые будут выполняться до или после обработки задания в очереди
namespace App\Providers;
use Illuminate\Support\Facades\Queue;
use Illuminate\Support\ServiceProvider;
use Illuminate\Queue\Events\JobProcessed;
use Illuminate\Queue\Events\JobProcessing;

class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void {
    Queue::before(function (JobProcessing $event) {
      // $event->connectionName
      // $event->job
      // $event->job->payload()
    });
    Queue::after(function (JobProcessed $event) {
      // $event->connectionName
      // $event->job
      // $event->job->payload()
    });
  }
}

// отправить событие если количество заданий в очереди больше заданного
php artisan queue:monitor redis:default,redis:deployments --max=100

// прослушать это событие
use App\Notifications\QueueHasLongWaitTime;
use Illuminate\Queue\Events\QueueBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;

public function boot(): void {
  Event::listen(
    function (QueueBusy $event) {
      Notification::route('mail', 'dev@example.com')->notify(new QueueHasLongWaitTime(
        $event->connection,
        $event->queue,
        $event->size));});}
</code></pre>
        <p>выполнить функцию до того, как обработчик попытается получить задание из очереди</p>
        <pre><code>// откат любых транзакций, оставшихся открытыми из-за ранее неудачного задания
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Queue;
Queue::looping(function () {while (DB::transactionLevel() > 0) {DB::rollBack();}});

</code></pre>
        <p>тестирование</p>
        <pre><code>// предотвратить фактическую отправку заданий очередь
use App\Jobs\AnotherJob;
use App\Jobs\FinalJob;
use App\Jobs\ShipOrder;
use Illuminate\Support\Facades\Queue;
test('orders can be shipped', function () {
  Queue::fake();

  // Assert that no jobs were pushed
  Queue::assertNothingPushed();

  // Assert a job was pushed to a given queue
  Queue::assertPushedOn('queue-name', ShipOrder::class);

  // Assert a job was pushed twice
  Queue::assertPushed(ShipOrder::class, 2);

  // Assert a job was not pushed
  Queue::assertNotPushed(AnotherJob::class);

  // Assert that a Closure was pushed to the queue
  Queue::assertClosurePushed();

  // Assert the total number of jobs that were pushed
  Queue::assertCount(3);
});

// либо
Queue::assertPushed(function (ShipOrder $job) use ($order) {return $job->order->id === $order->id;});

// передать имена классов заданий, которые нужно имитировать
test('orders can be shipped', function () {
  Queue::fake([ShipOrder::class]);

  // Assert a job was pushed twice
  Queue::assertPushed(ShipOrder::class, 2);});

// имитировать все задания, кроме указанных
Queue::fake()->except([ShipOrder::class]);

// протестировать цепочки заданий
use App\Jobs\RecordShipment;
use App\Jobs\ShipOrder;
use App\Jobs\UpdateInventory;
use Illuminate\Support\Facades\Bus;

Bus::fake();
Bus::assertChained([
  ShipOrder::class,
  RecordShipment::class,
  UpdateInventory::class]);

// либо
Bus::assertChained([
  new ShipOrder,
  new RecordShipment,
  new UpdateInventory]);

// подтвердить, что задание было отправлено без цепочки заданий
Bus::assertDispatchedWithoutChain(ShipOrder::class);

// подтвердить, что задание имеет ожидаемую цепочку оставшихся заданий
$job = new ProcessPodcast;
$job->handle();
$job->assertHasChain([
  new TranscribePodcast,
  new OptimizePodcast,
  new ReleasePodcast]);

// подтвердить, что оставшаяся цепочка задания пуста
$job->assertDoesntHaveChain();

// тестирование цепочки пакетов
use App\Jobs\ShipOrder;
use App\Jobs\UpdateInventory;
use Illuminate\Bus\PendingBatch;
use Illuminate\Support\Facades\Bus;

Bus::assertChained([
  new ShipOrder,
  Bus::chainedBatch(function (PendingBatch $batch) {return $batch->jobs->count() === 3;}),
  new UpdateInventory]);

// подтвердить, что пакет заданий был отправлен
use Illuminate\Bus\PendingBatch;
use Illuminate\Support\Facades\Bus;
Bus::fake();
Bus::assertBatched(function (PendingBatch $batch) {
  return $batch->name == 'import-csv' && $batch->jobs->count() === 10;});

// подтвердить, что было отправлено заданное количество пакетов
Bus::assertBatchCount(3);

// подтвердить, что никакие пакеты не были отправлены
Bus::assertNothingBatched();

// протестировать взаимодействие отдельного задания с его базовым пакетом: назначить заданию поддельный пакет
[$job, $batch] = (new ShipOrder)->withFakeBatch();
$job->handle();
$this->assertTrue($batch->cancelled());
$this->assertEmpty($batch->added);

// протестировать взаимодействие задания с очередью
use App\Exceptions\CorruptedAudioException;
use App\Jobs\ProcessPodcast;

// поддельное взаимодействие
$job = (new ProcessPodcast)->withFakeQueueInteractions();
$job->handle();
$job->assertReleased(delay: 30);
$job->assertDeleted();
$job->assertNotDeleted();
$job->assertFailed();
$job->assertFailedWith(CorruptedAudioException::class);
$job->assertNotFailed();
</code></pre>
        <table>
          <caption>обработка заданий в очереди с помощью Horizon</caption>
          <tbody>
            <tr>
              <td>php artisan horizon:forget 91401d2c-0784-4f43-824c-34f94a33c24d</td>
              <td>удаления неудачного задания</td>
            </tr>
            <tr>
              <td>php artisan horizon:clear</td>
              <td>удалить все задания из соединения и очереди по умолчанию</td>
            </tr>
          </tbody>
        </table>
        <h2>Events</h2>
        <ul>
          <li>RequestSending - до отправки запроса, содержит общедоступное свойство $request</li>
          <li>ResponseReceived - после получения ответа, содержит общедоступные свойства $request и $response</li>
          <li>ConnectionFailed - ответ не получен, содержит общедоступное свойство $request</li>
        </ul>
        <table>
          <tbody>
            <tr>
              <td>php artisan make:event PodcastProcessed</td>
              <td>сгенерировать событие</td>
            </tr>
            <tr>
              <td>php artisan make:listener SendPodcastNotification --event=PodcastProcessed</td>
              <td>сгенерировать слушателя</td>
            </tr>
            <tr>
              <td>php artisan event:list</td>
              <td>список всех слушателей</td>
            </tr>
          </tbody>
        </table>
        <p>в bootstrap/app.php - искать слушатели в указанном каталоге</p>
        <pre><code>->withEvents(discover: [__DIR__.'/../app/Domain/Orders/Listeners'])</code></pre>
        <p>регистрация вручную событий и соответствующих им слушателей</p>
        <pre><code>// в AppServiceProvider
namespace App\Providers;
use App\Domain\Orders\Events\PodcastProcessed;
use App\Domain\Orders\Listeners\SendPodcastNotification;
use Illuminate\Support\Facades\Event;
public function boot(): void {Event::listen(PodcastProcessed::class, SendPodcastNotification::class);}

// либо
Event::listen(function (PodcastProcessed $event) { });
</code></pre>
        <p>выполнить слушателя с использованием очереди</p>
        <pre><code>use function Illuminate\Events\queueable;
Event::listen(queueable(function (PodcastProcessed $event) { }));

// детализация выполнения слушателя в очереди
Event::listen(queueable(function (PodcastProcessed $event) { })
  ->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));

// обрабатывать сбои анонимного слушателя в очереди
use Throwable;
Event::listen(queueable(function (PodcastProcessed $event) { })
  // Событие в очереди завершилось неудачно
  ->catch(function (PodcastProcessed $event, Throwable $e) {...}));
  
// перехватывать несколько событий на одном слушателе, $data - массив данных события
Event::listen('event.*', function (string $eventName, array $data) { });
</code></pre>
        <p>регистрация вручную подписчика на события</p>
        <pre><code>use App\Listeners\UserEventSubscriber;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void {Event::subscribe(UserEventSubscriber::class);}}</code></pre>
        <ul>
          <li>события позволяют использовать хуки жизненного цикла модели: retrieved, creating, created, updating, updated, saving, saved, deleting, deleted, trashed, forceDeleting, forceDeleted, restoring, restored и replicating.</li>
          <li>события, заканчивающиеся на -ing, инициируются до сохранения изменений в модели, а события, заканчивающиеся на -ed, инициируются после сохранения изменений в модели.</li>
          <li>события saved, updated, deleting, и deleted при массовом обновлении или удалении не будут инициированы.</li>
        </ul>
        <p>прослушивание событий модели</p>
        <pre><code>namespace App\Models;
use App\Events\UserDeleted;
use App\Events\UserSaved;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable {
  use Notifiable;
  protected $dispatchesEvents = ['saved' => UserSaved::class, 'deleted' => UserDeleted::class];
}

// либо через функции: метод «booted» модели
protected static function booted(): void {static::created(function (User $user) {});}

// выполнить слушателя событий модели в фоновом режиме, используя очередь
use function Illuminate\Events\queueable;
static::created(queueable(function (User $user) {}));
</code></pre>
        <p>наблюдатель, чтобы сгруппировать слушателей в одном классе</p>
        <pre><code>// создать наблюдателя в app/Observers
php artisan make:observer UserObserver --model=User

namespace App\Observers;
use App\Models\User;
class UserObserver
{
  public function created(User $user): void {}        // обработать событие «created»
  public function updated(User $user): void {}        // обработать событие «updated»
  public function deleted(User $user): void {}        // обработать событие «deleted»
  public function restored(User $user): void {}       // обработать событие «restored»
  public function forceDeleted(User $user): void {}   // обработать событие «forceDeleted»
}

// наблюдатель выполнит свои обработчики событий только после фиксирования транзакции БД
use Illuminate\Contracts\Events\ShouldHandleEventsAfterCommit;
class UserObserver implements ShouldHandleEventsAfterCommit
{public function created(User $user): void { }}

// регистрации наблюдателя
use App\Observers\UserObserver;
use Illuminate\Database\Eloquent\Attributes\ObservedBy;
# [ObservedBy([UserObserver::class])]
class User extends Authenticatable {}

// либо в App\Providers\AppServiceProvider
use App\Models\User;
use App\Observers\UserObserver;
public function boot(): void {User::observe(UserObserver::class);}
</code></pre>
        <p>заглушить все события, запускаемые моделью</p>
        <pre><code>$user = User::withoutEvents(function () {
  User::findOrFail(1)->delete();
  return User::find(2);
});
</code></pre>
        <p>операции с моделью, не вызывая никаких событий</p>
        <pre><code>$user = User::findOrFail(1);
$user->name = 'Victoria Faith';
$user->saveQuietly();
$user->deleteQuietly();
$user->forceDeleteQuietly();
$user->restoreQuietly();

namespace App\Events;
use App\Models\Order;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class OrderShipped {
  use Dispatchable, InteractsWithSockets, SerializesModels;
  public function __construct(public Order $order) { }}

// отправить событие (метод dispatch)
namespace App\Http\Controllers;
use App\Events\OrderShipped;
use App\Http\Controllers\Controller;
use App\Models\Order;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;

class OrderShipmentController extends Controller {
  public function store(Request $request): RedirectResponse {
    $order = Order::findOrFail($request->order_id);
    OrderShipped::dispatch($order);
    return redirect('/orders');}}

// отправить событие по условию
OrderShipped::dispatchIf($condition, $order);
OrderShipped::dispatchUnless($condition, $order);

// отправлять событие только после завершения активной транзакции в БД
namespace App\Events;
use App\Models\Order;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Contracts\Events\ShouldDispatchAfterCommit;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class OrderShipped implements ShouldDispatchAfterCommit {
  use Dispatchable, InteractsWithSockets, SerializesModels;
  public function __construct(public Order $order) {}}</code></pre>
        <h2>Listeners</h2>
        <p>Слушатели полезны для выполнения медленной задачи: отправка электронной почты или выполнение HTTP-запроса</p>
        <pre><code>// слушатель одного события
use App\Events\PodcastProcessed;
class SendPodcastNotification {public function handle(PodcastProcessed $event): void { }}

// слушатель двух событий
public function handle(PodcastProcessed|PodcastPublished $event): void { }

// слушатели получают экземпляры событий в методе handle
namespace App\Listeners;
use App\Events\OrderShipped;

class SendShipmentNotification {
  public function __construct() { }

  // Доступ к заказу с помощью `$event->order`
  public function handle(OrderShipped $event): void {...}}

// остановить распространение события среди других слушателей
public function handle(OrderShipped $event): void { return false}}

// интерфейс ShouldQueue: обеспечивает постановку слушателя в очередь
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
class SendShipmentNotification implements ShouldQueue { }

// настроить соединение очереди, имя очереди или время задержки очереди для слушателя событий
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;

class SendShipmentNotification implements ShouldQueue {
  // имя соединения, на которое должно быть отправлено задание
  public $connection = 'sqs';

  // имя очереди, в которую должно быть отправлено задание
  public $queue = 'listeners';

  // время (в секундах) до обработки задания
  public $delay = 60;}

// определить соединение очереди слушателя или имя очереди слушателя во время выполнения или получить имя подключения очереди
public function viaConnection(): string {return 'sqs';}

public function viaQueue(): string {
  // получить имя очереди
  return 'listeners';}

public function withDelay(OrderShipped $event): int {
  // получить количество секунд до того, как задача должна быть выполнена
  return $event->highPriority ? 0 : 60;}

// отправить слушателя в очередь по условию
namespace App\Listeners;
use App\Events\OrderCreated;
use Illuminate\Contracts\Queue\ShouldQueue;

class RewardGiftCard implements ShouldQueue {
  public function handle(OrderCreated $event): void { }
    public function shouldQueue(OrderCreated $event): bool {

    // следует ли ставить слушателя в очередь
    return $event->order->subtotal >= 5000;}}

// получить доступ к методам delete и release базового задания в очереди слушателя
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;

class SendShipmentNotification implements ShouldQueue {
  use InteractsWithQueue;
  public function handle(OrderShipped $event): void {if (true) {$this->release(30);}}}

// указать, что слушатель в очереди должен быть выполнен после завершения всех транзакций в БД
namespace App\Listeners;
use Illuminate\Contracts\Queue\ShouldQueueAfterCommit;
use Illuminate\Queue\InteractsWithQueue;
class SendShipmentNotification implements ShouldQueueAfterCommit {use InteractsWithQueue;}

// обработка невыполненных заданий
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
use Throwable;

class SendShipmentNotification implements ShouldQueue {
  use InteractsWithQueue;
  // обработать событие
  public function handle(OrderShipped $event): void { }

  // обработать провал задания
  public function failed(OrderShipped $event, Throwable $exception): void { }}

// указать, сколько раз и как долго можно пытаться выполнить слушатель
namespace App\Listeners;
use App\Events\OrderShipped;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;

class SendShipmentNotification implements ShouldQueue {
  use InteractsWithQueue;
  // количество попыток слушателя в очереди
  public $tries = 5;}

// время, через которое слушатель должен отключиться
use DateTime;
public function retryUntil(): DateTime {return now()->addMinutes(5);}

// количество секунд ожидания перед повторной попыткой
public $backoff = 3;

// либо
public function backoff(): int {return 3;}

// задержка повтора 1 секунда для первой попытки, 5 секунд для второй, 10 секунд для третьей и каждой последующей попытки
public function backoff(): array {return [1, 5, 10];}
</code></pre>
        <p>
          Подписчики событий – это классы, которые могут подписываться на несколько событий.</br>
          Это позволяет определять несколько обработчиков событий в одном классе.
        </p>
        <pre><code>namespace App\Listeners;
use Illuminate\Auth\Events\Login;
use Illuminate\Auth\Events\Logout;
use Illuminate\Events\Dispatcher;

class UserEventSubscriber {
  // обработать событие входа пользователя в систему
  public function handleUserLogin(Login $event): void {}

  // обработать событие выхода пользователя из системы
  public function handleUserLogout(Logout $event): void {}

  // методу subscribe передан экземпляр диспетчера событий
  public function subscribe(Dispatcher $events): void {

    // зарегистрировать слушателей для подписчика
    $events->listen(Login::class, [UserEventSubscriber::class, 'handleUserLogin']);
    $events->listen(Logout::class, [UserEventSubscriber::class, 'handleUserLogout']);}}

// либо
class UserEventSubscriber {
  public function handleUserLogin(Login $event): void {}
  public function handleUserLogout(Logout $event): void {}
  public function subscribe(Dispatcher $events): array
    {return [Login::class => 'handleUserLogin', Logout::class => 'handleUserLogout'];}}</code></pre>
        <h2>Broadcasting</h2>
        <p>отправка событий от сервера к клиенту без обновления страницы</p>
        <ul>
          <li>WebSocket — это независимый протокол, основанный на протоколе TCP.</li>
          <li>Он делает возможным более тесное взаимодействие между браузером и веб-сайтом, способствуя распространению интерактивного содержимого и созданию приложений реального времени.</li>
          <li>Когда некоторые данные обновляются на сервере, тогда обычно отправляется сообщение через соединение WebSocket для обработки клиентом.</li>
          <li>Широковещание используется для отправки события от сервера к клиенту, которое будет получено в JavaScript приложения без обновления страницы.</li>
          <li>Клиенты подключаются к именованным каналам во внешнем интерфейсе, Laravel транслирует события для этих каналов во внутреннем интерфейсе.</li>
          <li>Вся трансляция событий выполняются через задания в очереди.</li>
          <li>Трансляция событий на стороне сервера (конфигурация config/broadcasting.php)</li>
          <li>Драйвера трансляции: Laravel Reverb, Pusher Channels, и Ably</li>
        </ul>
        <p>драйвер log для локальной разработки и отладки, драйвер null - отключить трансляцию во время тестирования</p>
        <pre><code>// включить трансляцию (создаст config/broadcasting.php и routes/channels.php)
php artisan install:broadcasting

// установить Reverb вручную
composer require laravel/reverb
php artisan reverb:install


// установить PHP SDK Pusher Channels
composer require pusher/pusher-php-server
</code></pre>
        <p>настроить учетные данные в config/broadcasting.php</p>
        <pre><code>PUSHER_APP_ID="your-pusher-app-id"
PUSHER_APP_KEY="your-pusher-key"
PUSHER_APP_SECRET="your-pusher-secret"
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME="https"
PUSHER_APP_CLUSTER="mt1"

// в .env
BROADCAST_CONNECTION=pusher

// установить PHP SDK Ably
composer require ably/ably-php
</code></pre>
        <p>настроить учетные данные Ably в config/broadcasting.php</p>
        <pre><code>// в .env
ABLY_KEY=your-ably-key
BROADCAST_CONNECTION=ably
</code></pre>
        <p>Установка на стороне клиента</p>
        <pre><code>// автоматически устанавливает пакеты laravel-echo и pusher-js
php artisan install:broadcasting

// установить пакеты laravel-echo и pusher-js вручную
// echo использует протокол Pusher для подписок, каналов и сообщений
npm install --save-dev laravel-echo pusher-js
</code></pre>
        <p>Reverb</p>
        <pre><code>// в resources/js/bootstrap.js либо в resources/js/echo.js
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
  broadcaster: 'reverb',
  key: import.meta.env.VITE_REVERB_APP_KEY,
  wsHost: import.meta.env.VITE_REVERB_HOST,
  wsPort: import.meta.env.VITE_REVERB_PORT,
  wssPort: import.meta.env.VITE_REVERB_PORT,
  forceTLS: (import.meta.env.VITE_REVERB_SCHEME ?? 'https') === 'https',
  enabledTransports: ['ws', 'wss'],
});
</code></pre>
        <p>Pusher Channels</p>
        <pre><code>// в resources/js/echo.js
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
  broadcaster: 'pusher',
  key: import.meta.env.VITE_PUSHER_APP_KEY,
  cluster: import.meta.env.VITE_PUSHER_APP_CLUSTER,
  forceTLS: true
});

// использовать существующий экземпляр клиента Pusher Channelsimport Echo from 'laravel-echo';
import Pusher from 'pusher-js';
const options = {broadcaster: 'pusher', key: 'your-pusher-channels-key'}
window.Echo = new Echo({...options, client: new Pusher(options.key, options)});

// в .env
PUSHER_APP_ID="your-pusher-app-id"
PUSHER_APP_KEY="your-pusher-key"
PUSHER_APP_SECRET="your-pusher-secret"
PUSHER_HOST=
PUSHER_PORT=443
PUSHER_SCHEME="https"
PUSHER_APP_CLUSTER="mt1"
VITE_APP_NAME="${APP_NAME}"
VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
</code></pre>
        <p>Ably - включить поддержку протокола Pusher в разделе настроек «Protocol Adapter Settings» панели Ably</p>
        <pre><code>// в resources/js/echo.js
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';
window.Pusher = Pusher;
window.Echo = new Echo({
  broadcaster: 'pusher',

  // часть ключа Ably перед символом :
  key: import.meta.env.VITE_ABLY_PUBLIC_KEY,
  wsHost: 'realtime-pusher.ably.io',
  wsPort: 443,
  disableStats: true,
  encrypted: true,
});

// скомпилировать ресурсы
npm run dev
</code></pre>
        <p>Пример: статус доставки заказов в интернет-магазине</p>
        <pre><code>use App\Events\OrderShipmentStatusUpdated;
// событие запускается при обновлении статуса доставки
OrderShipmentStatusUpdated::dispatch($order);
</code></pre>
        <p>ShouldBroadcast: транслировать событие при его запуске</p>
        <pre><code>namespace App\Events;
use App\Models\Order;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class OrderShipmentStatusUpdated implements ShouldBroadcast {public $order;}

// получить каналы трансляции события в классе события
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\PrivateChannel;

// транслировать событие на частном канале, привязанном к конкретному заказу
public function broadcastOn(): Channel {return new PrivateChannel('orders.'.$this->order->id);}

// передать событие по нескольким каналам
use Illuminate\Broadcasting\PrivateChannel;
public function broadcastOn(): array {return [new PrivateChannel('orders.'.$this->order->id)];}
</code></pre>
        <p>определить правила авторизации каналов в файле routes/channels.php</p>
        <pre><code>use App\Models\Order;
use App\Models\User;

// прослушивать канал может только создатель заказа
Broadcast::channel('orders.{orderId}', function (User $user, int $orderId) {
  return $user->id === Order::findOrNew($orderId)->user_id;});

// прослушивать событие: метод private для подписки на частный канал
Echo.private(`orders.${orderId}`).listen('OrderShipmentStatusUpdated', (e) => {console.log(e.order);});
</code></pre>
        <ul>Транслируемые события
          <li>для трансляции события интерфейс ShouldBroadcast и метод broadcastOn</li>
          <li>экземпляры Channel - публичные каналы, на которые может подписаться любой пользователь,</li>
          <li>PrivateChannels и PresenceChannels - частные каналы, для которых требуется авторизация канала</li>
        </ul>
        <pre><code>namespace App\Events;
use App\Models\User;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;

class ServerCreated implements ShouldBroadcast {
  use SerializesModels;
  // создать новый экземпляр события
  public function __construct(public User $user) {}

  // получить каналы трансляции события
  public function broadcastOn(): array {
    return [new PrivateChannel('user.'.$this->user->id)];}}

// после запуска события, задание в очереди автоматически транслирует событие, используя указанный драйвер трансляции: изменить имя транслируемого события (по умолчанию имя класса события)
public function broadcastAs(): string {return 'server.created';}

// слушатель с ведущим символом . чтобы не добавлять пространство имен приложения к событию
.listen('.server.created', function (e) { });
</code></pre>
        <p>при трансляции события, все его публичные свойства автоматически сериализуются</p>
        <pre><code>{
  "user": {
    "id": 1,
    "name": "Patrick Stewart"
  }
}

// получить массив данных в качестве полезной нагрузки при трансляции события
public function broadcastWith(): array {return ['id' => $this->user->id];}

// изменить соединение очереди и имя очереди для транслируемого события
public $connection = 'redis';
public $queue = 'default';

// либо имя очереди трансляции
public function broadcastQueue(): string {return 'default';}

// транслировать событие с помощью очереди sync вместо драйвера очереди по умолчанию
use Illuminate\Contracts\Broadcasting\ShouldBroadcastNow;
class OrderShipmentStatusUpdated implements ShouldBroadcastNow { }

// транслировать событие по условию
public function broadcastWhen(): bool {return $this->order->value > 100;}

// транслируемое событие будет отправлено после фиксации всех транзакций БД
namespace App\Events;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Contracts\Events\ShouldDispatchAfterCommit;
use Illuminate\Queue\SerializesModels;
class ServerCreated implements ShouldBroadcast, ShouldDispatchAfterCommit {use SerializesModels;}
</code></pre>
        <p>для авторизации каналов маршрут /broadcasting/auth автоматически помещается в группу посредников web</p>
        <pre><code>// определить логику может ли текущий аутентифицированный пользователь прослушивать канал в routes/channels.php
use App\Models\User;
Broadcast::channel('orders.{orderId}', function (User $user, int $orderId) {
  return $user->id === Order::findOrNew($orderId)->user_id;});

// просмотреть список замыканий авторизации вещания
php artisan channel:list
</code></pre>
        <p>привязка модели к маршруту канала</p>
        <pre><code>use App\Models\Order;
use App\Models\User;
Broadcast::channel(
  'orders.{order}',
  function (User $user, Order $order) {
    return $user->id === $order->user_id;});

// назначить своих охранников для аутентификации входящего запроса
Broadcast::channel('channel', function () { }, ['guards' => ['web', 'admin']]);
</code></pre>
        <p>вместо использования замыканий для авторизации каналов можно использовать классы каналов</p>
        <pre><code>// сгенерировать новый класс канала в app/Broadcasting
php artisan make:channel OrderChannel   

</code></pre>
        <p>зарегистрировать канал в routes/channels.php</p>
        <pre><code>use App\Broadcasting\OrderChannel;
Broadcast::channel('orders.{order}', OrderChannel::class);

// логику авторизации для канала в методе join
namespace App\Broadcasting;
use App\Models\Order, App\Models\User;
class OrderChannel {
  public function __construct() { }
  public function join(User $user, Order $order): array|bool {return $user->id === $order->user_id;}}
</code></pre>
        <p>запустить трансляцию события</p>
        <pre><code>use App\Events\OrderShipmentStatusUpdated;
OrderShipmentStatusUpdated::dispatch($order);

// трансляция события всем подписчикам канала, кроме текущего пользователя
use App\Events\OrderShipmentStatusUpdated;
broadcast(new OrderShipmentStatusUpdated($update))->toOthers();

// для toOthers() глобальный экземпляр Axios прикрепляет идентификатор сокета к каждому исходящему запросу в заголовке X-Socket-ID, получить идентификатор сокета
var socketId = Echo.socketId();

// указать, на какое соединение отправлять событие
use App\Events\OrderShipmentStatusUpdated;
broadcast(new OrderShipmentStatusUpdated($update))->via('pusher');

// либо указать широковещательное соединение события в конструкторе события
namespace App\Events;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithBroadcasting;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Queue\SerializesModels;
class OrderShipmentStatusUpdated implements ShouldBroadcast {
  use InteractsWithBroadcasting;
  public function __construct() {$this->broadcastVia('pusher');}}
</code></pre>
        <p>анонимные события</p>
        <pre><code>// транслировать простое событие без создания специального класса событий
Broadcast::on('orders.'.$order->id)->send();

  // будет транслироваться
{
  "event": "AnonymousEvent",
  "data": "[]",
  "channel": "orders.1"
}

// настроить имя и данные события
Broadcast::on('orders.'.$order->id)->as('OrderPlaced')->with($order)->send();

  // будет транслироваться
{
  "event": "OrderPlaced",
  "data": "{ id: 1, total: 100 }",
  "channel": "orders.1"
}

// транслировать анонимное событие на частном канале или канале присутствия
Broadcast::private('orders.'.$order->id)->send();
Broadcast::presence('channels.'.$channel->id)->send();

// немедленно транслировать событие без постановки в очередь
Broadcast::on('orders.'.$order->id)->sendNow();

// транслировать событие всем подписчикам канала, кроме текущего аутентифицированного пользователя
Broadcast::on('orders.'.$order->id)->toOthers()->send();
</code></pre>
        <p>Приём трансляций: прослушивание событий</p>
        <pre><code>// метод channel для получения экземпляра канала, метод listen для прослушивания события
Echo.channel(`orders.${this.order.id}`).listen('OrderShipmentStatusUpdated', (e) => {console.log(e.order.name);});

// прослушивать несколько событий на частном канале
Echo.private(`orders.${this.order.id}`).listen(/* ... */).listen(/* ... */).listen(/* ... */);

// прекратить прослушивание данного события не покидая канал
Echo.private(`orders.${this.order.id}`).stopListening('OrderShipmentStatusUpdated')

// покинуть канал, а также связанные с ним частные каналы и каналы присутствия
Echo.leave(`orders.${this.order.id}`);

// Echo автоматически предполагает, что события находятся в пространстве имен App\Events
// изменить пространство имен при создании экземпляра Echo
window.Echo = new Echo({broadcaster: 'pusher', namespace: 'App.Other.Namespace'});

// префикс . позволяет указывать полное имя класса
Echo.channel('orders').listen('.Namespace\\Event\\Class', (e) => { });
</code></pre>
        <p>Каналы присутствия основаны на безопасности частных каналов и позволяют уведомление пользователей, когда другой пользователь просматривает ту же страницу, или перечисление пользователей комнаты чата.</p>
        <pre><code>// авторизация каналов присутствия: если пользователь авторизован для присоединения к каналу, то вернуть массив данных о пользователе, если не авторизован, то вернуть false или null
use App\Models\User;
Broadcast::channel('chat.{roomId}', function (User $user, int $roomId) {
  if ($user->canJoinRoom($roomId)) {return ['id' => $user->id, 'name' => $user->name];}});

// присоединиться к каналу присутствия: метод join вернет реализацию PresenceChannel, с методом listen, чтобы подписаться на события here, joining и leave
Echo.join(`chat.${roomId}`).here((users) => { }).joining((user) => {console.log(user.name);})
  .leaving((user) => {console.log(user.name);}).error((error) => {console.error(error);});

// трансляция на каналы присутствия: получить канал трансляции события
public function broadcastOn(): array {return [new PresenceChannel('chat.'.$this->message->room_id)];}

// отправить событие
broadcast(new NewMessage($message));

// либо
broadcast(new NewMessage($message))->toOthers();

// прослушивать события
Echo.join(`chat.${roomId}`).here(/* ... */).joining(/* ... */).leaving(/* ... */).listen('NewMessage', (e) => { });
</code></pre>
        <p>Трансляция моделей: обычно транслируются события, когда модели Eloquent создаются, обновляются или удаляются, чтобы не создавать классы событий с единственной целью их широковещательной передачи, модель Eloquent может автоматически транслировать изменения своего состояния</p>
        <pre><code>namespace App\Models;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Database\Eloquent\BroadcastsEvents;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
class Post extends Model {
  use BroadcastsEvents, HasFactory;

  // получить пользователя, которому принадлежит сообщение
  public function user(): BelongsTo {return $this->belongsTo(User::class);}

  // получить каналы, по которым должны транслироваться события модели
  // аргумент $event - тип события, которое произошло: created, updated, deleted, trashed или restored
  public function broadcastOn(string $event): array {return [$this, $this->user];}}

// определить, на какие каналы (если есть) модель должна транслировать конкретное событие
public function broadcastOn(string $event): array {
  return match ($event) {'deleted' => [], default => [$this, $this->user]};}

// настроить создание базового события трансляции модели
use Illuminate\Database\Eloquent\BroadcastableModelEventOccurred;
protected function newBroadcastableEvent(string $event): BroadcastableModelEventOccurred {
  return (new BroadcastableModelEventOccurred($this, $event))->dontBroadcastToCurrentUser();}
</code></pre>
        <ul>соглашение о трансляции моделей
          <li>Laravel автоматически создаст экземпляр частного канала для модели, используя имя класса модели и идентификатор первичного ключа для названия канала: App\Models\User с id равным 1, вернёт экземпляр Illuminate\Broadcasting\PrivateChannel с именем App.Models.User.1</li>
          <li>либо вручную для модели App\Models\User с id равным 1 метод $user->broadcastChannel() вернёт App.Models.User.1</li>
        </ul>
        <pre><code>// либо возвращать полные экземпляры Channel для трансляции события модели вручную
use Illuminate\Broadcasting\PrivateChannel;
public function broadcastOn(string $event): array {return [new PrivateChannel('user.'.$this->id)];}

// передать экземпляр модели Eloquent в конструктор канала
return [new Channel($this->user)];
</code></pre>
        <p>соглашение о событиях</p>
        <pre><code>// обновление модели App\Models\Post будет транслировать событие PostUpdated с полезной нагрузкой
{
  "model": {"id": 1, "title": "Мой первый пост"},
  "socket": "someSocketId",
}

// определить собственное имя трансляции и полезную нагрузку
public function broadcastAs(string $event): string|null {
  return match ($event) {'created' => 'post.created', default => null};}
public function broadcastWith(string $event): array {
  return match ($event) {'created' => ['title' => $this->title], default => ['model' => $this]};}
</code></pre>
        <ul>прослушивание трансляций моделей
          <li>имя события должно иметь префикс ., чтобы указать, что оно не принадлежит определенному пространству имен</li>
          <li>метод private для получения экземпляра канала,</li>
          <li>метод listen для прослушивания указанного события,</li>
          <li>свойство model, содержит все транслируемые свойства модели</li>
        </ul>
        <pre><code>Echo.private(`App.Models.User.${this.user.id}`).listen('.PostUpdated', (e) => {console.log(e.model);});</code></pre>
        <p>Клиентские события: транслировать событие другим подключенным клиентам, не затрагивая приложение Laravel</p>
        <pre><code>// предупредить пользователей приложения, что другой пользователь печатает сообщение

//транслировать клиентские события
Echo.private(`chat.${roomId}`).whisper('typing', {name: this.user.name});

// слушать клиентские события
Echo.private(`chat.${roomId}`).listenForWhisper('typing', (e) => {console.log(e.name);});
</code></pre>
        <p>Уведомления: связать трансляцию событий с уведомлениями, чтобы получать новые уведомления без обновления страницы</p>
        <pre><code>// уведомления App\Models\User через канал broadcast получены в замыкании, авторизация канала App.Models.User.{id} включена в файл routes/channels.php
Echo.private(`App.Models.User.${userId}`).notification((notification) => {console.log(notification.type);});</code></pre>
        <h2>Concurrency</h2>
        <p>Одновременное выполнение функций для не зависящих друг от друга задач.</p>
        <ul>
          <li>фасад Concurrency поддерживает три драйвера: process (по умолчанию), fork и sync.</li>
          <li>PHP не поддерживает разветвление во время веб-запросов, поэтому нужен CLI PHP.</li>
          <li>#sync: отключить весь параллелизм и выполнить функции внутри родительского процесса, полезно во время тестирования.</li>
        </ul>
        <pre><code>// запуск параллельных задач
use Illuminate\Support\Facades\Concurrency;
use Illuminate\Support\Facades\DB;
[$userCount, $orderCount] = Concurrency::run([
  fn () => DB::table('users')->count(),
  fn () => DB::table('orders')->count()]);

// указать драйвер
$results = Concurrency::driver('fork')->run(...);

// изменить драйвер по умолчанию, параметр default в config/concurrency.php
php artisan config:publish concurrency

// у fork лучше производительность чем у process
composer require spatie/fork

// отсрочка параллельных задач: выполнять функции одновременно после отправки пользователю HTTP-ответа
use App\Services\Metrics;
use Illuminate\Support\Facades\Concurrency;
Concurrency::defer([
  fn () => Metrics::report('users'),
  fn () => Metrics::report('orders')]);</code></pre>
        <h2>Context</h2>
        <p>
          собирать, извлекать и обмениваться информацией в запросах, заданиях и командах.<br/>
          Информация записывается в журналы с отслеживанием потоков и историей выполнения кода.
        </p>
        <pre><code>// добавить URL-адрес и id трассировки в контекст каждого входящего запроса
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Context;
use Illuminate\Support\Str;
use Symfony\Component\HttpFoundation\Response;
class AddContext {
  public function handle(Request $request, Closure $next): Response {
    Context::add('url', $request->url());
    Context::add('trace_id', Str::uuid()->toString());
    return $next($request);}}

// информация, добавленная в контекст, автоматически добавляется в виде метаданных ко всем записям журнала
Log::info('Пользователь прошел аутентификацию.', ['auth_id' => Auth::id()]);  // записать запись в журнал

// получим запись
Пользователь прошел аутентификацию. {"auth_id":27} {"url":"https://example.com/login","trace_id":"e04e1a11-e75c-4db3-b5b5-cfef4ef56697"}
</code></pre>
        <p>Информация, добавленная в контекст, также становится доступной для заданий, отправленных в очередь</p>
        <pre><code>// в посреднике
Context::add('url', $request->url());
Context::add('trace_id', Str::uuid()->toString());

// в контроллере
ProcessPodcast::dispatch($podcast);

// при отправке задания любая информация, хранящаяся в данный момент в контексте, фиксируется и передается заданию
class ProcessPodcast implements ShouldQueue {
  use Queueable;
  public function handle(): void {Log::info('Обработка подкаста.', ['podcast_id' => $this->podcast->id]);}}

// результирующая запись журнала
Обработка подкаста. {"podcast_id":95} {"url":"https://example.com/login","trace_id":"e04e1a11-e75c-4db3-b5b5-cfef4ef56697"}
</code></pre>
        <p>захват контекста</p>
        <pre><code>// хранить информацию в текущем контексте
use Illuminate\Support\Facades\Context;
Context::add('key', 'value');

// либо
Context::add(['first_key' => 'value', 'second_key' => 'value']);

// add переопределит значение с тем же ключём, addIf добавить информацию в контекст только если ключ еще не существует
Context::add('key', 'first');

// "first"
Context::get('key');
Context::addIf('key', 'second');

// "first"
Context::get('key');

// добавления данных в контекст по условию
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Context;
Context::when(
  Auth::user()->isAdmin(),
  fn ($context) => $context->add('permissions', Auth::user()->permissions),
  fn ($context) => $context->add('permissions', []));

// создать стек: список данных, хранящихся в том порядке, в котором они были добавлены
use Illuminate\Support\Facades\Context;
Context::push('breadcrumbs', 'first_value');
Context::push('breadcrumbs', 'second_value', 'third_value');
Context::get('breadcrumbs');
вернёт
[
  'first_value',
  'second_value',
  'third_value',
]

// создать прослушиватель событий, который помещает в стек инфу о SQL-запросе и его продолжительности при выполнении запроса
use Illuminate\Support\Facades\Context;
use Illuminate\Support\Facades\DB;
DB::listen(function ($event) {Context::push('queries', [$event->time, $event->sql]);});

// находится ли значение в стеке
if (Context::stackContains('breadcrumbs', 'first_value')) { }
if (Context::hiddenStackContains('secrets', 'first_value')) { }

// либо
use Illuminate\Support\Facades\Context;
use Illuminate\Support\Str;
return Context::stackContains('breadcrumbs', function ($value) {return Str::startsWith($value, 'query_');});
</code></pre>
        <p>получение контекста</p>
        <pre><code>// получить информацию из контекста
use Illuminate\Support\Facades\Context;
$value = Context::get('key');

// получить подмножество информации в контексте
$data = Context::only(['first_key', 'second_key']);

// извлечение и удаление информации из контекста
$value = Context::pull('key');

// извлечь элементы из стека
Context::push('breadcrumbs', 'first_value', 'second_value');

// second_value
Context::pop('breadcrumbs');

// ['first_value']
Context::get('breadcrumbs');

// получить всю информацию, хранящуюся в контексте
$data = Context::all();

// имеет ли контекст значение для указанного ключа
use Illuminate\Support\Facades\Context;
if (Context::has('key')) { ... }

// даже при null значение есть
Context::add('key', null);

// true
Context::has('key');
</code></pre>
        <p>удаление контекста</p>
        <pre><code>use Illuminate\Support\Facades\Context;
Context::add(['first_key' => 1, 'second_key' => 2]);
Context::forget('first_key');

// ['second_key' => 2]
Context::all();

// либо забыть несколько ключей одновременно
Context::forget(['first_key', 'second_key']);
</code></pre>
        <p>скрытый контекст не добавляется в журналы</p>
        <pre><code>use Illuminate\Support\Facades\Context;
Context::addHidden('key', 'value');

// 'value'
Context::getHidden('key');

// null
Context::get('key');

// скрытые методы
Context::addHidden(/* ... */);
Context::addHiddenIf(/* ... */);
Context::pushHidden(/* ... */);
Context::getHidden(/* ... */);
Context::pullHidden(/* ... */);
Context::popHidden(/* ... */);
Context::onlyHidden(/* ... */);
Context::allHidden(/* ... */);
Context::hasHidden(/* ... */);
Context::forgetHidden(/* ... */);
</code></pre>
        <p>события контекста: гидратация и обезвоживание</p>
        <pre><code>// зарегистрировать в AppServiceProvider
// когда задание отправляется в очередь, данные в контексте обезвоживаются
use Illuminate\Log\Context\Repository;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\Context;
public function boot(): void {
  Context::dehydrating(function (Repository $context) {$context->addHidden('locale', Config::get('app.locale'));});}

// когда поставленное в очередь задание начинает выполняться, любой контекст задания, будет «гидратирован» в текущий контекст
use Illuminate\Log\Context\Repository;
use Illuminate\Support\Facades\Config;
use Illuminate\Support\Facades\Context;
public function boot(): void {
  Context::hydrated(function (Repository $context) {
    if ($context->hasHidden('locale')) {Config::set('app.locale', $context->getHidden('locale'));}});}</code></pre>
        <h2>Localization</h2>
        <p>мультиязычность интерфейса приложения</p>
        <pre><code>// опубликовать языковые файлы
php artisan lang:publish

// языковые файлы
/lang
  /en
    messages.php
  /es
    messages.php

// либо
/lang
  en.json
  es.json
</code></pre>
        <p>язык по умолчанию в APP_LOCALE .env сохранит в locale  config/app.php, резервный язык APP_FALLBACK_LOCALE .env</p>
        <pre><code>// изменить язык по умолчанию для одного HTTP-запроса во время выполнения
use Illuminate\Support\Facades\App;
Route::get('/greeting/{locale}', function (string $locale) {
  if (! in_array($locale, ['en', 'es', 'fr'])) {abort(400);}
  App::setLocale($locale);});

// определить текущий язык или проверить соответствие указанного языка
use Illuminate\Support\Facades\App;
$locale = App::currentLocale();
if (App::isLocale('en')) { }

// поддержка языком множественного числа: french, norwegian-bokmal, portuguese, spanish и turkish
в App\Providers\AppServiceProvider
use Illuminate\Support\Pluralizer;
public function boot(): void {Pluralizer::useLanguage('spanish');}

// все языковые файлы возвращают массив строк с ключами, lang/en/messages.php
return ['welcome' => 'Welcome to our application!'];
</code></pre>
        <p>для языков, отличающихся территориально языковые каталоги называть «en_GB»</p>
        <pre><code>// файлы перевода, которые используют строки перевода в качестве ключей, lang/es.json
{"I love programming.": "Me encanta programar."}

// получить строки перевода из языковых файлов, lang/en/messages.php
echo __('messages.welcome');

// либо в шаблонизаторе Blade, lang/es.json
{{ __('messages.welcome') }}
echo __('I love programming.');

// заполнитель в строках перевода
'welcome' => 'Welcome, :name',
echo __('messages.welcome', ['name' => 'dayle']);

// Welcome, DAYLE
'welcome' => 'Welcome, :NAME',
// Goodbye, Dayle
'goodbye' => 'Goodbye, :Name',
// автоматически вызывает метод __toString

// если нет контроля над методом __toString, регистрация пользовательского обработчика форматирования 
в AppServiceProvider
use Illuminate\Support\Facades\Lang;
use Money\Money;
public function boot(): void {Lang::stringable(function (Money $money) {return $money->formatTo('en_GB');});}

// различать формы единственного и множественного числа строки
'apples' => 'There is one apple|There are many apples'

// либо
"There is one apple|There are many apples": "Hay una manzana|Hay muchas manzanas"

// либо
'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many'
// извлечения строки соответствующую указанному количеству
echo trans_choice('messages.apples', 10);

// либо
'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago',
echo trans_choice('time.minutes_ago', 5, ['value' => 5]);

// отобразить целочисленное значение
'apples' => '{0} There are none|{1} There is one|[2,*] There are :count'

// переопределить языковые файлы пакеты
lang/vendor/{package}/{locale}

// переопределить строки перевода в messages.php для пакета skyrim/hearthfire: lang/vendor/hearthfire/en/messages.php
  в файле определить только те строки перевода, которые нужно переопределить</code></pre>
        <h2>File Storage</h2>
        <p>обеспечивает абстракцию файловой системы и содержит драйверы для работы с локальными файловыми системами, SFTP и Amazon S3</p>
        <p>local</p>
        <ul>
          <li>драйвер local взаимодействует с файлами на сервере, на котором запущено приложение Laravel</li>
          <li>операции с файлами выполняются относительно корневого каталога storage/app</li>
        </ul>
        <pre><code>use Illuminate\Support\Facades\Storage;
// запишет файл в storage/app/example.txt
Storage::disk('local')->put('example.txt', 'Contents');
</code></pre>
        <p>публичный диск определен в config/filesystems.php по умолчанию использует драйвер local и хранит свои файлы в storage/app/public</p>
        <pre><code>// создать символическую ссылку из storage/app/public на public/storage, для доступа из интернета
php artisan storage:link

// либо настроить дополнительные символические ссылки в config/filesystems.php
'links' => [
  public_path('storage') => storage_path('app/public'),
  public_path('images') => storage_path('app/images')]

// создать URL-адреса для сохраненных файлов
echo asset('storage/file.txt');

// уничтожение настроенных символических ссылок
php artisan storage:unlink
</code></pre>
        <p>Amazon S3: драйвер s3 используется для записи в службу облачного хранилища Amazon S3</p>
        <pre><code>// установить пакет Flysystem S3
composer require league/flysystem-aws-s3-v3 "^3.0" --with-all-dependencies

// настройка конфигурации диска сохраняется в config/filesystems.php через указание в .env
AWS_ACCESS_KEY_ID=< your-key-id>
AWS_SECRET_ACCESS_KEY=< your-secret-access-key>
AWS_DEFAULT_REGION=us-east-1
AWS_BUCKET=< your-bucket-name>
AWS_USE_PATH_STYLE_ENDPOINT=false
</code></pre>
        <p>FTP</p>
        <pre><code>// установить пакет Flysystem FTP
composer require league/flysystem-ftp "^3.0"

// в config/filesystems.php
'ftp' => [
  'driver' => 'ftp',
  'host' => env('FTP_HOST'),
  'username' => env('FTP_USERNAME'),
  'password' => env('FTP_PASSWORD'),
  // Optional FTP Settings...
  // 'port' => env('FTP_PORT', 21),
  // 'root' => env('FTP_ROOT'),
  // 'passive' => true,
  // 'ssl' => true,
  // 'timeout' => 30]
</code></pre>
        <p>SFTP</p>
        <pre><code>// установить пакет Flysystem SFTP
composer require league/flysystem-sftp-v3 "^3.0"

// в config/filesystems.php
'sftp' => [
  'driver' => 'sftp',
  'host' => env('SFTP_HOST'),

  // Settings for basic authentication...
  'username' => env('SFTP_USERNAME'),
  'password' => env('SFTP_PASSWORD'),

  // Settings for SSH key based authentication with encryption password...
  'privateKey' => env('SFTP_PRIVATE_KEY'),
  'passphrase' => env('SFTP_PASSPHRASE'),

  // Settings for file / directory permissions...
  // `private` = 0600, `public` = 0644
  'visibility' => 'private',
  // `private` = 0700, `public` = 0755
  'directory_visibility' => 'private',

  // Optional SFTP Settings...
  // 'hostFingerprint' => env('SFTP_HOST_FINGERPRINT'),
  // 'maxTries' => 4,
  // 'passphrase' => env('SFTP_PASSPHRASE'),
  // 'port' => env('SFTP_PORT', 22),
  // 'root' => env('SFTP_ROOT', ''),
  // 'timeout' => 30,
  // 'useAgent' => true]
</code></pre>
        <p>диски: ограниченные диски определяют файловую систему, в которой все пути автоматически дополняются указанным префиксом пути</p>
        <pre><code>composer require league/flysystem-path-prefixing "^3.0"

// определить диск с драйвером scoped
's3-videos' => [
  'driver' => 'scoped',
  'disk' => 's3',
  'prefix' => 'path/to/videos']

// диски только для чтения создают диски с запретом записи записи
composer require league/flysystem-read-only "^3.0"
's3-videos' => [
  'driver' => 's3',
  'read-only' => true]

// для взаимодействия с совместимой с S3 службой хранения файлов, такой как MinIO или DigitalOcean Spaces
указать AWS_ENDPOINT в .env для изменения настройки в config/filesystems.php
'endpoint' => env('AWS_ENDPOINT', 'https://minio:9000'),
AWS_URL='http://localhost:9000/local'

// доступ к экземплярам дисков
use Illuminate\Support\Facades\Storage;
// использует диск по умолчанию
Storage::put('avatars/1', $content);
// использует указанный диск
Storage::disk('s3')->put('avatars/1', $content);

p создать диск во время выполнения без конфигурации в config/filesystems.php
use Illuminate\Support\Facades\Storage;
$disk = Storage::build(['driver' => 'local', 'root' => '/path/to/root']);
$disk->put('image.jpg', $content);
</code></pre>
        <p>URL-адреса файлов: общедоступные файлы в storage/app/public, создать символическую ссылку в public/storage на storage/app/public</p>
        <table>
          <caption>получение файлов: все пути к файлам должны быть указаны относительно «корня» диска</caption>
          <tbody>
            <tr>
              <td>$contents = Storage::get('file.jpg');</td>
              <td>получить содержимое файла</td>
            </tr>
            <tr>
              <td>$orders = Storage::json('orders.json');</td>
              <td>извлечения и декодирования json</td>
            </tr>
            <tr>
              <td>if (Storage::disk('s3')->exists('file.jpg')) { }</td>
              <td>существует ли файл на диске</td>
            </tr>
            <tr>
              <td>if (Storage::disk('s3')->missing('file.jpg')) { }</td>
              <td>отсутствует ли файл на диске</td>
            </tr>
            <tr>
              <td>return Storage::download('file.jpg');</td>
              <td>скачать файл</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// либо $name - имя файла, которое видит пользователь при скачивании, $headers - массив заголовков
return Storage::download('file.jpg', $name, $headers);

// при драйвере local добавит /storage к указанному пути и вернет относительный URL-адрес файла
use Illuminate\Support\Facades\Storage;
// при драйвере s3 вернет абсолютный внешний URL-адрес
$url = Storage::url('file.jpg');

// изменить хост для URL-адресов
'public' => [
  'driver' => 'local',
  'root' => storage_path('app/public'),
  'url' => env('APP_URL').'/storage',
  'visibility' => 'public',
  'throw' => false]

// создать временные URL-адреса для файлов, хранящихся с помощью драйверов local и s3
use Illuminate\Support\Facades\Storage;
$url = Storage::temporaryUrl('file.jpg', now()->addMinutes(5));
либо передать массив параметров запроса
$url = Storage::temporaryUrl('file.jpg', now()->addMinutes(5),[
  'ResponseContentType' => 'application/octet-stream',
  'ResponseContentDisposition' => 'attachment; filename=file2.jpg']);

// включить локальные временные URL-адреса в config/filesystems.php
'local' => [
  'driver' => 'local',
  'root' => storage_path('app/private'),
  'serve' => true,
  'throw' => false]

// настроить способ создания временных URL-адресов для определенного диска хранилища
namespace App\Providers;
use DateTime;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\URL;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void {
    Storage::disk('local')->buildTemporaryUrlsUsing(
      function (string $path, DateTime $expiration, array $options) {
        return URL::temporarySignedRoute(
          'files.download',
          $expiration,
          array_merge($options, ['path' => $path]));});}}

// временные URL-адреса для загрузки из клиентского приложения на стороне клиента, поддерживается только драйвером s3
// полезен в серверных средах, где клиентское приложение должно загружать файлы в облако
use Illuminate\Support\Facades\Storage;
['url' => $url, 'headers' => $headers] = Storage::temporaryUploadUrl('file.jpg', now()->addMinutes(5));
</code></pre>
        <p>Файлы и каталоги</p>
        <table>
          <caption>метаданные файла</caption>
          <tbody>
            <tr>
              <td>use Illuminate\Support\Facades\Storage;</td>
              <td></td>
            </tr>
            <tr>
              <td>$size = Storage::size('file.jpg');</td>
              <td>размера файла в байтах</td>
            </tr>
            <tr>
              <td>$time = Storage::lastModified('file.jpg');</td>
              <td>метка UNIX последнего изменения файла</td>
            </tr>
            <tr>
              <td>$mime = Storage::mimeType('file.jpg');</td>
              <td>MIME-тип файла</td>
            </tr>
            <tr>
              <td>$path = Storage::path('file.jpg');</td>
              <td>путь к файлу: драйвер local вернет абсолютный путь, s3 - относительный путь в корзине S3</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>хранение файлов: все пути к файлам должны быть относительно корня диска</caption>
          <tbody>
            <tr>
              <td>use Illuminate\Support\Facades\Storage;</td>
              <td></td>
            </tr>
            <tr>
              <td>Storage::put('file.jpg', $contents);</td>
              <td>сохранения содержимого файла на диске</td>
            </tr>
            <tr>
              <td>Storage::put('file.jpg', $resource);</td>
              <td>использовать поддержку базового потока Flysystem</td>
            </tr>
            <tr>
              <td>if (! Storage::put('file.jpg', $contents)) { }</td>
              <td>удалось ли записать на диск</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// включить выброс исключения при неудавшейся записи в config/filesystems.php
'public' => [
  'driver' => 'local',
  'throw' => true]

// записывать в начало или конец файла
Storage::prepend('file.log', 'Prepended Text');
Storage::append('file.log', 'Appended Text');

// копирование и перемещение файлов
Storage::copy('old/file.jpg', 'new/file.jpg');
Storage::move('old/file.jpg', 'new/file.jpg');

// автоматическая потоковая передача: потоковая передача файлов в хранилище значительно сокращает использование памяти
// вернет путь, включая сгенерированное имя файла
use Illuminate\Http\File;
use Illuminate\Support\Facades\Storage;
// автоматически генерировать уникальный идентификатор для имени файла
$path = Storage::putFile('photos', new File('/path/to/photo'));

// либо явно указать имя файла
$path = Storage::putFileAs('photos', new File('/path/to/photo'), 'photo.jpg');

// либо с аргументом для определения «видимости» сохраненного файла
Storage::putFile('photos', new File('/path/to/photo'), 'public');

// загрузка файлов: вернет путь, включая сгенерированное имя файла
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Http\Request;
class UserAvatarController extends Controller {
  public function update(Request $request): string {

    // по умолчанию store генерирует уникальный идентификатор для имени файла в указанной папке 'avatars'
    $path = $request->file('avatar')->store('avatars');
    return $path;}}

// либо
$path = Storage::putFile('avatars', $request->file('avatar'));

// присвоить имя вручную
$path = $request->file('avatar')->storeAs('avatars', $request->user()->id);

// либо
$path = Storage::putFileAs('avatars', $request->file('avatar'), $request->user()->id);

// указать диск
$path = $request->file('avatar')->store('avatars/'.$request->user()->id, 's3');

// либо
$path = $request->file('avatar')->storeAs('avatars', $request->user()->id, 's3');

// получить оригинальное имя или расширение загружаемого файла: небезопасно
$file = $request->file('avatar');
$name = $file->getClientOriginalName();
$extension = $file->getClientOriginalExtension();

// либо безопасно
$file = $request->file('avatar');
// Generate a unique, random name
$name = $file->hashName();
// Determine the file's extension based on the file's MIME type
$extension = $file->extension();

// видимость файла
use Illuminate\Support\Facades\Storage;
// задать видимость при записи файла
Storage::put('file.jpg', $contents, 'public');
// получить видимость сохранённого файла
$visibility = Storage::getVisibility('file.jpg');
// задать видимость сохранённому файлу
Storage::setVisibility('file.jpg', 'public');

// сохранить загружаемый файл с видимостью public
$path = $request->file('avatar')->storePublicly('avatars', 's3');
$path = $request->file('avatar')->storePubliclyAs('avatars', $request->user()->id, 's3');

// для драйвера local, видимость public это право доступа 0755 для каталогов и 0644 для файлов
// в config/filesystems.php
'local' => [
  'driver' => 'local',
  'root' => storage_path('app'),
  'permissions' => [
    'file' => [
      'public' => 0644,
      'private' => 0600],
    'dir' => [
      'public' => 0755,
      'private' => 0700]],
  'throw' => false]

//  удаление файлов
use Illuminate\Support\Facades\Storage;
Storage::delete('file.jpg');
Storage::delete(['file.jpg', 'file2.jpg']);

// либо указать диск
Storage::disk('s3')->delete('path/file.jpg');

// каталоги
use Illuminate\Support\Facades\Storage;
$files = Storage::files($directory);
$files = Storage::allFiles($directory);

// вернет массив всех каталогов указанного каталога
$directories = Storage::directories($directory);
// либо всех каталогов внутри указанного каталога и всех его подкаталогов
$directories = Storage::allDirectories($directory);

// создать каталог
Storage::makeDirectory($directory);

// удалить каталог и все его файлы
Storage::deleteDirectory($directory);
</code></pre>
        <p>тестирование: создавать фейковый диск</p>
        <pre><code>use Illuminate\Http\UploadedFile;
use Illuminate\Support\Facades\Storage;
test('albums can be uploaded', function () {
  Storage::fake('photos');
  $response = $this->json('POST', '/photos', [
    UploadedFile::fake()->image('photo1.jpg'),
    UploadedFile::fake()->image('photo2.jpg')]);

  // Проверка, что один или несколько файлов были сохранены
  Storage::disk('photos')->assertExists('photo1.jpg');
  Storage::disk('photos')->assertExists(['photo1.jpg', 'photo2.jpg']);

  // Проверка, что один или несколько файлов не были сохранены
  Storage::disk('photos')->assertMissing('missing.jpg');
  Storage::disk('photos')->assertMissing(['missing.jpg', 'non-existing.jpg']);

  // Проверка, что количество файлов в данном каталоге соответствует ожидаемому количеству
  Storage::disk('photos')->assertCount('/wallpapers', 2);

  // Проверка, что данный каталог пуст
  Storage::disk('photos')->assertDirectoryEmpty('/wallpapers');});
</code></pre>
        <p>файловые системы не из коробки</p>
        <pre><code>// добавить адаптер Dropbox
composer require spatie/flysystem-dropbox

// зарегистрировать адаптер
namespace App\Providers;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Filesystem\FilesystemAdapter;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\ServiceProvider;
use League\Flysystem\Filesystem;
use Spatie\Dropbox\Client as DropboxClient;
use Spatie\FlysystemDropbox\DropboxAdapter;
class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void {
    Storage::extend('dropbox', function (Application $app, array $config) {
      $adapter = new DropboxAdapter(new DropboxClient($config['authorization_token']));
      return new FilesystemAdapter(
        new Filesystem($adapter, $config),
        $adapter,

        // $config содержит значения, определенные в config/filesystems.php
        $config);});}}</code></pre>
        <h2>Processes: позволяет вызывать внешние процессы из приложения</h2>
        <pre><code>// получить присвоенный операционной системой идентификатор выполняющегося процесса
$process = Process::start('bash import.sh');
return $process->id();

//  отправить сигнал запущенному процессу
$process->signal(SIGUSR2);
</code></pre>
        <p>вызов процессов: run вызывает процессы синхронно</p>
        <pre><code>// вызвать базовый синхронный процесс и проверить его результат
use Illuminate\Support\Facades\Process;
$result = Process::run('ls -la');
return $result->output();

// run вернет Illuminate\Contracts\Process\ProcessResult, который даёт методы для анализа результата выполнения процесса
$result = Process::run('ls -la');
$result->successful();
$result->failed();
$result->exitCode();
$result->output();
$result->errorOutput();
</code></pre>
        <table>
          <caption>если процесс провалился</caption>
          <tbody>
            <tr>
              <td>$result = Process::run('ls -la')->throw();</td>
              <td>выбросить экземпляр</td>
            </tr>
            <tr>
              <td>Illuminate\Process\Exceptions\ProcessFailedException</td>
              <td> </td>
            </tr>
            <tr>
              <td>$result = Process::run('ls -la')->throwIf($condition);</td>
              <td>выбросит по условию</td>
            </tr>
            <tr>
              <td>$result = Process::path(__DIR__)->run('ls -la');</td>
              <td>указать рабочий каталог процесса</td>
            </tr>
            <tr>
              <td>$result = Process::input('Hello World')->run('cat');</td>
              <td>предоставить ввод через “стандартный ввод” процесса</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>если процессы выполняются более 60 секунд, то выбрасят экземпляр</caption>
          <tbody>
            <tr>
              <td>Illuminate\Process\Exceptions\ProcessTimedOutException</td>
              <td></td>
            </tr>
            <tr>
              <td>$result = Process::timeout(120)->run('bash import.sh');</td>
              <td>настроить таймаут процесса</td>
            </tr>
            <tr>
              <td>$result = Process::forever()->run('bash import.sh');</td>
              <td>отключить таймаут процесса</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// указать максимальное количество секунд выполнения процесса без результата
$result = Process::timeout(60)->idleTimeout(30)->run('bash import.sh');

// процесс унаследует все переменные среды из .env
$result = Process::forever()->env(['IMPORT_PATH' => __DIR__])->run('bash import.sh');

// унаследованную переменную среды из процесса
$result = Process::forever()->env(['LOAD_PATH' => false])->run('bash import.sh');

// режим TTY соединяет ввод и вывод процесса с вводом и выводом терминала: открыть редактор Vim как процесс
Process::forever()->tty()->run('vim');

// получить вывод после выполнения процесса с методом output (stdout) и errorOutput (stderr)
use Illuminate\Support\Facades\Process;
$result = Process::run('ls -la');
echo $result->output();
echo $result->errorOutput();

// получить вывод в реальном времени: первый аргумент функции это тип вывода (stdout или stderr), второй - сам вывод в виде строки
$result = Process::run('ls -la', function (string $type, string $output) {echo $output;});
// содержится ли заданная строка в выводе процесса
if (Process::run('ls -la')->seeInOutput('laravel')) { }

// отключить получение вывода от процесса
use Illuminate\Support\Facades\Process;
$result = Process::quietly()->run('bash import.sh');
</code></pre>
        <p>асинхронные процессы: start вызывает процессы асинхронно</p>
        <pre><code>// приложение выполняет другие задачи, пока процесс выполняется в фоновом режиме
$process = Process::timeout(120)->start('bash import.sh');
// определяет выполняется ли процесс
while ($process->running()) { }
// дождаться завершения процесса и получить экземпляр результата
$result = $process->wait();

// либо
$process = Process::timeout(120)->start('bash import.sh');
$result = $process->wait();

// получить вывод процесса, который произошел после последнего вывода
$process = Process::timeout(120)->start('bash import.sh');
while ($process->running()) {
  echo $process->latestOutput();
  echo $process->latestErrorOutput();
  sleep(1);}

// получать вывод в реальном времени: первый аргумент функции это тип вывода (stdout или stderr), второй - сам вывод в виде строки
$process = Process::start('bash import.sh', function (string $type, string $output) {echo $output;});
$result = $process->wait();

// остановить ожидание завершения процесса, как только процесс выведет нужный результат
$process = Process::start('bash import.sh');
$process->waitUntil(function (string $type, string $output) {return $output === 'Ready...';});
</code></pre>
        <p>параллельные процессы: управление пулом одновременных асинхронных процессов</p>
        <pre><code>use Illuminate\Process\Pool;
use Illuminate\Support\Facades\Process;
$pool = Process::pool(function (Pool $pool) {
  $pool->path(__DIR__)->command('bash import-1.sh');
  $pool->path(__DIR__)->command('bash import-2.sh');
  $pool->path(__DIR__)->command('bash import-3.sh');
})->start(function (string $type, string $output, int $key) { });

// доступ к коллекции запущенных процессов
while ($pool->running()->isNotEmpty()) { }
// дождаться завершения всех процессов в пуле и получить массив их результатов
$results = $pool->wait();
// получить экземпляр результата
echo $results[0]->output();

// либо с получением результатов в реальном времени
[$first, $second, $third] = Process::concurrently(function (Pool $pool) {
  $pool->path(__DIR__)->command('ls -la');
  $pool->path(app_path())->command('ls -la');
  $pool->path(storage_path())->command('ls -la');});
echo $first->output();

// назначить строковые ключи каждому процессу в пуле, вместо числовых для определения к какому процессу относится вывод
$pool = Process::pool(function (Pool $pool) {
  $pool->as('first')->command('bash import-1.sh');
  $pool->as('second')->command('bash import-2.sh');
  $pool->as('third')->command('bash import-3.sh');
})->start(function (string $type, string $output, string $key) { });
$results = $pool->wait();
return $results['first']->output();
// получить доступ к идентификаторам процессов в основном пуле
$processIds = $pool->running()->each->id();
// отправить сигнал каждому процессу внутри пула
$pool->signal(SIGUSR2);
</code></pre>
        <p>pipelines</p>
        <pre><code>// pipe выполнит связанные процессы синхронно и вернет результат последнего
use Illuminate\Process\Pipe;
use Illuminate\Support\Facades\Process;
$result = Process::pipe(function (Pipe $pipe) {
  $pipe->command('cat example.txt');
  $pipe->command('grep -i "laravel"');});
if ($result->successful()) { }

// либо
$result = Process::pipe(['cat example.txt', 'grep -i "laravel"']);

// получать вывод в реальном времени: первый аргумент функции это тип вывода (stdout или stderr), второй - сам вывод в виде строки
$result = Process::pipe(function (Pipe $pipe) {
  $pipe->command('cat example.txt');
  $pipe->command('grep -i "laravel"');},
  function (string $type, string $output) {echo $output;});

// назначать строковые ключи каждому процессу
$result = Process::pipe(function (Pipe $pipe) {
  $pipe->as('first')->command('cat example.txt');
  $pipe->as('second')->command('grep -i "laravel"');
})->start(function (string $type, string $output, string $key) { });
</code></pre>
        <p>тестирование процессов: возврат фиктивных/заглушечных результатов при вызове процессов</p>
        <pre><code>// вызвать синхронный процесс
use Illuminate\Support\Facades\Process;
use Illuminate\Support\Facades\Route;
Route::get('/import', function () {
  Process::run('bash import.sh');
  return 'Import complete!';});

// тест синхронного процесса
use Illuminate\Process\PendingProcess;
use Illuminate\Contracts\Process\ProcessResult;
use Illuminate\Support\Facades\Process;
test('process is invoked', function () {

  // вернуть поддельный успешный результат для каждого вызванного процесса
  Process::fake();
  $response = $this->get('/import');
  // был ли запущен процесс
  Process::assertRan('bash import.sh');

  // проверить конфигурацию процесса
  Process::assertRan(function (PendingProcess $process, ProcessResult $result) {
    return $process->command === 'bash import.sh' && $process->timeout === 60;});});

// указать вывод и код завершения для поддельных процессов
Process::fake(['*' => Process::result(output: 'Test output', errorOutput: 'Test error output', exitCode: 1)]);

// ключи массива - шаблоны подделываемых команд, значения - их результаты
Process::fake([
  'cat *' => Process::result(output: 'Test "cat" output'),
  'ls *' => Process::result(output: 'Test "ls" output')]);

// либо если не нужно настраивать код завершения или вывод ошибок поддельного процесса
Process::fake([
  'cat *' => 'Test "cat" output',
  'ls *' => 'Test "ls" output']);

// назначить различные фейковые результаты каждому вызову процесса
Process::fake(['ls *' => Process::sequence()->push(Process::result('First invocation'))->push(Process::result('Second invocation'))]);

// вызвать асинхронный процесс
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Route;
Route::get('/import', function () {
  $process = Process::start('bash import.sh');
  while ($process->running()) {
    Log::info($process->latestOutput());
    Log::info($process->latestErrorOutput());}
  return 'Done';});

//  тест асинхронного процесса: описать, сколько раз метод running должен возвращать true и указать какие строки вывода вернуть
Process::fake(['bash import.sh' => Process::describe()
  ->output('First line of standard output')
  ->errorOutput('First line of error output')
  ->output('Second line of standard output')
  ->exitCode(0)
  ->iterations(3)]);

//  утверждения процессов для тестов: true/false
use Illuminate\Support\Facades\Process;
// процесс выполняется
Process::assertRan('ls -la');

// получить экземпляр и результат процесса, чтобы проверить конфигурацию процесса
use Illuminate\Process\PendingProcess;
use Illuminate\Contracts\Process\ProcessResult;

// если функция вернет true, то утверждение будет пройдено
Process::assertRan(fn ($process, $result) =>
  $process->command === 'ls -la' &&
  $process->path === __DIR__ &&
  $process->timeout === 60);

// либо
use Illuminate\Support\Facades\Process;
// процесс не выполняется
Process::assertDidntRun('ls -la');

// получить экземпляр и результат процесса, чтобы проверить конфигурацию процесса
// если функция вернет true, то утверждение будет провалено
Process::assertDidntRun(fn (PendingProcess $process, ProcessResult $result) => $process->command === 'ls -la');

// либо
use Illuminate\Support\Facades\Process;
// процесс выполнился 3 раза
Process::assertRanTimes('ls -la', times: 3);

// получить экземпляр и результат процесса, чтобы проверить конфигурацию процесса
// если функция вернет true и процесс был вызван указанное количество раз, то утверждение будет пройдено
Process::assertRanTimes(function (PendingProcess $process, ProcessResult $result) {
  return $process->command === 'ls -la';}, times: 3);
  
// процессы без поддельного результата, вызовут исключение, а не фактический процесс
use Illuminate\Support\Facades\Process;
Process::preventStrayProcesses();
Process::fake(['ls *' => 'Test output...']);

// получен поддельный ответ
Process::run('ls -la');
// получено исключение
Process::run('bash import.sh');</code></pre>
        <h2>Task Scheduling</h2>
        <p>управление запланированными задачами на сервере</p>
        <ul>
          <li>Планировщик позволяет определять расписание команд в самом приложении, без отдельного подключения по SSH.</li>
          <li>При использовании планировщика на сервере требуется только одна запись cron.</li>
          <li>Расписание задач обычно определяется в файле routes/console.php.</li>
        </ul>
        <h2>Routes</h2>
        <ul>
          <li>маршрут это URI и поведение при запросе этого URI</li>
          <li>анонимные функции маршрутов - это альтернатива контроллеров и консольных команд в виде классов</li>
          <li>routes/console.php не определяет HTTP-маршруты, он определяет консольные точки входа</li>
        </ul>
        <table>
          <tbody> 
            <tr>
              <td>api.php</td>
              <td>маршруты API</td>
            </tr>
            <tr>
              <td>channels.php</td>
              <td>маршруты широковещательной передачи</td>
            </tr>
            <tr>
              <td>console.php</td>
              <td>маршруты консоли</td>
            </tr>
            <tr>
              <td>web.php</td>
              <td>маршруты веб-приложения</td>
            </tr>
          </tbody>
        </table>
        <pre><code>use Illuminate\Support\Facades\Route;

// вернуть 'Hello World'
Route::get('/greeting', function () {return 'Hello World';});

// вызывать метод index JobController при переходе на /jobs
Route::get('/jobs', [JobController::class, 'index']);
</code></pre>
        <p>маршруты НТТР-методов</p>
        <pre><code>// маршрут с методом get всегда указывать первым
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);
Route::any('/', function () {});

// все методы на одном маршруте
Route::match(['get', 'post'], '/', function () {});

// несколько методов на одном маршруте
// перенаправить маршрут, третий необязательный параметр (301)
Route::redirect('/here', '/there', 301);

// вернуть шаблон 'welcome' с переменной 'name'
Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

// маршруты поддоменов указывать перед маршрутами корневого домена
Route::domain('{account}.example.com')->group(function () {
  Route::get('/user/{id}', function (string $account, string $id) {});
});
</code></pre>
        <table> 
          <caption>artisan для маршрутов</caption>
          <tbody>
            <tr>
              <td>php artisan route:cache</td>
              <td>кешировать</td>
            </tr>
            <tr>
              <td>php artisan route:clear</td>
              <td>очистить кеш маршрутов</td>
            </tr>
            <tr>
              <td>php artisan route:list -v</td>
              <td>просмотреть список маршрутов с малой информацией</td>
            </tr>
            <tr>
              <td>php artisan route:list -vv</td>
              <td>просмотреть список маршрутов с подробной информацией</td>
            </tr>
            <tr>
              <td>php artisan route:list --path=api</td>
              <td>просмотреть список api-маршрутов</td>
            </tr>
            <tr>
              <td>php artisan route:list --except-vendor</td>
              <td>просмотреть список маршрутов без встроенных</td>
            </tr>
            <tr>
              <td>php artisan route:list --only-vendor</td>
              <td>просмотреть список только встроенных маршрутов</td>
            </tr>
            <tr>
              <td>php artisan install:api</td>
              <td>установить пакет Sanctum и создать routes/api.php для api-маршрутов</td>
            </tr>
          </tbody>
        </table>
        <p>настройка маршрутизации в bootstrap/app.php</p>
        <pre><code>// параметры и зависимости маршрута
Route::get(
  '/posts/{post}/comments/{comment}',
  function (Request $request, string $postId, string $commentId) {});

// изменить ключ
Route::get('/posts/{post:slug}', function (Post $post) {return $post;});

// у необязательного параметра должно быть значение по умолчанию
Route::get('/user/{name?}', function (?string $name = 'John') {return $name;});

// формат маршрута в регулярном выражении
Route::get(
  '/user/{id}/{name}',
  function (string $id, string $name) { })
->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

// методы типовых шаблонов регулярных выражений
whereNumber('id')
whereAlpha('name')
whereAlphaNumeric('name')
whereUuid('id')
whereUlid('id')
whereIn('category', ['movie', 'song', 'painting'])
whereIn('category', CategoryEnum::cases())
</code></pre>
        <p>в App\Providers\AppServiceProvider</p>
        <pre><code>// глобальный шаблон
use Illuminate\Support\Facades\Route;
public function boot(): void
{Route::pattern('id', '[0-9]+');}

// связывание модели и URI
// в маршруте: Route::get('/users/{user}', function (User $user) { });
{Route::model('user', User::class);}

// поменять логику связывания модели и URI
{Route::bind('user', function (string $value) {return User::where('name', $value)->firstOrFail();});}

// ограничение частоты запросов
{RateLimiter::for('api', function (Request $request) {return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());});}

// ограничение частоты запросов и своё сообщение
{RateLimiter::for('global', function (Request $request) {
  return Limit::perMinute(1000)->response(function (Request $request, array $headers) {
    return response('Custom response...', 429, $headers);
  });
});}

// ограничение частоты запросов по статусу пользователя
{RateLimiter::for('uploads', function (Request $request) {
  return $request->user()->vipCustomer() ? Limit::none() : Limit::perMinute(100);
});}

// ограничение частоты запросов отдельно по ip и id
{RateLimiter::for('uploads', function (Request $request) {
  return $request->user() ? Limit::perMinute(100)->by($request->user()->id) : Limit::perMinute(10)->by($request->ip());
});}

// ограничение частоты запросов по маршрутам
{Route::middleware(['throttle:uploads'])->group(function () {
  Route::post('/audio', function () {});
  Route::post('/video', function () {});
});}
</code></pre>
        <p>маршрут и модель</p>
        <ul>
          <li>wildcard {user} and parametr function (User $user): привязка модели к маршруту,</li>
          <li>по умолчанию {user} - это id, но можно задать название столба таблицы {user:name}</li>
        </ul>
        <pre><code>// привязка модели
Route::get('/users/{user}', function (User $user) {return $user->email;});

// либо
Route::get(
  '/users/{user}',
  function (User $user) {return view('users.show', ['user' => $user]);});

// привязка дочерней модели к родительской
Route::get(
  '/users/{user}/posts/{post}',
  function (User $user, Post $post) {return $post;})->scopeBindings();

// с группировкой
Route::scopeBindings()->group(function () {
  Route::get(
    '/users/{user}/posts/{post}',
    function (User $user, Post $post) {return $post;});
});

// не использовать область действия привязоки
Route::get(
  '/users/{user}/posts/{post:slug}',
  function (User $user, Post $post) {return $post;})
->withoutScopedBindings();
</code></pre>
        <p>маршрут и контроллер</p>
        <pre><code>// к методу
Route::get('/user/{id}', [UserController::class, 'show']);

// контроллер одиночного действия
Route::post('/server', ProvisionServer::class);

// с middleware
Route::get('/profile', [UserController::class, 'show'])->middleware('auth');

// с параметром для middleware
Route::put(
  '/post/{id}',
  function (string $id) {})
->middleware(EnsureUserHasRole::class.':editor,publisher');

// именованный маршрут
Route::get('/user/profile', [UserProfileController::class, 'show'])->name('profile');

// именованный маршрут с параметрами
Route::get('/user/{id}/profile', function (string $id) { })->name('profile');
$url = route('profile', ['id' => 1, 'photos' => 'yes']);

// был ли запрос на маршрут
if ($request->route()->named('profile')) {}

// ресурсный маршрут должен быть последним
// к ресурсному контроллеру
Route::resource('photos', PhotoController::class);

// выбор методов в ресурсном контроллере
Route::resource('photos', PhotoController::class)->only(['index', 'show']);
Route::resource('photos', PhotoController::class)->except(['create', 'store', 'update', 'destroy']);

// редирект при отсутствии модели
Route::resource('photos', PhotoController::class)->missing(function (Request $request) {
  return Redirect::route('photos.index');
});

// использовать программно удалённые модели
Route::resource('photos', PhotoController::class)->withTrashed();

// вернёт: /photos/{photo}/comments/{comment}
Route::resource('photos.comments', PhotoCommentController::class);

// при уникальных идентификаторах вернёт: /photos/{photo}/comments
Route::resource('photos.comments', CommentController::class)->shallow();

// именованный ресурсный маршрут
Route::resource('photos', PhotoController::class)->names(['create' => 'photos.build']);

// вернёт: /users/{admin_user}
Route::resource('users', AdminUserController::class)->parameters(['users' => 'admin_user']);

// вернёт: /photos/{photo}/comments/{comment:slug}
Route::resource('photos.comments', PhotoCommentController::class)->scoped(['comment' => 'slug']);

// ресурсные api-маршруты - маршруты без create и edit
Route::apiResource('photos', PhotoController::class);
</code></pre>
        <p>создание URL-адреса и перенаправление по именованному маршруту</p>
        <pre><code>$url = route('profile');
return redirect()->route('profile');
return to_route('profile');
</code></pre>
        <p>группировка маршрутов</p>
        <pre><code>// маршруты c общим контроллером
Route::controller(JobController::class)->group( function()
{
  Route::get('/jobs', 'index');
  Route::get('/jobs/create', 'create');
  Route::get('/jobs/{job}', 'show');
  Route::get('/jobs/{job}/edit', 'edit');
  Route::post('/jobs', 'store');
  Route::patch('/jobs/{job}', 'update');
  Route::delete('/jobs/{job}', 'destroy');
});

// по middleware `first` и `second`
Route::middleware(['first', 'second'])->group(function () {Route::get('/', function () {});});

// по преффиксу: /admin/users
Route::prefix('admin')->group(function () {Route::get('/users', function () {});});

// по имени маршрута: admin.users
Route::name('admin')->group(function () {Route::get('/users', function () {})->name('users');});
</code></pre>
        <p>middleware can(действие, маршрут) - на этот маршрут разрешено тому, кому политикой разрешено совершать указанное действие</p>
        <pre><code>// обновить пост
Route::put('/post/{post}', function (Post $post) { })->middleware('can:update,post');

// либо
Route::put('/post/{post}', function (Post $post) { })->can('update', 'post');
</code></pre>
        <p>определить названия маршрутов в Enums</p>
        <pre><code>namespace App\Enums;
enum Category: string {
  case Fruits = 'fruits';
  case People = 'people';
}

// в маршруте
use App\Enums\Category;
use Illuminate\Support\Facades\Route;
Route::get('/categories/{category}', function (Category $category) {return $category->value;});

// резевный маршрут, если запрос не соответствует ни одному маршруту
Route::fallback(function () {});
</code></pre>
        <p>перенаправить</p>
        <pre><code>Route::get('/dashboard', function () {

  // на указанную страницу
  return redirect('/home/dashboard');
});
Route::post('/user/profile', function () {

  // перенаправить обратно с записью в сессию данных ввода и фильтром middleware
  return back()->withInput();
})->middleware('web');

// на внешний домен
return redirect()->away('https://www.google.com');

// на метод контроллера
return redirect()->action([UserController::class, 'profile'], ['id' => 1]);

// на именованный маршрут
return redirect()->route('profile', ['id' => 1]);

// на именованный маршрут с указанием модели
return redirect()->route('profile', [$user]);

// на именованный маршрут с указанием столбца как ключа
return redirect()->route('/profile/{id:slug}', [$user]);

// задать ключ маршрута в модели
public function getRouteKey(): mixed                
{return $this->slug;}

// с записью указанных данных в сессию
return redirect('/dashboard')->with('status', 'Profile updated!');

// отобразить запись в шаблоне
@if (session('status'))
    < div class="alert alert-success">{{ session('status') }}</ div>
@endif
// перенаправить на ответ
// с HTML
return response()->view('hello', $data, 200)->header('Content-Type', $type);

// с JSON
return response()->json(['name' => 'Abigail', 'state' => 'CA'])->withCallback($request->input('callback'));

// заставить браузер пользователя загрузить файл
return response()->download($pathToFile, $name, $headers);

// отображение файла в браузере без загрузки
return response()->file($pathToFile, $headers);
</code></pre>
        <p>выполнить тест</p>
        <pre><code>Route::get('test', function () {
  $job = Job::first();
  TranslateJob::dispatch($job);
  return 'Done';
});
</code></pre>
        <p>ресурсный маршрут</p>
        <pre><code>Route::resource('uri', controller);
Route::resource('jobs', JobController::class);

// сформирует для методов класса контроллера маршруты:
jobs.index    - показать всё списком
jobs.show     - показать один
jobs.create   - создать
jobs.edit     - редактировать
jobs.store    - сохранить
jobs.update   - обновить
jobs.destroy  - уничтожить

// маршруты только для 'index' и 'show'
Route::resource('jobs', JobController::class, ['only' => ['index', 'show']]);

// все маршруты кроме 'edit'
Route::resource('jobs', JobController::class, ['except' => ['edit']]);</code></pre>
        <h2>Middleware</h2>
        <p>middleware - класс для проверки и фильтрации HTTP-запросов, HTTP-ответов, HTTP-заголовков, HTTP-тел, HTTP-методов</p>
        <pre><code>// создать
php artisan make:middleware MyMiddleware

// либо указать путь
php artisan make:middleware App\Http\Middleware\MyMiddleware

// либо указать путь и пространство имен
php artisan make:middleware App\Http\Middleware\MyMiddleware --namespace=App\Http\Middleware
</code></pre>
        <p>получает запрос, сравнивает значение токена из запроса и либо перенаправляет на домашнюю страницу, либо пропускает запрос дальше в приложение</p>
        <pre><code>namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Symfony\Component\HttpFoundation\Response;
class MyMiddleware
{
  // @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next): Response
  {
    // выполняется до обработки запроса приложением
    if ($request->input('token') !== 'my-secret-token') {return redirect('/home');}
    return $next($request);
  }
}

//либо
  public function handle(Request $request, Closure $next): Response
  {
    return $next($request);
    // выполняется после обработки запроса приложением
    return $response;
  }

// с параметром
class EnsureUserHasRole
{
  // @param  \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  public function handle(Request $request, Closure $next, string $role): Response
  {
    if (! $request->user()->hasRole($role)) {}
    return $next($request);
  }
}
</code></pre>
        <p>в bootstrap/app.php</p>
        <pre><code>// группировка
->withMiddleware(function (Middleware $middleware) {
  $middleware->appendToGroup('group-name', [
    First::class,
    Second::class,
  ]);
  $middleware->prependToGroup('group-name', [
    First::class,
    Second::class,
  ]);
})

// добавить к группе
->withMiddleware(function (Middleware $middleware) {

  // применяется к routes/web.php
  $middleware->web(append: [EnsureUserIsSubscribed::class]);

  // применяется к routes/api.php
  $middleware->api(prepend: [EnsureTokenIsValid::class]);
})

// заменить middleware в группе
$middleware->web(replace: [StartSession::class => StartCustomSession::class]);

// удалить middleware из группы
$middleware->web(remove: [StartSession::class]);

// псевдоним для middleware
->withMiddleware(function (Middleware $middleware) {
  $middleware->alias(['subscribed' => EnsureUserIsSubscribed::class]);
})

// применить псевдоним middleware
Route::get('/profile', function () { })->middleware('subscribed');

// перенаправить пользователя если он гость
->withMiddleware(function (Middleware $middleware) {
  $middleware->redirectGuestsTo('/login');
  
  // либо
  $middleware->redirectGuestsTo(fn (Request $request) => route('login'));
})

// перенаправить пользователя если он аутентифицирован
->withMiddleware(function (Middleware $middleware) {
  $middleware->redirectUsersTo('/panel');
  
  // либо
  $middleware->redirectUsersTo(fn (Request $request) => route('panel'));
})
</code></pre>
        <p>в маршруте</p>
        <pre><code>// доступ только для аутентифицированных
Route::get('/flights', function () { })->middleware('auth');

// доступ только с подтверждённым email
Route::get('/profile', function () { })->middleware(['auth', 'verified']);

// доступ только для аутентифицированных по guard 'admin' из config/auth.php
Route::get('/flights', function () { })->middleware('auth:admin');
</code></pre>
        <p>метод share может возвращать общие данные для всех страниц Inertia</p>
        <pre><code>namespace App\Http\Middleware;
use App\Models\Post;
use Illuminate\Http\Request;
use Inertia\Middleware;
class HandleInertiaRequests extends Middleware
{
  public function share(Request $request)
  {
    return [...parent::share($request), 'auth' => [
      'user' => $request->user(),
      'permissions' => ['post' => ['create' => $request->user()->can('create', Post::class)]],
    ]];
  }
}
</code></pre>
        <p>форматирование значений поля ввода input настраивается Illuminate\Foundation\Http\Middleware\TrimStrings и Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull в bootstrap/app.php</p>
        <p>доверенные прокси указать в bootstrap/app.php</p>
        <pre><code>->withMiddleware(function (Middleware $middleware) {
  $middleware->trustProxies(at: [
    '192.168.1.1',
    '10.0.0.0/8',
  ]);
})

// заголовки доверенных прокси
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustProxies(headers: Request::HEADER_X_FORWARDED_FOR |
    Request::HEADER_X_FORWARDED_HOST |
    Request::HEADER_X_FORWARDED_PORT |
    Request::HEADER_X_FORWARDED_PROTO |
    Request::HEADER_X_FORWARDED_AWS_ELB
  );
})

// доверять всем прокси
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustProxies(at: '*');
})
</code></pre>
        <p>доверенный host</p>
        <pre><code>// имя хоста, на которого реагировать указать в bootstrap/app.php
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustHosts(at: ['laravel.test']);
})

// не доверять поддоменам хоста
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustHosts(at: ['laravel.test'], subdomains: false);
})

// указать доверенные хосты в файле конфигурации
->withMiddleware(function (Middleware $middleware) {
  $middleware->trustHosts(at: fn () => config('app.trusted_hosts'));
})</code></pre>
        <h2>Session</h2>
        <p>сессия - это способ хранения данных между запросами в виде массива, JSON и отдельных переменных в файлах, базе данных, кэше или в памяти.</p>
        <p>
          по умолчанию Laravel использует драйвер файловой системы для хранения данных сессии<br/>
          драйверы кеша и БД могут быть использованы для хранения данных сессии
        </p>
        <pre><code>php artisan session:table
php artisan migrate
</code></pre>
        <ul>
          <li>по умолчанию Laravel использует драйвер файловой системы для хранения данных сессии</li>
          <li>драйверы кеша и БД могут быть использованы для хранения данных сессии</li>
        </ul>
        <pre><code>php artisan session:table
php artisan migrate
</code></pre>
        <p>по умолчанию database, данные сессии в таблице sessions в 0001_01_01_000000_create_users_table.php</p>
        <table>
          <caption>настройка хранения сессии в config/session.php</caption>
          <tbody>
            <tr>
              <td>file</td>
              <td>сессии хранятся в storage/framework/sessions.</td>
            </tr>
            <tr>
              <td>cookie</td>
              <td>сессии хранятся в безопасных, зашифрованных файлах Cookies.</td>
            </tr>
            <tr>
              <td>database</td>
              <td>сессии хранятся в реляционной базе данных.</td>
            </tr>
            <tr>
              <td>memcached / redis</td>
              <td>сессии хранятся в одном из этих быстрых хранилищ на основе кеша.</td>
            </tr>
            <tr>
              <td>dynamodb</td>
              <td>сессии хранятся в AWS DynamoDB.</td>
            </tr>
            <tr>
              <td>array</td>
              <td>сессии хранятся в массиве PHP и не будет сохранены.</td>
            </tr>
          </tbody>
        </table>
        <p>получить данные из сессии</p>
        <pre><code>// через экземпляр Request
namespace App\Http\Controllers;
use Illuminate\Http\Request;
use Illuminate\View\View;
class UserController extends Controller
{
  public function show(Request $request, string $id): View
  {
    $value = $request->session()->get('key', 'default');
    $user = $this->users->find($id);
    return view('user.profile', ['user' => $user]);
  }
}

// через глобальный помощник session
Route::get('/home', function () {

  // получить часть данных из сессии
  $value = session('key');

  // получить часть данных из сессии с указанием значения по умолчанию
  $value = session('key', 'default');

  // сохранить часть данных в сессию
  session(['key' => 'value']);
});</code></pre>
        <table>
          <tbody> 
            <tr>
              <td>$data = $request->session()->all();</td>
              <td>получить все данные сессии</td>
            </tr>
            <tr>
              <td>$data = $request->session()->only(['username', 'email']);</td>
              <td>получить только указанные данные сессии</td>
            </tr>
            <tr>
              <td>$data = $request->session()->except(['username', 'email']);</td>
              <td>получить данные сессии без указанных</td>
            </tr>
            <tr>
              <td>$value = $request->session()->pull('key', 'default');</td>
              <td>получает и удаляет элемент из сессии</td>
            </tr>
            <tr>
              <td>if ($request->session()->has('users')) { }</td>
              <td>наличие элемента в сессии не равного null</td>
            </tr>
            <tr>
              <td>if ($request->session()->exists('users')) { }</td>
              <td>наличие элемента в сессии в т.ч. null</td>
            </tr>
            <tr>
              <td>if ($request->session()->missing('users')) { }</td>
              <td>элемент в сессии либо null, либо отсутствует</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>данные в сессии</caption>
          <tbody>
            <tr>
              <td>$request->session()->put('key', 'value');                         </td>
              <td>сохранить через экземпляр запроса</td>
            </tr>
            <tr>
              <td>session(['key' => 'value']);                                      </td>
              <td>сохранить через глобальный помощник «session»</td>
            </tr>
            <tr>
              <td>$request->session()->push('user.teams', 'developers');            </td>
              <td>вставка нового значения</td>
            </tr>
            <tr>
              <td>$request->session()->increment('count');                          </td>
              <td>увеличение целочисленных значений в сессии</td>
            </tr>
            <tr>
              <td>$request->session()->increment('count', $incrementBy = 2);        </td>
              <td>увеличение целочисленных значений в сессии</td>
            </tr>
            <tr>
              <td>$request->session()->decrement('count');                          </td>
              <td>уменьшение целочисленных значений в сессии</td>
            </tr>
            <tr>
              <td>$request->session()->decrement('count', $decrementBy = 2);        </td>
              <td>уменьшение целочисленных значений в сессии</td>
            </tr>
            <tr>
              <td>$request->session()->now('status', 'Задача выполнена успешно!');  </td>
              <td>сохранить только для текущего запроса</td>
            </tr>
            <tr>
              <td>$request->session()->flash('status', 'Задача выполнена успешно!');</td>
              <td>сохранить только для следующего запроса</td>
            </tr>
            <tr>
              <td>$request->session()->reflash();                                   </td>
              <td>для нескольких запросов одновременно, потом удаление</td>
            </tr>
            <tr>
              <td>$request->session()->keep(['username', 'email']);                 </td>
              <td>сохранить отдельные данные для следующего запроса</td>
            </tr>
            <tr>
              <td>$request->session()->forget('name');                              </td>
              <td>удалить единственный ключ</td>
            </tr>
            <tr>
              <td>$request->session()->forget(['name', 'status']);                  </td>
              <td>удалить несколько ключей</td>
            </tr>
            <tr>
              <td>$request->session()->flush();                                     </td>
              <td>удалить все данные из сессии</td>
            </tr>
            <tr>
              <td>$request->session()->regenerate();                                </td>
              <td>повторно сгенерировать идентификатор сессии</td>
            </tr>
            <tr>
              <td>$request->session()->invalidate();                                </td>
              <td>удалить идентификатор сессии все её данные</td>
            </tr>
          </tbody>
        </table>
        <p>блокировка сессии</p>
        <pre><code>// по умолчанию блокировка 10 сек и ожидание получения блокировки 10 сек
Route::post('/profile', function () { })->block();
Route::post('/profile', function () { })->block($lockSeconds = 10, $waitSeconds = 10);
Route::post('/order', function () { })->block($lockSeconds = 10, $waitSeconds = 10);</code></pre>
        <h2>CSRF</h2>
        <ul>
          <li>токен CSRF для защиты от атак CSRF, хранится в сессии</li>
          <li>CSRF - это атака, при которой злоумышленник отправляет запрос от имени пользователя без его ведома</li>
          <li>Laravel использует токены CSRF для защиты от атак CSRF</li>
          <li>токены CSRF хранятся в сессии пользователя и проверяются при каждом запросе</li>
          <li>токены CSRF могут быть использованы только для POST, PUT, PATCH и DELETE запросов</li>
        </ul>
        <pre><code>Route::get('/token', function (Request $request) {

  // доступ к токену CSRF
  $token = $request->session()->token();

  // либо
  $token = csrf_token();
});
</code></pre>
        <p>в каждой форме с методом «POST», «PUT», «PATCH» или «DELETE» должен быть токен</p>
        <pre><code>< form method="POST" action="/profile">
  @csrf

  // либо
  < input type="hidden" name="_token" value="{{ csrf_token() }}" />
< /form>
</code></pre>
        <p>исключить маршруты из проверки токена в файле bootstrap/app.php</p>
        <pre><code>->withMiddleware(function (Middleware $middleware) {
  $middleware->validateCsrfTokens(except: [
    'stripe/*',
    'http://example.com/foo/bar',
    'http://example.com/foo/*',
  ]);
})
</code></pre>
        <table>
          <caption>добавить токен</caption>
          <tbody> 
            <tr>
              <td>< meta name="csrf-token" content="{{ csrf_token() }}"></td>
              <td>в HTML-заголовок X-CSRF-TOKEN</td>
            </tr>
            <tr>
              <td>< meta name="x-xsrf-token" content="{{ csrf_token() }}"></td>
              <td>в заголовок X-XSRF-TOKEN</td>
            </tr>
          </tbody>
        </table>
        <p>По умолчанию файл resources/js/bootstrap.js включает HTTP-библиотеку Axios, которая автоматически отправляет заголовок X-XSRF-TOKEN.</p>
        <h2>Application</h2>
        <table>
          <caption>Catalog namespace App</caption>
          <tbody> 
            <tr>
              <td>Broadcasting</td>
              <td>классы широковещательных каналов</td>
            </tr>
            <tr>
              <td>Console</td>
              <td>пользовательские команды Artisan</td>
            </tr>
            <tr>
              <td>Events</td>
              <td>классы событий</td>
            </tr>
            <tr>
              <td>Notifications</td>
              <td>уведомления о событиях, которые происходят в приложении</td>
            </tr>
            <tr>
              <td>Exceptions</td>
              <td>классы исключений</td>
            </tr>
            <tr>
              <td>Http</td>
              <td>логика обработки поступающих запросов: классы контроллеров, middleware и запросов</td>
            </tr>
            <tr>
              <td>Jobs</td>
              <td>планировщики заданий</td>
            </tr>
            <tr>
              <td>Listeners</td>
              <td>обработчики событий</td>
            </tr>
            <tr>
              <td>Controllers</td>
              <td>логика обработки запросов</td>
            </tr>
            <tr>
              <td>Middleware</td>
              <td>фильтрация запросов</td>
            </tr>
            <tr>
              <td>Mail</td>
              <td>классы для работы с почтой</td>
            </tr>
            <tr>
              <td>Models</td>
              <td>классы моделей Eloquent для взаимодействия с таблицами БД</td>
            </tr>
            <tr>
              <td>Policies</td>
              <td>классы политик авторизации определяют возможные действия пользователя</td>
            </tr>
            <tr>
              <td>Providers</td>
              <td>классы поставщиков служб: таких как база данных, очереди, валидация и маршрутизация</td>
            </tr>
            <tr>
              <td>Rules</td>
              <td>классы правил валидации</td>
            </tr>
            <tr>
              <td>Requests</td>
              <td>правила валидации запроса</td>
            </tr>
            <tr>
              <td>Resources</td>
              <td>классы ресурсов API</td>
            </tr>
            <tr>
              <td>Services</td>
              <td>классы сервисов, которые реализуют бизнес-логику приложения</td>
            </tr>
            <tr>
              <td>Traits</td>
              <td>классы трейтов, которые могут быть использованы в других классах</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>контроллеры - классы, которые обрабатывают HTTP-запросы и возвращают HTTP-ответы, view, JSON, файлы и редиректы</caption>
          <tbody> 
            <tr>
              <td>php artisan make:controller UserController</td>
              <td>создать контроллер</td>
            </tr>
            <tr>
              <td>php artisan make:controller ProvisionServer --invokable</td>
              <td>создать контроллер одного действия</td>
            </tr>
            <tr>
              <td>php artisan make:controller PhotoController --resource</td>
              <td>создать ресурсный контроллер</td>
            </tr>
            <tr>
              <td>php artisan make:controller PhotoController -r</td>
              <td>создать ресурсный контроллер</td>
            </tr>
            <tr>
              <td>php artisan make:controller PhotoController --model=Photo --resource --requests</td>
              <td>с привязкой к моделе и валидацией</td>
            </tr>
            <tr>
              <td>php artisan make:controller PhotoController --api</td>
              <td>api-контроллер контроллер без create и edit</td>
            </tr>
          </tbody>
        </table>
        <table>
          <thead>
            <tr>
              <th>Controller Method</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>index</td>
              <td>view all</td>
            </tr>
            <tr>
              <td>show</td>
              <td>view one</td>
            </tr>
            <tr>
              <td>create</td>
              <td>show form for create</td>
            </tr>
            <tr>
              <td>store</td>
              <td>create</td>
            </tr>
            <tr>
              <td>edit</td>
              <td>show form for edit</td>
            </tr>
            <tr>
              <td>update</td>
              <td>update</td>
            </tr>
            <tr>
              <td>destroy</td>
              <td>delete</td>
            </tr>
          </tbody>
        </table>
        <p>в контроллере</p>
        <pre><code>// избежать проблему n+1: with([ ])
public function __invoke()
{
  $jobs = Job::query()->with(['employer', 'tags'])->where('title', 'LIKE', '%'.request('q').'%')->get();
  return view('results', ['jobs' => $jobs]);
}

// указать middleware в контроллере
class UserController extends Controller implements HasMiddleware
{
  public static function middleware(): array
  {
    return [
      'auth',
      new Middleware('log', only: ['index']),
      new Middleware('subscribed', except: ['store']),
    ];
  }
}

// реализовать middleware в контроллере
public static function middleware(): array
{
  return [
    function (Request $request, Closure $next) {
      return $next($request);
    },
  ];
}

// внедрить зависимости через конструктор
use App\Repositories\UserRepository;
class UserController extends Controller
{
  public function __construct(protected UserRepository $users) { }
}

// внедрить зависимости через параметры функции
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class UserController extends Controller
{
  public function store(Request $request): RedirectResponse
  {
    $name = $request->name;
    return redirect('/users');
  }
}
</code></pre>
        <p>получить параметр из маршрута</p>
        <pre><code>// маршрут
use App\Http\Controllers\UserController;
Route::put('/user/{id}', [UserController::class, 'update']);

// контроллер
class UserController extends Controller
{
  public function update(Request $request, string $id): RedirectResponse
  {
    // действия с пользователем
    return redirect('/users');
  }
}
</code></pre>
        <p>Authentication - проверка, что пользователь тот, за кого себя выдает</p>
        <ul>
          <li>конфигурация в config/auth.php, в массиве guards 'охранники' для аутентификации пользователя</li>
          <li>информацию об аутентифицированном пользователе хранится в сессии пользователя</li>
          <li>файл cookie, отправленный браузеру, содержит идентификатор сессии, чтобы последующие запросы к приложению могли связать пользователя с правильной сессией</li>
          <li>встроенные службы аутентификации Laravel для запросов из веб-браузеров и доступны через фасады Auth и Session</li>
          <li>встроенные службы аутентификации ориентированы на web-аутентификацию на основе файлов cookie</li>
          <li>Fortify - серверная служба аутентификации</li>
          <li>при каждом запросе к API удаленная служба отправляет API-токен, приложение проверяет входящий токен по таблице допустимых API-токенов и «аутентифицирует» запрос как выполняемый пользователем, связанным с этим API-токеном</li>
          <li>библиотеки Passport и Sanctum ориентированы на аутентификацию токена API</li>
          <li>Passport – надежный и сложный пакет для аутентификации API, когда нужен весь функционал OAuth2</li>
          <li>Sanctum –  простое и полное решение для аутентификации API, аутентификации SPA и мобильной аутентификации, включая поддержку «scopes» или «abilities»</li>
          <li>Laravel автоматически хеширует пароли пользователей при аутентификации</li>
          <li>настроить сложность хеширования в config/hashing.php или в BCRYPT_ROUNDS из .env</li>
        </ul>
        <table>
          <tbody>
            <tr>
              <td>php artisan config:publish hashing</td>
              <td>опубликовать config/hashing.php</td>
            </tr>
            <tr>
              <td>'rehash_on_login' => false</td>
              <td>отключить автоматическое хеширование</td>
            </tr>
          </tbody>
        </table>
        <p>"запомнить меня" - аутентифицирован до выхода из системы вручную, столбец remember_token в таблице users</p>
        <table>
          <caption>встроенная аутентификация: use Illuminate\Support\Facades\Auth;</caption>
          <tbody>
            <tr>
              <td>$user = Auth::user();</td>
              <td>получить текущего аутентифицированного пользователя</td>
            </tr>
            <tr>
              <td>$id = Auth::id();</td>
              <td>получить текущего аутентифицированного пользователя по идентификатору</td>
            </tr>
            <tr>
              <td>$user = $request->user();</td>
              <td>получить текущего аутентифицированного пользователя из запроса</td>
            </tr>
            <tr>
              <td>if (Auth::check()) { }</td>
              <td>проверить что пользователь аутентифицировался</td>
            </tr>
            <tr>
              <td>if (Auth::guard('admin')->attempt($credentials)) { }</td>
              <td>с указанием guard из config/auth.php</td>
            </tr>
            <tr>
              <td>if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) { }</td>
              <td>параметр "запомнить меня"</td>
            </tr>
            <tr>
              <td>if (Auth::viaRemember()) { }</td>
              <td>есть ли "запомнить меня"</td>
            </tr>
            <tr>
              <td>if (Auth::once($credentials)) { }</td>
              <td>аутентификации пользователя только для одного запроса без сессии и cookie</td>
            </tr>
            <tr>
              <td>Auth::login($user);</td>
              <td>передать пользователя на аутентификацию</td>
            </tr>
            <tr>
              <td>Auth::login($user, $remember = true);</td>
              <td>передать пользователя на аутентификацию с "запомнить меня"</td>
            </tr>
            <tr>
              <td>Auth::guard('admin')->login($user);</td>
              <td>передать пользователя на аутентификацию с указанием guard</td>
            </tr>
            <tr>
              <td>Auth::loginUsingId(1);</td>
              <td>аутентификация по id</td>
            </tr>
            <tr>
              <td>Auth::loginUsingId(1, remember: true);</td>
              <td>аутентификация по id с "запомнить меня"</td>
            </tr>
          </tbody>
        </table>
        <p>Basic HTTP - аутентификация без cookie и страницы входа</p>
        <pre><code>Route::get('/profile', function () { })->middleware('auth.basic');

//  добавить в .htaccess для HTTP Basic и PHP FastCGI
RewriteCond %{HTTP:Authorization} ^(.+)$
RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]

//  использовать в middleware
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Symfony\Component\HttpFoundation\Response;
class AuthenticateOnceWithBasicAuth
{
  public function handle(Request $request, Closure $next): Response
  {return Auth::onceBasic() ?: $next($request);}
}

// далее
Route::get('/api/user', function () { })->middleware(AuthenticateOnceWithBasicAuth::class);
</code></pre>
        <p>выход пользователя из приложения</p>
        <pre><code>public function logout(Request $request): RedirectResponse
{
  // удалить информацию аутентификации из сессии пользователя
  Auth::logout();

  // аннулировать сессию пользователя
  $request->session()->invalidate();

  // повторно сгенерировать токен CSRF пользователя
  $request->session()->regenerateToken();

  return redirect('/');
}
</code></pre>
        <p>аннулировать сессии на других устройствах, без аннулирования сессии на текущем устройстве</p>
        <pre><code>// в маршруте
Route::middleware(['auth', 'auth.session'])->group(function () {
  Route::get('/', function () { });
});

// в контроллере
Auth::logoutOtherDevices($currentPassword);
</code></pre>
        <p>настроить время, через которое нужно повторно ввести пароль: password_timeout в config/auth.php</p>
        <pre><code>// форма подтверждения пароля
Route::get('/confirm-password', function () {
  return view('auth.confirm-password');
})->middleware('auth')->name('password.confirm');

// далее
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Redirect;
Route::post('/confirm-password', function (Request $request) {
  if (! Hash::check($request->password, $request->user()->password)) {
    return back()->withErrors([
      'password' => ['Предоставленный пароль не соответствует нашим записям.']
    ]);
  }
  $request->session()->passwordConfirmed();
  return redirect()->intended();
})->middleware(['auth', 'throttle:6,1']);

// далее
Route::get('/settings', function () { })->middleware(['password.confirm']);
Route::post('/settings', function () { })->middleware(['password.confirm']);
</code></pre>
        <p>добавить свой guard</p>
        <pre><code>namespace App\Providers;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {
    Auth::viaRequest('custom-token', function (Request $request) {
      return User::where('token', (string) $request->token)->first();
    });
  }
}

// в config/auth.php
'guards' => [
  'api' => [
    'driver' => 'jwt',
    'provider' => 'users',
  ],
],

// либо
'guards' => [
  'api' => [
    'driver' => 'custom-token',
  ],
],

// в маршруте
Route::middleware('auth:api')->group(function () { });
</code></pre>
        <p>свой провайдер аутентификации пользователей для нереляционной БД</p>
        <pre><code>namespace App\Providers;
use App\Extensions\MongoUserProvider;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {
    Auth::provider('mongo', function (Application $app, array $config) {
      return new MongoUserProvider($app->make('mongo.connection'));
    });
  }
}

// в config/auth.php
'providers' => [
  'users' => [
    'driver' => 'mongo',
  ],
],
'guards' => [
  'web' => [
    'driver' => 'session',
    'provider' => 'users',
  ],
]
</code></pre>
        <p>собственная аутентификации пользователей</p>
        <pre><code>namespace App\Http\Controllers;
use Illuminate\Http\Request;
use Illuminate\Http\RedirectResponse;
use Illuminate\Support\Facades\Auth;
class LoginController extends Controller
{
  public function authenticate(Request $request): RedirectResponse
  {
    $credentials = $request->validate([
      'email' => ['required', 'email'],
      'password' => ['required'],
    ]);
    if (Auth::attempt($credentials)) {
      $request->session()->regenerate();
      return redirect()->intended('dashboard');
    }
    return back()->withErrors([
      'email' => 'Предоставленные учетные данные не соответствуют нашим записям.',
    ])->onlyInput('email');
  }
}
// Дополнительные условия аутентификации
if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) { }

// либо
use Illuminate\Database\Eloquent\Builder;
if (Auth::attempt([
  'email' => $email,
  'password' => $password,
  fn (Builder $query) => $query->has('activeSubscription'),
])) { }

// либо
if (Auth::attemptWhen([
  'email' => $email,
  'password' => $password,
], function (User $user) {return $user->isNotBanned();})) { }
</code></pre>
        <p>Email verification - автоматическая отправка электронного письма со ссылкой для подтверждения</p>
        <pre><code>namespace App\Models;

use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable implements MustVerifyEmail
{
  use Notifiable;
}

// при регистрации пользователя вручную
use Illuminate\Auth\Events\Registered;
event(new Registered($user));
</code></pre>
        <p>в таблице users миграции 0001_01_01_000000_create_users_table.php столбец столбец email_verified_at для даты и времени подтверждения email</p>
        <p>Чтобы правильно реализовать подтверждение электронной почты, необходимо определить три маршрута:</p>
        <pre><code>// отображения пользователю уведомления об отправке ссылки подтверждения
Route::get('/email/verify', function () {
  return view('auth.verify-email');
})->middleware('auth')->name('verification.notice');

// обработки запроса при нажатии на ссылку подтверждения
use Illuminate\Foundation\Auth\EmailVerificationRequest;

Route::get('/email/verify/{id}/{hash}', function (EmailVerificationRequest $request) {
  $request->fulfill();
  return redirect('/home');
})->middleware(['auth', 'signed'])->name('verification.verify');

// повторная отправка ссылки подтверждения
use Illuminate\Http\Request;

Route::post('/email/verification-notification', function (Request $request) {
  $request->user()->sendEmailVerificationNotification();
  return back()->with('message', 'Verification link sent!');
})->middleware(['auth', 'throttle:6,1'])->name('verification.send');

// изменить сообщение о подтверждении в App\Providers\AppServiceProvider
use Illuminate\Auth\Notifications\VerifyEmail;
use Illuminate\Notifications\Messages\MailMessage;

public function boot(): void
{
  VerifyEmail::toMailUsing(function (object $notifiable, string $url) {
    return (new MailMessage)
      ->subject('Verify Email Address')
      ->line('Click the button below to verify your email address.')
      ->action('Verify Email Address', $url);
  });
}
</code></pre>
        <p>Fortify - backend реализация authentication</p>
        <pre><code>// установить Fortify
./sail composer require laravel/fortify

// создать папки и роуты Fortify
./sail artisan fortify:install

// обновить БД
./sail artisan migrate
</code></pre>
        <p>Autherization - проверка прав доступа пользователя, основанная на политиках и шлюзах, может быть выполнена с помощью:</p>
        <ul>
          <li>middleware, контроллеров, моделей и шаблонов</li>
          <li>фасадов, классов и функций</li>
          <li>политик и шлюзов, которые могут быть определёны в любом месте приложения и использоваться вместе</li>
        </ul>
        <p>Gate (шлюз) - это функция проверки прав пользователя без использования модели или ресурса, например просмотр панели управления администратора.</p>
        <ul>
          <li>объявляется в AppProvidersAppServiceProvider методом boot()</li>
          <li>используется для простых ограничений ролей</li>
          <li>аргументом всегда принимает пользователя, к которому применяет ограничения</li>
          <li>методы шлюза для авторизации полномочий: allows, denies, check, any, none, authorize, can, cannot</li>
          <li>директивы авторизации Blade: @can, @cannot, @canany</li>
          <li>дополнительные аргументы по необходимости</li>
        </ul>
        <pre><code>namespace App\Providers;
use App\Models\Post;
use App\Models\User;
use Illuminate\Support\Facades\Gate;
class AppServiceProvider extends ServiceProvider

// может ли пользователь обновить модель

public function boot(): void
{
  Gate::define('update-post', function (User $user, Post $post) {
    return $user->id === $post->user_id;
  });
}

// либо вынести логику в отдельный класс (политику) и объявить в App\Providers\AppServiceProvider
use App\Policies\PostPolicy;
use Illuminate\Support\Facades\Gate;
public function boot(): void
{
  Gate::define('update-post', [PostPolicy::class, 'update']);
}
</code></pre>
        <table> 
          <tbody>
            <tr>
              <td>Gate::define</td>
              <td>объявляю Gate,</td>
            </tr>
            <tr>
              <td>'update-post'</td>
              <td>название возможности предоставляемой пользователю</td>
            </tr>
            <tr>
              <td>function (User $user, Post $post)</td>
              <td>вернёт true/false,</td>
            </tr>
            <tr>
              <td>true</td>
              <td>этому пользователю можно пользоваться этой возможностью</td>
            </tr>
            <tr>
              <td>false</td>
              <td>этому пользователю нельзя пользоваться этой возможностью</td>
            </tr>
          </tbody>
        </table>
        <p>После этого в любом контроллере можем проверять роль конкрено указав пользователя</p>
        <table>
          <tbody>
            <tr>
              <td>if (Gate::forUser($user)->allows('update-post', $post)) { }</td>
              <td>если может редактировать пост</td>
            </tr>
            <tr>
              <td>if (Gate::forUser($user)->denies('update-post', $post)) { }</td>
              <td>если не может редактировать пост</td>
            </tr>
            <tr>
              <td>if (Gate::allows('update-post', $post)) { }</td>
              <td>если разрешено</td>
            </tr>
            <tr>
              <td>if (Gate::denies('update-post', $post)) {abort(403);}</td>
              <td>если запрещено</td>
            </tr>
            <tr>
              <td>if (Gate::any(['update-post', 'delete-post'], $post)) { }</td>
              <td>если может редактировать и удалять</td>
            </tr>
            <tr>
              <td>if (Gate::none(['update-post', 'delete-post'], $post)) { }</td>
              <td>если не может редактировать и удалять</td>
            </tr>
            <tr>
              <td>if (Gate::check('create-post', [$category, $pinned])) { }</td>
              <td>дополнительный контекст для check</td>
            </tr>
            <tr>
              <td>Gate::authorize('update-post', $post);</td>
              <td>проверить роль текущего пользователя встроенным методом</td>
            </tr>
            <tr>
              <td>Gate::authorize('update', App\Models\Post::class);</td>
              <td>'update' - действие, $post - объект модели, либо класс модели</td>
            </tr>
            <tr>
              <td>Gate::allowIf(fn (User $user) => $user->isAdministrator());</td>
              <td>встроенная роверка авторизации</td>
            </tr>
            <tr>
              <td>Gate::denyIf(fn (User $user) => $user->banned());</td>
              <td>встроенная роверка авторизации</td>
            </tr>
          </tbody>
        </table>
        <p>авторизация действий через шлюзы</p>
        <pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Gate;
class PostController extends Controller
{
  public function update(Request $request, Post $post): RedirectResponse
  {
    if (! Gate::allows('update-post', $post)) {abort(403);}
    return redirect('/posts');
  }
}

// либо
public function update(Request $request, Post $post): RedirectResponse
{
  // если пользователь не авторизован для 'update', то выбросит исключение
  Gate::authorize('update', $post);
  return redirect('/posts');
}

// либо
public function create(Request $request): RedirectResponse
{
  // класс определяет какую политику использовать при авторизации
  Gate::authorize('create', Post::class);
  return redirect('/posts');
}

// дополнительный контекст при принятии решений об авторизации
Gate::define('create-post', function (User $user, Category $category, bool $pinned) {
  if (! $user->canPublishToGroup($category->group)) {return false;}
  elseif ($pinned && ! $user->canPinPosts()) {return false;}
  return true;
});

// ответ шлюза
use App\Models\User;
use Illuminate\Auth\Access\Response;
use Illuminate\Support\Facades\Gate;
Gate::define('edit-settings', function (User $user) {
  return $user->isAdmin ? Response::allow() : Response::deny('Вы должны быть администратором.');
});

//  полный возвращенный шлюзом ответ
$response = Gate::inspect('edit-settings');
if ($response->allowed()) { }
else {echo $response->message();}

//  код статуса HTTP-ответа вручную
Gate::define('edit-settings', function (User $user) {
  return $user->isAdmin ? Response::allow() : Response::denyWithStatus(404);
});

//  ответ 404
Gate::define('edit-settings', function (User $user) {
  return $user->isAdmin ? Response::allow() : Response::denyAsNotFound();
});

//  before выполняется перед всеми другими проверками авторизации
Gate::before(function (User $user, string $ability) {
  if ($user->isAdministrator()) {return true;}
});

//  after выполняется после всех других проверок авторизации
Gate::after(function (User $user, string $ability, bool|null $result, mixed $arguments) {
  if ($user->isAdministrator()) {return true;}
});
</code></pre>
        <p>Policies</p>
        <ul>
          <li>политики - это классы с логикой авторизации пользователя на действия с конкретной моделью или ресурсом.</li>
          <li>по конвенции название политики содержит название модели.</li>
          <li>Laravel проверит наличие политик в app/Models/Policies, а затем в app/Policies.</li>
        </ul>
        <pre><code>// создать политику с привязкой к модели: создаст методы для модели Post
php artisan make:policy PostPolicy --model=Post
</code></pre>
        <table>
          <thead>
            <tr>
              <th>Policy Method</th>
              <th>Action</th>
            </tr>
          </thead>
          <tbody> 
            <tr>
              <td>viewAny</td>
              <td>view all</td>
            </tr>
            <tr>
              <td>view</td>
              <td>view one</td>
            </tr>
            <tr>
              <td>create</td>
              <td>create & store</td>
            </tr>
            <tr>
              <td>update</td>
              <td> edit</td>
            </tr>
            <tr>
              <td>delete</td>
              <td>mark as delete</td>
            </tr>
            <tr>
              <td>restore</td>
              <td>unmark as delete</td>
            </tr>
            <tr>
              <td>forceDelete</td>
              <td>permanently delete</td>
            </tr>
          </tbody>
        </table>
        <p>Назвать политику не по конвенции:</p>
        <pre><code>namespace App\Providers;
use App\Models\ModelName;
use App\Policies\PolicyName;
use Illuminate\Support\Facades\Gate;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void
  {
    Gate::policy(Order::class, OrderPolicy::class);
  }
}

// использовать
Gate::guessPolicyNamesUsing(function (string $modelClass) { });
</code></pre>
        <p>политика</p>
        <pre><code>namespace App\Policies;
use App\Models\Post;
use App\Models\User;
class PostPolicy
{
  public function update(User $user, Post $post): bool
  {
    return $user->id === $post->user_id;
  }
}
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>return $user->id === $post->user_id ? Response::allow() : Response::deny('You do not own this post.');</td>
              <td>подробный ответ</td>
            </tr>
            <tr>
              <td>return $user->id === $post->user_id ? Response::allow() : Response::denyWithStatus(404);</td>
              <td>настроить HTTP-ответ</td>
            </tr>
            <tr>
              <td>return $user->id === $post->user_id ? Response::allow() : Response::denyAsNotFound();</td>
              <td>встроенный ответ 404</td>
            </tr>
            <tr>
              <td>return $user->role == 'writer';</td>
              <td>имеет ли пользователь право создавать посты</td>
            </tr>
            <tr>
              <td>return $user?->id === $post->user_id;</td>
              <td>$user типа User либо null: авторизация для не аутентифицированных пользователей</td>
            </tr>
            <tr>
              <td>return $user->id === $post->user_id && $user->canUpdateCategory($category);</td>
              <td>проверка id и роли пользователя</td>
            </tr>
            <tr>
              <td>Gate::authorize('update', [$post, $request->category]);</td>
              <td>передать методу дополнительный контекст в массиве</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// before будет выполнен перед любыми другими методами в политике
public function before(User $user, string $ability): bool|null
{
  // выполнить предварительную авторизацию
  if ($user->isAdministrator()) {return true;}
  return null;
}
</code></pre>
        <p>Controller</p>
        <ul>
          <li>модель AppModelsUser включает два метода авторизации: can и cannot</li>
          <li>если для модели зарегистрирована политика, то can вызовет политику</li>
          <li>если нет политики, то can вызовет шлюз</li>
        </ul>
        <pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Models\Post;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class PostController extends Controller
{
  public function update(Request $request, Post $post): RedirectResponse
  {
    if ($request->user()->cannot('update', $post)) {abort(403);}
    return redirect('/posts');
  }
}
public function store(Request $request): RedirectResponse
{
  // имя класса определяет используемую политику
  if ($request->user()->cannot('create', Post::class)) {abort(403);}
  return redirect('/posts');
}
</code></pre>
        <p>Requests - запросы позволяют создавать правила валидации, авторизации и преобразования данных в контроллерах, маршрутах и сервисах</p>
        <table>
          <tbody>
            <tr>
              <td>php artisan make:request StoreUserRequest</td>
              <td>создать запрос</td>
            </tr>
            <tr>
              <td>php artisan make:request StoreUserRequest --rules=store</td>
              <td>создать запрос с правилами валидации</td>
            </tr>
            <tr>
              <td>php artisan make:request App\Http\Requests\StoreUserRequest</td>
              <td>указать путь к классу</td>
            </tr>
            <tr>
              <td>php artisan make:request App\Http\Requests\StoreUserRequest --namespace=App\Http\Requests</td>
              <td>указать путь к классу и пространство имен</td>
            </tr>
          </tbody>
        </table>
        <p>в запросе App/Http/Requests</p>
        <pre><code>// если логика авторизации обрабатывается в другом месте
public function authorize(): bool {return true;}

//  авторизация запросов
use App\Models\Comment;
public function authorize(): bool
{
  // route() - доступ к параметрам URI
  $comment = Comment::find($this->route('comment'));

  // user() - текущй аутентифицированный пользователь
  return $comment && $this->user()->can('update', $comment);
}

// либо с привязкой модели к маршруту
return $this->user()->can('update', $this->comment);

//  изменить сообщения об ошибках
public function messages(): array
{
  return [
    'title.required' => 'A title is required',
    'body.required' => 'A message is required',
  ];
}

//  изменить имя атрибута
public function attributes(): array
{return ['email' => 'email address'];}

//  подготовить данные из запроса для валидации
use Illuminate\Support\Str;
protected function prepareForValidation(): void
{$this->merge(['slug' => Str::slug($this->slug)]);}

//  получить отвалидированные данные
$validated = $request->validated();

// либо через валидатор
$validated = $validator->validated();

// либо метод safe вернёт экземпляр Illuminate\Support\ValidatedInput с методами only, except, и all
$validated = $request->safe()->only(['name', 'email']);
$validated = $request->safe()->except(['name', 'email']);
$validated = $request->safe()->all();

//  итерировать проверенные данные
foreach ($request->safe() as $key => $value) { }

//  доступ к проверенным данным как в массиве
$validated = $request->safe();
$email = $validated['email'];

//  добавить поля к проверенным данным
$validated = $request->safe()->merge(['name' => 'Taylor Otwell']);

//  получить проверенные данные в виде экземпляра collection
$collection = $request->safe()->collect();

//  нормализовать данные после валидации
protected function passedValidation(): void
{$this->replace(['name' => 'Taylor']);}
</code></pre>
        <table>
          <caption>данные формы ввода</caption>
          <tbody>
            <tr>
              <td>$input = $request->all();</td>
              <td>все данные в виде массива</td>
            </tr>
            <tr>
              <td>$input = $request->collect();</td>
              <td>все данные в виде коллекции</td>
            </tr>
            <tr>
              <td>$input = $request->input();</td>
              <td>все данные как ассоциированный массив</td>
            </tr>
            <tr>
              <td>$name = $request->input('name', 'Sally');</td>
              <td>данные одного поля, второй параметр - значение по умолчанию</td>
            </tr>
            <tr>
              <td>$name = $request->input('products.0.name');</td>
              <td>получить элемент из массива данных формы</td>
            </tr>
            <tr>
              <td>$names = $request->input('products.*.name');</td>
              <td>получить по указанному фильтру массив из массива данных формы</td>
            </tr>
            <tr>
              <td>$query = $request->query();</td>
              <td>все данные из строки запроса в виде ассоциативного массива</td>
            </tr>
            <tr>
              <td>$name = $request->query('name', 'Helen');</td>
              <td>данные отдельного параметра из строки запроса, второй параметр - значение по умолчанию</td>
            </tr>
            <tr>
              <td>$name = $request->string('name')->trim();</td>
              <td>в виде объекта String</td>
            </tr>
            <tr>
              <td>$perPage = $request->integer('per_page');</td>
              <td>в виде целого числа</td>
            </tr>
            <tr>
              <td>$archived = $request->boolean('archived');</td>
              <td>в логическом виде</td>
            </tr>
            <tr>
              <td>$elapsed = $request->date('elapsed', '!H:i', 'Europe/Madrid');</td>
              <td>дата - имя параметра, формат вывода и часовой пояс</td>
            </tr>
            <tr>
              <td>$status = $request->enum('status', Status::class);</td>
              <td>перечисление - имя параметра и класс перечислений</td>
            </tr>
            <tr>
              <td>$products = $request->enums('products', Product::class);</td>
              <td>перечисления в виде массива</td>
            </tr>
            <tr>
              <td>$input = $request->only(['username', 'password']);</td>
              <td>получить только указанный массив</td>
            </tr>
            <tr>
              <td>$input = $request->only('username', 'password');</td>
              <td>получить только указанный список</td>
            </tr>
            <tr>
              <td>$input = $request->except(['credit_card']);</td>
              <td>получить всё кроме указанного массива</td>
            </tr>
            <tr>
              <td>$input = $request->except('credit_card');</td>
              <td>получить всё кроме указанного списка</td>
            </tr>
            <tr>
              <td>if ($request->has('name')) { }</td>
              <td>если есть параметр в запросе</td>
            </tr>
            <tr>
              <td>if ($request->has(['name', 'email'])) { }</td>
              <td>если есть в запросе все параметры из массива</td>
            </tr>
            <tr>
              <td>if ($request->hasAny(['name', 'email'])) { }</td>
              <td>если есть в запросе любой параметр из массива</td>
            </tr>
            <tr>
              <td>$request->whenHas('name', function (string $input) { });</td>
              <td>выполнить функцию если в запросе параметр есть</td>
            </tr>
            <tr>
              <td>$request->whenHas('name', function (string $input) { }, function () { });</td>
              <td>выполнить первую функцию если в запросе параметр есть, вторую если нет</td>
            </tr>
            <tr>
              <td>if ($request->filled('name')) { }</td>
              <td>проверить есть ли значение</td>
            </tr>
            <tr>
              <td>if ($request->isNotFilled('name')) { }</td>
              <td>проверить отсутствие значения или пустая строка</td>
            </tr>
            <tr>
              <td>if ($request->isNotFilled(['name', 'email'])) { }</td>
              <td>все ли отсутствуют или пустые</td>
            </tr>
            <tr>
              <td>if ($request->anyFilled(['name', 'email'])) { }</td>
              <td>true если хоть один не пустой</td>
            </tr>
            <tr>
              <td>$request->whenFilled('name', function (string $input) { });</td>
              <td>если не пустой, то выполнит действие</td>
            </tr>
            <tr>
              <td>$request->whenFilled('name', function (string $input) { }, function () { });</td>
              <td>если нет значения, то выполнить второе действие</td>
            </tr>
            <tr>
              <td>if ($request->missing('name')) { }</td>
              <td>проверить существует ли ключ параметра в запросе</td>
            </tr>
            <tr>
              <td>$request->whenMissing('name', function () { }, function () { });</td>
              <td>если отсутствует, то первое действие, если присутствует - то второе</td>
            </tr>
            <tr>
              <td>$request->merge(['votes' => 0]);</td>
              <td>объединить существующие данные запроса с данными из ввода с перезаписью по ключу</td>
            </tr>
            <tr>
              <td>$request->mergeIfMissing(['votes' => 0]);</td>
              <td>добавить в запрос данные из ввода если в запросе такого ключа нет</td>
            </tr>
            <tr>
              <td>$request->flash();</td>
              <td>сохранить входные данные запроса в сессии, для доступа только во время следующего запроса</td>
            </tr>
            <tr>
              <td>$request->flashOnly(['username', 'email']);</td>
              <td>сохранить в сессии входные данные запроса только по указанным ключам</td>
            </tr>
            <tr>
              <td>$request->flashExcept('password');</td>
              <td>сохранить в сессии входные данные запроса кроме указанного ключа</td>
            </tr>
            <tr>
              <td>return redirect('/form')->withInput();</td>
              <td>сохранить в сессии входные данные запроса и вернуть к форме</td>
            </tr>
            <tr>
              <td>return redirect()->route('user.create')->withInput();</td>
              <td>сохранить в сессии входные данные запроса и перенаправить по маршруту</td>
            </tr>
            <tr>
              <td>return redirect('/form')->withInput($request->except('password'));</td>
              <td>сохранить в сессии входные данные запроса кроме указанного ключа и вернуть к форме</td>
            </tr>
            <tr>
              <td>$username = $request->old('username');</td>
              <td>получить данные предыдущего запроса</td>
            </tr>
            <tr>
              <td>< input type="text" name="username" value="{{ old('username') }}"></td>
              <td>получить данные предыдущего запроса в шаблоне Blade</td>
            </tr>
            <tr>
              <td>$value = $request->cookie('name');</td>
              <td>получить значение cookie</td>
            </tr>
            <tr>
              <td>$file = $request->file('photo');</td>
              <td>получить файл из запроса</td>
            </tr>
            <tr>
              <td>$file = $request->photo;</td>
              <td>получить файл из запроса динамически</td>
            </tr>
            <tr>
              <td>if ($request->hasFile('photo')) { }</td>
              <td>проверить если файл в запросе</td>
            </tr>
            <tr>
              <td>if ($request->file('photo')->isValid()) { }</td>
              <td>валидация загрузки файла</td>
            </tr>
            <tr>
              <td>$path = $request->photo->path();</td>
              <td>доступ к пути файла</td>
            </tr>
            <tr>
              <td>$extension = $request->photo->extension();</td>
              <td>доступ к расширению файла</td>
            </tr>
          </tbody>
        </table>
        <table> 
          <caption>сохранить файл из запроса</caption>
          <tbody> 
            <tr>
              <td>$path = $request->photo->store('images', 's3');</td>
              <td>имя файла автоматически, 's3' - имя диска сохранения (необязательный)</td>
            </tr>
            <tr>
              <td>$path = $request->photo->storeAs('images', 'filename.jpg', 's3');</td>
              <td>задать имя файла</td>
            </tr>
          </tbody>
        </table>
        <p>сообщение об ошибке</p>
        <table> 
          <caption>$validator - экземпляр Illuminate\Support\Facades\Validator</caption>
          <tbody> 
            <tr>
              <td>$errors = $validator->errors();</td>
              <td>вернёт экземпляр Illuminate\Support\MessageBag</td>
            </tr>
            <tr>
              <td>echo $errors->first('email');</td>
              <td>получить первое сообщение об ошибке для указанного поля</td>
            </tr>
          </tbody>
        </table>
        <table> 
          <caption>Illuminate\Support\MessageBag - набор методов для работы с сообщениями об ошибках</caption>
          <tbody>
            <tr>
              <td>foreach ($errors->get('email') as $message) { }</td>
              <td>получить массив всех сообщений для указанного поля</td>
            </tr>
            <tr>
              <td>foreach ($errors->get('attachments.*') as $message) { }</td>
              <td>получить все сообщения для каждого из элементов массива</td>
            </tr>
            <tr>
              <td>foreach ($errors->all() as $message) { }</td>
              <td>получить массив всех сообщений для всех полей</td>
            </tr>
            <tr>
              <td>if ($errors->has('email')) { }</td>
              <td>проверить наличие сообщений об ошибках для указанного поля</td>
            </tr>
          </tbody>
        </table>
        <p>при ошибке, Laravel запишет ошибки и входящие данные запроса в массив $errors сессии</p>
        <pre><code>// /resources/views/post/create.blade.php
< h1>Создание поста блога< /h1>
@if ($errors->any())
  < div class="alert alert-danger">
    < ul>
      @foreach ($errors->all() as $error)
        < li>{{ $error }}< /li>
      @endforeach
    < /ul>
  < /div>
@endif

// проверить наличие ошибок и вывести
< label for="title">Название сообщения< /label>
< input
  id="title"
  type="text"
  name="title"
  class="@error('title') is-invalid @enderror"
/>
@error('title')
  < div class="alert alert-danger">{{ $message }}< /div>
@enderror

// перезаполнить форму данными предыдущего запроса из сессии
$title = $request->old('title');

// либо
< input type="text" name="title" value="{{ old('title') }}">
</code></pre>
        <p>доступ к запросу</p>
        <pre><code>// в контроллере
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
class UserController extends Controller
{
  public function store(Request $request): RedirectResponse
  {
    $name = $request->input('name');
    return redirect('/users');
  }
}

// в маршруте
Route::get('/', function (Request $request) { });
</code></pre>
        <table>
          <caption>путь запроса</caption>
          <tbody>
            <tr>
              <td>$uri = $request->path();</td>
              <td>получить путь запроса</td>
            </tr>
            <tr>
              <td>if ($request->is('admin/*')) {}</td>
              <td>соответствие пути запроса шаблону</td>
            </tr>
            <tr>
              <td>if ($request->routeIs('admin.*')) {}</td>
              <td>соответствие пути запроса именованному маршруту</td>
            </tr>
            <tr>
              <td>$url = $request->url();</td>
              <td>получить URL для входящего запроса</td>
            </tr>
            <tr>
              <td>$urlWithQueryString = $request->fullUrl();</td>
              <td>получить полный URL для входящего запроса</td>
            </tr>
            <tr>
              <td>$request->fullUrlWithQuery(['type' => 'phone']);</td>
              <td>добавить строку запроса в массив переменных строки запроса</td>
            </tr>
            <tr>
              <td>$request->fullUrlWithoutQuery(['type']);</td>
              <td>получить строку запроса без указанного параметра</td>
            </tr>
          </tbody>
        </table>
        <p>получить host входящего запроса</p>
        <pre><code>$request->host();
$request->httpHost();
$request->schemeAndHttpHost();
</code></pre>
        <p>метод запроса</p>
        <table>
          <caption>данные формы могут быть отправлены в запросе с помощью метода GET, POST, PUT, PATCH, DELETE, OPTIONS, HEAD, TRACE, CONNECT</caption>
          <tbody>
            <tr>
              <td>$method = $request->method();</td>
              <td>получить</td>
            </tr>
            <tr>
              <td>if ($request->isMethod('post')) { }</td>
              <td>проверить</td>
            </tr>
          </tbody>
        </table>
        <p>заголовок запроса</p>
        <ul>
          <li>получить из запроса данные JSON: заголовок Content-Type = application/json</li>
          <li>получить из запроса данные формы: заголовок Content-Type = application/x-www-form-urlencoded</li>
        </ul>
        <table>
          <tbody>
            <tr>
              <td>$value = $request->header('X-Header-Name', 'default');</td>
              <td>второй параметр не обязательный</td>
            </tr>
            <tr>
              <td>if ($request->hasHeader('X-Header-Name')) { }</td>
              <td>проверить наличие заголовка</td>
            </tr>
            <tr>
              <td>$token = $request->bearerToken();</td>
              <td>получить токен из заголовка Authorization</td>
            </tr>
            <tr>
              <td>$ipAddress = $request->ip();</td>
              <td>получить ip-адрес клиента, который сделал запрос</td>
            </tr>
            <tr>
              <td>$ipAddresses = $request->ips();</td>
              <td>все ip-адреса с перенаправлением и прокси</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>тип контента в заголовке Accept</caption>
          <tbody>
            <tr>
              <td>$contentTypes = $request->getAcceptableContentTypes();</td>
              <td>получить массив типов контента, принятые запросом</td>
            </tr>
            <tr>
              <td>if ($request->accepts(['text/html', 'application/json'])) { }</td>
              <td>true если один из типов контента принят запросом, иначе false</td>
            </tr>
            <tr>
              <td>$preferred = $request->prefers(['text/html', 'application/json']);</td>
              <td>указать предпочитаемый для запроса тип контента из массива</td>
            </tr>
            <tr>
              <td>if ($request->expectsJson()) {}</td>
              <td>если ждём только JSON</td>
            </tr>
          </tbody>
        </table>
        <p>получить запрос в формате PSR-7</p>
        <pre><code>// установить зависимости
composer require symfony/psr-http-message-bridge
composer require nyholm/psr7

// интерфейс в маршрут или контроллер
use Psr\Http\Message\ServerRequestInterface;
Route::get('/', function (ServerRequestInterface $request) { });
</code></pre>
        <p>Validate - проверка данных на соответствие встроенным и пользовательских правилам</p>
        <pre><code>// валидация и авторизация данных
namespace App\Http\Requests;
use Illuminate\Foundation\Http\FormRequest;
class StoreUserRequest extends FormRequest
{
  public function authorize(): bool
  {return true;}
  public function rules(): array
  {return [
    'name' => 'required|string|max:255',
    'email' => 'required|string|email|max:255|unique:users',
    'password' => 'required|string|min:8|confirmed',
  ]};
}

// применение в контроллере
use App\Http\Requests\StoreUserRequest;
class UserController extends Controller
{
  public function store(StoreUserRequest $request): RedirectResponse
  {
    // использую уже валидированые данные
    return redirect('/users');
  }
}

// применение в маршруте
use App\Http\Requests\StoreUserRequest;
Route::post('/user', function (StoreUserRequest $request) {
  // использую уже валидированые данные
  return redirect('/users');
});
- применение в middleware
use App\Http\Requests\StoreUserRequest;
class StoreUserMiddleware
{
  public function handle(Request $request, Closure $next): Response
  {
    $request->validateWithBag('user', (new StoreUserRequest())->rules());
    return $next($request);
  }
}
</code></pre>
        <p>валидация в контроллере</p>
        <pre><code>// routes/web.php
use App\Http\Controllers\PostController;
Route::get('/post/create', [PostController::class, 'create']);
Route::post('/post', [PostController::class, 'store']);

// App\Http\Controllers\PostController.php
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\View\View;
class PostController extends Controller
{

  // показать форму для создания нового сообщения в блоге
  public function create(): View
  {return view('post.create');}

  // сохранить новую запись в блоге
  public function store(Request $request): RedirectResponse
  {
  $validated = $request->validate([
    'title' => 'required|unique:posts|max:255',
    'body' => 'required',
  ]);

  // либо
  $validatedData = $request->validate([
    'title' => ['required', 'unique:posts', 'max:255'],
    'body' => ['required'],
  ]);

  // либо сохранение любых сообщений об ошибках в именованную коллекцию ошибок
  $validatedData = $request->validateWithBag('post', [
    'title' => ['required', 'unique:posts', 'max:255'],
    'body' => ['required'],
  ]);
  return redirect('/posts');
  }
}

// bail: прекратить выполнение правил валидации для атрибута после первой ошибки
$request->validate([
  'title' => 'bail|required|unique:posts|max:255',
  'body' => 'required',
]);

// вложенные поля в HTTP-запросе
$request->validate([
  'title' => 'required|unique:posts|max:255',
  'author.name' => 'required',
  'author.description' => 'required',
]);

// экранировать символ
$request->validate([
  'title' => 'required|unique:posts|max:255',
  'v1\.0' => 'required',
]);

// необязательные поля помечать nullable
$request->validate([
  'title' => 'required|unique:posts|max:255',
  'body' => 'required',
  'publish_at' => 'nullable|date',
]);
</code></pre>
        <p>создать свой валидатор</p>
        <pre><code>$validator = Validator::make($request->all(), [
  'title' => 'required|unique:posts|max:255',
  'body' => 'required',
]);

// withErrors() - передать ошибки в $errors сессии
if ($validator->fails()) {
  return redirect('/post/create')
  ->withErrors($validator)->withInput();}

// прекратить валидацию всех атрибутов после возникновения первой ошибки
if ($validator->stopOnFirstFailure()->fails()) { }

// получить проверенные данные
$validated = $validator->validated();

// получить только указанные данные
$validated = $validator->safe()->only(['name', 'email']);

// получить все данные кроме указанных
$validated = $validator->safe()->except(['name', 'email']);

// для автоматического перенаправления вызвать validate()
Validator::make($request->all(), [
  'title' => 'required|unique:posts|max:255',
  'body' => 'required',
])->validate();

// свои сообщения об ошибках в валидаторе
$validator = Validator::make($input, $rules, $messages = [
  'required' => 'Поле :attribute является обязательным.',
]);

// сохранить сообщения об ошибках в именованной коллекции ошибок
Validator::make($request->all(), [
  'title' => 'required|unique:posts|max:255',
  'body' => 'required',
])->validateWithBag('post');

// свои имена для атрибутов валидатора
$validator = Validator::make($input, $rules, $messages, [
  'email' => 'Адрес электронной почты',
]);

// дополнительная валидация after()
$validator = Validator::make(/* ... */);
$validator->after(function ($validator) {
  if ($this->somethingElseIsInvalid()) {
    $validator->errors()->add('field', 'Что-то не так с этим полем!');
  }
});

// exclude_if - не проверять это поле, если указанное поле имеет заданное значение
$validator = Validator::make($data, [
  'has_appointment' => 'required|boolean',
  'appointment_date' => 'exclude_if:has_appointment,false|required|date',
  'doctor_name' => 'exclude_if:has_appointment,false|required|string',
]);

// exclude_unless - не проверять это поле, если указанное поле не имеет заданное значение
$validator = Validator::make($data, [
  'has_appointment' => 'required|boolean',
  'appointment_date' => 'exclude_unless:has_appointment,true|required|date',
  'doctor_name' => 'exclude_unless:has_appointment,true|required|string',
]);

// sometimes - проверить поле если оно существует
$validator = Validator::make($data, [
    'email' => 'sometimes|required|email',
]);
$validator = Validator::make($request->all(), ['photos.profile' => 'required|image']);  // HTTP-запрос содержит поле photos[profile]

//проверить каждый элемент массива
$validator = Validator::make($request->all(), [
  'person.*.email' => 'email|unique:users',
  'person.*.first_name' => 'required_with:person.*.last_name',
]);
</code></pre>
        <table>
          <caption>правила валидации</caption>
          <tbody>
            <tr>
              <td>php artisan make:rule Uppercase</td>
              <td>создать правило</td>
            </tr>
            <tr>
              <td>php artisan make:rule Uppercase --implicit</td>
              <td>создать правило для обязательного атрибута</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// в app/Rules/Uppercase.php
namespace App\Rules;
use Closure;
use Illuminate\Contracts\Validation\ValidationRule;
class Uppercase implements ValidationRule
{
  public function validate(string $attribute, mixed $value, Closure $fail): void
  {if (strtoupper($value) !== $value) {$fail('The :attribute must be uppercase.');}}
}

// применить правило
use App\Rules\Uppercase;
$request->validate(['name' => ['required', 'string', new Uppercase]]);

// вызвать локализацию сообщения об ошибке
if (strtoupper($value) !== $value) {$fail('validation.uppercase')->translate();}

// либо
$fail('validation.location')->translate(['value' => $this->value], 'fr')

// доступ к внешним данным из класса правил
namespace App\Rules;
use Illuminate\Contracts\Validation\DataAwareRule;
use Illuminate\Contracts\Validation\ValidationRule;
class Uppercase implements DataAwareRule, ValidationRule
{
  protected $data = [];
  public function setData(array $data): static
  {
    $this->data = $data;
    return $this;
  }
}

// доступ к экземпляру валидатора, выполняющему проверку
namespace App\Rules;
use Illuminate\Contracts\Validation\ValidationRule;
use Illuminate\Contracts\Validation\ValidatorAwareRule;
use Illuminate\Validation\Validator;
class Uppercase implements ValidationRule, ValidatorAwareRule
{
  protected $validator;
  public function setValidator(Validator $validator): static
  {
    $this->validator = $validator;
    return $this;
  }
}

// правило без создания класса через $fail
use Illuminate\Support\Facades\Validator;
use Closure;
$validator = Validator::make($request->all(), [
  'title' => ['required', 'max:255',
    function (string $attribute, mixed $value, Closure $fail) {
      if ($value === 'foo') {$fail("The {$attribute} is invalid.");}
    },
  ],
]);

// прекратить валидацию всех атрибутов после первой ошибки
protected $stopOnFirstFailure = true;

// перенаправить при ошибке вручную
protected $redirect = '/dashboard';

// либо
protected $redirectRoute = 'dashboard';
</code></pre>
        <table>
          <caption>именованные коллекции ошибок позволяют делить ошибки валидации на разные группы (экземпляр MessageBag)</caption>
          <tbody>
            <tr>
              <td>return redirect('/register')->withErrors($validator, 'login');</td>
              <td>задать имя коллекции ошибок</td>
            </tr>
            <tr>
              <td>{{ $errors->login->first('email') }}</td>
              <td>получить доступ к именованной коллекции из переменной $errors сессии</td>
            </tr>
          </tbody>
        </table>
        <p>
          каждое встроенное правило валидации Laravel содержит текст сообщения об ошибке в файле lang/en/validation.php</>
          свой перевод - скопируй lang/en/validation.php и отредактируй
        </p>
        <pre><code>//опубликовать сообщения по умолчанию
php artisan lang:publish

// - в resources/lang/ru/validation.php
'custom' => [
  'email' => [
    'required' => 'Нам нужно знать ваш адрес электронной почты!',
    'max' => 'Ваш адрес электронной почты слишком длинный!'
  ],
],
// заменить имя атрибута по умолчанию
'attributes' => ['email' => 'email address']

// пользовательские имена для атрибутов
Validator::make($request->all(), ['credit_card_number' => 'required_if:payment_type,cc']);

// в resources/lang/ru/validation.php
'values' => ['payment_type' => ['cc' => 'кредитная карта']],

// использование одного сообщения валидации для полей на основе массива
'custom' => [
  'person.*.email' => [
    'unique' => 'Each person must have a unique email address',
  ]
]
</code></pre>
        <p>проверка полей при условии</p>
        <pre><code>// создать валидатор
use Illuminate\Support\Facades\Validator;
$validator = Validator::make($request->all(), [
  'email' => 'required|email',
  'stars' => 'required|numeric',
]);
</code></pre>
        <ul>
          <li>условие проверки: reason - поле проверки, required|max:500 - правила проверки,</li>
          <li>function (Fluent $input) - условие, при котором проверяем</li>
        </ul>
        <pre><code>use Illuminate\Support\Fluent;
$validator->sometimes('reason', 'required|max:500', function (Fluent $input) {return $input->stars >= 100;});

// либо
$input = [
  'channels' => [
    ['type' => 'email', 'address' => 'abigail@example.com'],
    ['type' => 'url', 'address' => 'https://example.com'],
  ],
];
$validator->sometimes('channels.*.address', 'email', function (Fluent $input, Fluent $item) {
  return $item->type === 'email';
});
$validator->sometimes('channels.*.address', 'url', function (Fluent $input, Fluent $item) {
  return $item->type !== 'email';
});
</code></pre>
        <p>валидация массивов</p>
        <pre><code>use Illuminate\Support\Facades\Validator;
$input = [
  'user' => [
    'name' => 'Taylor Otwell',
    'username' => 'taylorotwell',
    'admin' => true,
  ],
];
// правило array - список разрешенных ключей массива
Validator::make($input, ['user' => 'array:name,username']);
</code></pre>
        <p>применить правила проверки к каждому элементу массива подлежащего проверке атрибута</p>
        <pre><code>use App\Rules\HasPermission;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;
$validator = Validator::make($request->all(), [
  'companies.*.id' => Rule::forEach(function (string|null $value, string $attribute) {
    return [
      Rule::exists(Company::class, 'id'),
      new HasPermission('manage-company', $value),
    ];
  }),
]);
</code></pre>
        <p>указать индекс или позицию элемента массива в сообщении об ошибке</p>
        <pre><code>use Illuminate\Support\Facades\Validator;
$input = [
  'photos' => [
    ['name' => 'BeachVacation.jpg', 'description' => 'Фото моего пляжного отдыха!'],
    ['name' => 'GrandCanyon.jpg', 'description' => '']
  ],
];
Validator::validate(
  $input,
  ['photos.*.description' => 'required'],
  ['photos.*.description.required' => 'Пожалуйста, укажите описание для фото № :position.']
);
</code></pre>
        <p>валидация файлов</p>
        <pre><code>// для файла
Validator::validate($input, ['attachment' => [
  'required', File::types(['mp3', 'wav'])->min(1024)->max(12 * 1024)],
]);

// либо с размерами kb, mb, gb и tb
File::image()->min('1kb')->max('10mb')

// для изображения
Validator::validate($input, [

  // dimensions - размер изображения
  'photo' => ['required',
    File::image()->min(1024)->max(12 * 1024)->dimensions(Rule::dimensions()->maxWidth(1000)->maxHeight(500))],
]);
</code></pre>
        <p>валидация паролей</p>
        <pre><code>use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rules\Password;
$validator = Validator::make($request->all(), ['password' => ['required', 'confirmed', Password::min(8)],]);
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>Password::min(8)</td>
              <td>не менее 8 символов</td>
            </tr>
            <tr>
              <td>Password::min(8)->letters()</td>
              <td>хотя бы одна буква</td>
            </tr>
            <tr>
              <td>Password::min(8)->mixedCase()</td>
              <td>хотя бы одна заглавная и одна строчная буква</td>
            </tr>
            <tr>
              <td>Password::min(8)->numbers()</td>
              <td>хотя бы одна цифра</td>
            </tr>
            <tr>
              <td>Password::min(8)->symbols()</td>
              <td>хотя бы один символ</td>
            </tr>
            <tr>
              <td>Password::min(8)->uncompromised()</td>
              <td>убедиться, что пароль не был скомпрометирован</td>
            </tr>
            <tr>
              <td>Password::min(8)->letters()->mixedCase()->numbers()->symbols()->uncompromised()</td>
              <td>все вместе</td>
            </tr>
          </tbody>
        </table>
        <p>указать правила проверки паролей по умолчанию в одном месте приложения</p>
        <pre><code>namespace App\Providers
use Illuminate\Validation\Rules\Password;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void
  {
    Password::defaults(function () {
      $rule = Password::min(8);
      return $this->app->isProduction() ? $rule->mixedCase()->uncompromised() : $rule;
    });
  }
}

// применить правила проверки паролей по умолчанию
'password' => ['required', Password::defaults()],
</code></pre>
        <p>
          HTTP Client - отправка HTTP запросов и интеграция с веб-службами.</br>
          API для HTTP-клиента Guzzle ориентированное на наиболее распространенные варианты использования
        </p>
        <pre><code>// для отправки использовать методы head, get, post, put, patch и delete фасада Http
use Illuminate\Support\Facades\Http;
$response = Http::get('http://example.com');

// получать доступ к данным ответа JSON
return Http::get('http://example.com/users/1')['name'];

// формировать URL-запросы с использованием шаблонов
Http::withUrlParameters([
  'endpoint' => 'https://laravel.com',
  'page' => 'docs',
  'version' => '11.x',
  'topic' => 'validation',
])->get('{+endpoint}/{page}/{version}/{topic}');

// получить информацию о сформированном экземпляре исходящего запроса
return Http::dd()->get('http://example.com');

// при запросах POST, PUT и PATCH обычно отправляются данные
use Illuminate\Support\Facades\Http;
$response = Http::post('http://example.com/users', [
  'name' => 'Steve',
  'role' => 'Network Administrator']);

// строка запроса в виде массива пар ключ/значение
$response = Http::get('http://example.com/users', ['name' => 'Taylor', 'page' => 1]);
// либо
Http::retry(3, 100)->withQueryParameters(['name' => 'Taylor', 'page' => 1])->get('http://example.com/users')

// запросы с передачей данных в URL-кодированной строке
$response = Http::asForm()->post('http://example.com/users', ['name' => 'Sara', 'role' => 'Privacy Consultant']);

// отправка необработанного тела запроса
$response = Http::withBody(base64_encode($photo), 'image/jpeg')->post('http://example.com/photo');
</code></pre>
        <p>отправлять файлы в запросах, состоящих из нескольких частей</p>
        <pre><code>// первый аргумент имя файла, второй - его содержимое, третий - будет считаться именем файла, четвертый - заголовки
$response = Http::attach(
  'attachment', file_get_contents('photo.jpg'), 'photo.jpg', ['Content-Type' => 'image/jpeg']
)->post('http://example.com/attachments');

// передать потоковый ресурс
$photo = fopen('photo.jpg', 'r');
$response = Http::attach('attachment', $photo, 'photo.jpg')->post('http://example.com/attachments');

// дополнительные параметры для исходящего запроса
$response = Http::withOptions(['debug' => true])->get('http://example.com/users');
</code></pre>
        <p>заголовки могут быть добавлены к запросам с помощью метода withHeaders</p>
        <pre><code>$response = Http::withHeaders(['X-First' => 'foo', 'X-Second' => 'bar'])
  ->post('http://example.com/users', ['name' => 'Taylor']);

// указать тип контента, который ожидаем в ответ
$response = Http::accept('application/json')->get('http://example.com/users');

// указать, что приложение ожидает тип содержимого application/json
$response = Http::acceptJson()->get('http://example.com/users');

// заменить все заголовки
$response = Http::withHeaders(['X-Original' => 'foo'])->replaceHeaders(['X-Replacement' => 'bar'])
  ->post('http://example.com/users', ['name' => 'Taylor']);
</code></pre>
        <p>аутентификация</p>
        <pre><code>// Basic HTTP-аутентификация
$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(/* ... */);

// Digest HTTP-аутентификациия
$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(/* ... */);

// добавить токен в заголовок Authorization запроса
$response = Http::withToken('token')->post(/* ... */);
</code></pre>
        <p>время ожидания ответа в секундах (по умолчанию 30)</p>
        <pre><code>$response = Http::timeout(3)->get(/* ... */);

// время ожидания при подключению к серверу
$response = Http::connectTimeout(3)->get(/* ... */);

// автоматический повтор запроса
$response = Http::retry(3, 100)->post(/* ... */);

// количество миллисекунд между повторами
use Exception;
$response = Http::retry(3, function (int $attempt, Exception $exception) {return $attempt * 100;})->post(/* ... */);
// либо
$response = Http::retry([100, 200])->post(/* ... */);

// следует ли повторить попытку
use Exception;
use Illuminate\Http\Client\PendingRequest;
$response = Http::retry(3, 100, function (Exception $exception, PendingRequest $request) {
  return $exception instanceof ConnectionException;})->post(/* ... */);

// внести изменение в запрос перед новой попыткой
use Exception;
use Illuminate\Http\Client\PendingRequest;
use Illuminate\Http\Client\RequestException;
$response = Http::withToken($this->getToken())->retry(2, 0, function (Exception $exception, PendingRequest $request) {
if (! $exception instanceof RequestException || $exception->response->status() !== 401) {return false;}
$request->withToken($this->getNewToken());
return true;})->post(/* ... */);

// отключить выброс исключения если все запросы неуспешные
$response = Http::retry(3, 100, throw: false)->post(/* ... */);
</code></pre>
        <p>метод get возвращает экземпляр Illuminate\Http\Client\Response со своими методами</p>
        <pre><code>$response->body() : string;
$response->json($key = null, $default = null) : mixed;
$response->object() : object;
$response->collect($key = null) : Illuminate\Support\Collection;
$response->resource() : resource;
$response->status() : int;
$response->successful() : bool;
$response->redirect(): bool;
$response->failed() : bool;
$response->clientError() : bool;
$response->header($header) : string;
$response->headers() : array;
</code></pre>
        <table>
          <caption>имеет ли ответ заданный код состояния</caption>
          <table>
            <tr>
              <td>$response->ok() : bool;</td>
              <td>200 OK</td>
            </tr>
            <tr>
              <td>$response->created() : bool;</td>
              <td>201 Created</td>
            </tr>
            <tr>
              <td>$response->accepted() : bool;</td>
              <td>202 Accepted</td>
            </tr>
            <tr>
              <td>$response->noContent() : bool;</td>
              <td>204 No Content</td>
            </tr>
            <tr>
              <td>$response->movedPermanently() : bool;</td>
              <td>301 Moved Permanently</td>
            </tr>
            <tr>
              <td>$response->found() : bool;</td>
              <td>302 Found</td>
            </tr>
            <tr>
              <td>$response->badRequest() : bool;</td>
              <td>400 Bad Request</td>
            </tr>
            <tr>
              <td>$response->clientError() : bool;</td>
              <td>400 Client Error</td>
            </tr>
            <tr>
              <td>$response->unauthorized() : bool;</td>
              <td>401 Unauthorized</td>
            </tr>
            <tr>
              <td>$response->paymentRequired() : bool;</td>
              <td>402 Payment Required</td>
            </tr>
            <tr>
              <td>$response->forbidden() : bool;</td>
              <td>403 Forbidden</td>
            </tr>
            <tr>
              <td>$response->notFound() : bool;</td>
              <td>404 Not Found</td>
            </tr>
            <tr>
              <td>$response->requestTimeout() : bool;</td>
              <td>408 Request Timeout</td>
            </tr>
            <tr>
              <td>$response->conflict() : bool;</td>
              <td>409 Conflict</td>
            </tr>
            <tr>
              <td>$response->unprocessableEntity() : bool;</td>
              <td>422 Unprocessable Entity</td>
            </tr>
            <tr>
              <td>$response->tooManyRequests() : bool;</td>
              <td>429 Too Many Requests</td>
            </tr>
            <tr>
              <td>$response->serverError() : bool;</td>
              <td>500 Internal Server Error</td>
            </tr>
            <tr>
              <td>$response->successful();</td>
              <td>имеет ли ответ код состояния >= 200 and < 300</td>
            </tr>
            <tr>
              <td>$response->failed();</td>
              <td>имеет ли ответ код состояния >= 400</td>
            </tr>
            <tr>
              <td>$response->onError(callable $callback);</td>
              <td>выполнить функцию обратного вызова, если произошла ошибка</td>
            </tr>
          </table>
        </table>
        <p>выбросить исключение</p>
        <pre><code>use Illuminate\Http\Client\Response;
$response = Http::post(/* ... */);
return $response['user']['id'];

// throw возвращает экземпляр ответа, если ошибки не произошло
return Http::post(/* ... */)->throw()->json();
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>$response->throw();</td>
              <td>если произошла ошибка клиента или сервера</td>
            </tr>
            <tr>
              <td>$response->throwIf($condition);</td>
              <td>если произошла ошибка и данное условие истинно</td>
            </tr>
            <tr>
              <td>$response->throwIf(fn (Response $response) => true);</td>
              <td>если произошла ошибка и данное замыкание принимает значение true</td>
            </tr>
            <tr>
              <td>$response->throwUnless(fn (Response $response) => false);</td>
              <td>если произошла ошибка и данное замыкание принимает значение false</td>
            </tr>
            <tr>
              <td>$response->throwUnless($condition);</td>
              <td>если произошла ошибка и заданное условие равно false</td>
            </tr>
            <tr>
              <td>$response->throwIfStatus(403);</td>
              <td>если ответ имеет определенный код состояния</td>
            </tr>
            <tr>
              <td>$response->throwUnlessStatus(200);</td>
              <td>если только ответ не содержит определенного кода состояния</td>
            </tr>
          </tbody>
        </table>
        <p>выполнить дополнительную логику до того, как будет сгенерировано исключение</p>
        <pre><code>use Illuminate\Http\Client\Response;
use Illuminate\Http\Client\RequestException;
return Http::post(/* ... */)->throw(function (Response $response, RequestException $e) { })->json();
</code></pre>
        <p>настроить длину сообщения об ошибке в bootstrap/app.php (по умолчанию 120 символов)</p>
        <pre><code>->withExceptions(function (Exceptions $exceptions) {

  // Truncate request exception messages to 240 characters
  $exceptions->truncateRequestExceptionsAt(240);

  // Disable request exception message truncation
  $exceptions->dontTruncateRequestExceptions();})
</code></pre>
        <p>Guzzle Middleware</p>
        <pre><code>// для изменения исходящего запроса
use Illuminate\Support\Facades\Http;
use Psr\Http\Message\RequestInterface;
$response = Http::withRequestMiddleware(
  function (RequestInterface $request) {
    return $request->withHeader('X-Example', 'Value');})->get('http://example.com');

// для анализа входящего ответа
use Illuminate\Support\Facades\Http;
use Psr\Http\Message\ResponseInterface;
$response = Http::withResponseMiddleware(
  function (ResponseInterface $response) {
    $header = $response->getHeader('X-Example');
    return $response;})->get('http://example.com');
</code></pre>
        <p>параллельные запросы</p>
        <pre><code>use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;
$responses = Http::pool(fn (Pool $pool) => [
  $pool->get('http://localhost/first'),
  $pool->get('http://localhost/second'),
  $pool->get('http://localhost/third')]);
return $responses[0]->ok() && $responses[1]->ok() && $responses[2]->ok();

// либо
use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;
$responses = Http::pool(fn (Pool $pool) => [
  $pool->as('first')->get('http://localhost/first'),
  $pool->as('second')->get('http://localhost/second'),
  $pool->as('third')->get('http://localhost/third')]);
return $responses['first']->ok();
</code></pre>
        <p>пользовательские заголовки или middleware к пулу запросов</p>
        <pre><code>use Illuminate\Http\Client\Pool;
use Illuminate\Support\Facades\Http;
$headers = ['X-Example' => 'example'];
$responses = Http::pool(fn (Pool $pool) => [
  $pool->withHeaders($headers)->get('http://laravel.test/test'),
  $pool->withHeaders($headers)->get('http://laravel.test/test'),
  $pool->withHeaders($headers)->get('http://laravel.test/test')]);
</code></pre>
        <p>в App\Providers\AppServiceProvider</p>
        <pre><code>// зарегистрировать middleware для всех исходящих запросов и входящих ответов
use Illuminate\Support\Facades\Http;
Http::globalRequestMiddleware(fn ($request) => $request->withHeader('User-Agent', 'Example Application/1.0'));
Http::globalResponseMiddleware(fn ($response) => $response->withHeader('X-Finished-At', now()->toDateTimeString()));

// настроить параметры по умолчанию для каждого исходящего запроса
use Illuminate\Support\Facades\Http;
public function boot(): void {Http::globalOptions(['allow_redirects' => false]);}

// определить макрос
use Illuminate\Support\Facades\Http;
public function boot(): void {
  Http::macro('github', function () {
    return Http::withHeaders(['X-Example' => 'example'])->baseUrl('https://github.com');});}

// вызвать макрос в любом месте приложения
$response = Http::github()->get('/');
</code></pre>
        <p>Тестирование</p>
        <pre><code>// возвращать пустые ответы с кодом состояния 200 на каждый запрос
use Illuminate\Support\Facades\Http;
Http::fake();
$response = Http::post(/* ... */);

// либо
Http::fake([

  // заглушка JSON ответа для адресов GitHub
  'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),

  // заглушка строкового ответа для адресов Google
  'google.com/*' => Http::response('Hello World', 200, $headers)]);

// либо
Http::fake([
  // заглушка JSON ответа для адресов GitHub
  'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),

// заглушка строкового ответа для всех остальных адресов
  '*' => Http::response('Hello World', 200, ['Headers'])]);

// либо сгенерировать простую строку, JSON и пустые ответы, указав в качестве ответа строку, массив или целое число
Http::fake([
  'google.com/*' => 'Hello World',
  'github.com/*' => ['foo' => 'bar'],
  'chatgpt.com/*' => 200]);

// имитация исключений соединения
Http::fake(['github.com/*' => Http::failedConnection()]);

// фальсификация серии ответов
Http::fake(['github.com/*' => Http::sequence()->push('Hello World', 200)->push(['foo' => 'bar'], 200)->pushStatus(404)]);

// либо с ответом по умолчанию
Http::fake(['github.com/*' => Http::sequence()->push('Hello World', 200)->push(['foo' => 'bar'], 200)->whenEmpty(Http::response())]);

// либо без указания конкретного шаблона URL
Http::fakeSequence()->push('Hello World', 200)->whenEmpty(Http::response());

// запросы без поддельного ответа, вызовут исключение
use Illuminate\Support\Facades\Http;
Http::preventStrayRequests();
Http::fake(['github.com/*' => Http::response('ok')]);

// "ok" response is returned
Http::get('https://github.com/laravel/framework');

// exception is thrown
Http::get('https://laravel.com');

// проверить запросы, которые получает клиент
use Illuminate\Http\Client\Request;
use Illuminate\Support\Facades\Http;
Http::fake();
Http::withHeaders(['X-First' => 'foo'])
  ->post('http://example.com/users', ['name' => 'Taylor', 'role' => 'Developer']);
Http::assertSent(function (Request $request) {
  return $request->hasHeader('X-First', 'foo') &&
  $request->url() == 'http://example.com/users' &&
  $request['name'] == 'Taylor' && $request['role'] == 'Developer';});

// утверждать, что указанный запрос не был отправлен
use Illuminate\Http\Client\Request;
use Illuminate\Support\Facades\Http;
Http::fake();
Http::post('http://example.com/users', ['name' => 'Taylor', 'role' => 'Developer']);
Http::assertNotSent(function (Request $request) {return $request->url() === 'http://example.com/posts';});

// определить, сколько запросов было отправлено во время теста
Http::fake();
Http::assertSentCount(5);

// утверждать, что во время теста не было отправлено никаких запросов
Http::fake();
Http::assertNothingSent();

// запись Запросов/Ответов
Http::fake([
  'https://laravel.com' => Http::response(status: 500),
  'https://nova.laravel.com/' => Http::response()]);
Http::get('https://laravel.com');
Http::get('https://nova.laravel.com/');
$recorded = Http::recorded();
[$request, $response] = $recorded[0];

// фильтрация пар запрос/ответ
use Illuminate\Http\Client\Request;
use Illuminate\Http\Client\Response;
Http::fake([
  'https://laravel.com' => Http::response(status: 500),
  'https://nova.laravel.com/' => Http::response()]);
Http::get('https://laravel.com');
Http::get('https://nova.laravel.com/');
$recorded = Http::recorded(function (Request $request, Response $response) {
  return $request->url() !== 'https://laravel.com' && $response->successful();});
</code></pre>
        <p>События</p>
        <ul>
          <li>Реализация паттерна Наблюдатель: подписываться и отслеживать события в приложении.</li>
          <li>Классы событий обычно хранятся в каталоге app/Events, а их слушатели – в app/Listeners.</li>
          <li>Класс событий – это контейнер данных о событии.</li>
        </ul>
        <p>создать прослушиватели событий для этих событий</p>
        <pre><code>use Illuminate\Http\Client\Events\RequestSending;
class LogRequest {public function handle(RequestSending $event): void { $event->request ... }}
</code></pre>
        <p>Response - это HTTP-ответ, который возвращается пользователю в виде HTML, JSON, XML, текстового файла, изображения, редиректа и т.д.</p>
        <table>
          <tbody>
            <tr>
              <td>return response('Hello World', 200);</td>
              <td>вернуть ответ в контроллере</td>
            </tr>
            <tr>
              <td>return response()->json(['name' => 'John Doe']);</td>
              <td>вернуть JSON-ответ</td>
            </tr>
            <tr>
              <td>return response()->json(['name' => 'John Doe'], 200, [], JSON_PRETTY_PRINT);</td>
              <td>вернуть JSONP-ответ</td>
            </tr>
            <tr>
              <td>return redirect('/home');</td>
              <td>вернуть редирект</td>
            </tr>
            <tr>
              <td>return redirect('/home')->with('status', 'Profile updated!');</td>
              <td>вернуть редирект с сообщением</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// добавить заголовки
return response($content)->header('Content-Type', $type)->header('X-Header-One', 'Header Value')->header('X-Header-Two', 'Header Value');
return response($content)->withHeaders(['Content-Type' => $type, 'X-Header-One' => 'Header Value', 'X-Header-Two' => 'Header Value',]);
</code></pre>
        <p>вернуть ответ в маршруте</p>
        <pre><code>// преобразует в НТТР-ответ
Route::get('/', function () {return 'Hello World';});

// преобразует в JSON
Route::get('/', function () {return [1, 2, 3];});

// модель преобразует в JSON
Route::get('/user/{user}', function (User $user) {return $user;});

// передать код и заголовок
Route::get('/home', function () {return response('Hello World', 200)->header('Content-Type', 'text/plain');});

// установить Cache-Control
Route::middleware('cache.headers:public;max_age=2628000;etag')->group(function () {
  Route::get('/privacy', function () {});
  Route::get('/terms', function () {});
});
</code></pre>
        <p>cookies</p>
        <pre><code>// добавить файл куки к ответу
return response('Hello World')->cookie('name', 'value', $minutes, $path, $domain, $secure, $httpOnly);

// поставить куки в очередь для добавления к ответу когда он будет создан
use Illuminate\Support\Facades\Cookie;
Cookie::queue('name', 'value', $minutes);
// либо
$cookie = cookie('name', 'value', $minutes);
return response('Hello World')->cookie($cookie);

// удалить куки, обнулив срок действия
return response('Hello World')->withoutCookie('name');
// либо
Cookie::expire('name');

// отключить шифрование и подпись куки в bootstrap/app.php
->withMiddleware(function (Middleware $middleware) {
  $middleware->encryptCookies(except: ['cookie_name']);
})
</code></pre>
        <p>потоковые ответы</p>
        <pre><code>function streamedContent(): Generator {
  yield 'Hello, ';
  yield 'World!';
}
Route::get('/stream', function () {
  return response()->stream(function (): void {
    foreach (streamedContent() as $chunk) {
      echo $chunk;
      ob_flush();

      // для отправки буферизованного содержимого
      flush();

      // Simulate delay between chunks...
      sleep(2);
    }
  }, 200, ['X-Accel-Buffering' => 'no']);
});
</code></pre>
        <p>отправить JSON из маршрута</p>
        <pre><code>use App\Models\User;
Route::get('/users.json', function () {
  return response()->streamJson(['users' => User::cursor()]);
});
</code></pre>
        <p>отправить в ответ результат функции без записи на диск</p>
        <pre><code>use App\Services\GitHub;
return response()->streamDownload(function () {
  echo GitHub::api('repo')->contents()->readme('laravel', 'laravel')['contents'];
}, 'laravel-readme.md');
</code></pre>
        <p>создать свой ответ</p>
        <pre><code>namespace App\Providers;
use Illuminate\Support\Facades\Response;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider
{
  public function boot(): void
  {Response::macro('caps', function (string $value) {
    return Response::make(strtoupper($value));
  });}
}

// применить в контроллере
return response()->caps('foo');
</code></pre>
        <p>Notifications</p>
        <ul>
          <li>отправка уведомлений по различным каналам доставки: электронная почта, SMS, Slack и т.д.</li>
          <li>каждое уведомление представлено единым классом в app/Notifications</li>
        </ul>
        <pre><code>// сгенерировать новое уведомление
php artisan make:notification InvoicePaid

// отправка уведомлений через трейт Notifiable
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable {use Notifiable;}

// получить экземпляр уведомления
use App\Notifications\InvoicePaid;
$user->notify(new InvoicePaid($invoice));
</code></pre>
        <p>отправка уведомлений через фасад Notification полезно при отправке уведомления нескольким объектам</p>
        <pre><code>use Illuminate\Support\Facades\Notification;
Notification::send($users, new InvoicePaid($invoice));

// отправить немедленно без постановки в очередь
Notification::sendNow($developers, new DeploymentCompleted($deployment));

// метод via определяет по каким каналам будет доставлено уведомление
// каналы: mail, database, broadcast, vonage, slack и http://laravel-notification-channels.com/
public function via(object $notifiable): array {return $notifiable->prefers_sms ? ['vonage'] : ['mail', 'database'];}
</code></pre>
        <p>поместить уведомление в очередь</p>
        <ul>
          <li>для каждой комбинации получателя и каналов будет создана задача в очереди</li>
          <li>если у уведомления три получателя и два канала, то в очередь будет отправлено шесть задач</li>
        </ul>
        <pre><code>namespace App\Notifications;
use App\Models\User;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification implements ShouldQueue {
  use Queueable;
  $user->notify(new InvoicePaid($invoice));}
</code></pre>
        <p>отложить доставку уведомления</p>
        <pre><code>$delay = now()->addMinutes(10);
$user->notify((new InvoicePaid($invoice))->delay($delay));

// либо указать величину задержки
$user->notify((new InvoicePaid($invoice))
->delay(['mail' => now()->addMinutes(5), 'sms' => now()->addMinutes(10)]));

// либо в классе уведомления
public function withDelay(object $notifiable): array {
return ['mail' => now()->addMinutes(5), 'sms' => now()->addMinutes(10)];}
</code></pre>
        <p>указать соединение вручную</p>
        <pre><code>namespace App\Notifications;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification implements ShouldQueue {
  use Queueable;
  public function __construct() {$this->onConnection('redis');}}

// указать соединение для каждого канала
public function viaConnections(): array {return ['mail' => 'redis', 'database' => 'sync'];}

// указать очередь для каждого канала
public function viaQueues(): array {return ['mail' => 'mail-queue', 'slack' => 'slack-queue'];}
</code></pre>
        <p>посредник для уведомлений в очереди в классе уведомления</p>
        <pre><code>use Illuminate\Queue\Middleware\RateLimited;
public function middleware(object $notifiable, string $channel) {
  return match ($channel) {
    'email' => [new RateLimited('postmark')],
    'slack' => [new RateLimited('slack')],
    default => []};}
</code></pre>
        <p>уведомления в очереди и транзакции в БД</p>
        <pre><code>use App\Notifications\InvoicePaid;
$user->notify((new InvoicePaid($invoice))->afterCommit());

// либо
namespace App\Notifications;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification implements ShouldQueue {
  use Queueable;
  public function __construct() {$this->afterCommit();}}

// следует ли отправлять уведомление в очереди после его обработки обработчиком очереди
public function shouldSend(object $notifiable, string $channel): bool {return $this->invoice->isPaid();}
</code></pre>
        <p>уведомления по запросу</p>
        <pre><code>// отправить уведомление тому, чьи данные не сохранены в БД
use Illuminate\Broadcasting\Channel;
use Illuminate\Support\Facades\Notification;
Notification::route('mail', 'taylor@example.com')
  ->route('vonage', '5555555555')
  ->route('slack', '#slack-channel')
  ->route('broadcast', [new Channel('channel-name')])
  ->notify(new InvoicePaid($invoice));

// указать имя получателя при отправке уведомления по запросу
Notification::route(
  'mail',
  ['barrett@example.com' => 'Barrett Blair'])
->notify(new InvoicePaid($invoice));

// несколько маршрутов для нескольких каналов уведомлений
Notification::routes([
  'mail' => ['barrett@example.com' => 'Barrett Blair'],
  'vonage' => '5555555555',
])->notify(new InvoicePaid($invoice));
</code></pre>
        <p>почтовые уведомления</p>
        <pre><code>// параметр name в config/app.php используется в верхнем и нижнем колонтитулах почтовых уведомлений
public function toMail(object $notifiable): MailMessage {
  $url = url('/invoice/'.$this->invoice->id);
  return (new MailMessage)->greeting('Hello!')->line('One of your invoices has been paid!')
    ->lineIf($this->amount > 0, "Amount paid: {$this->amount}")->action('View Invoice', $url)
    ->line('Thank you for using our application!');}

// указать, что почтовое сообщение относится к ошибке: кнопка действия будет красной
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->error()->subject('Invoice Payment Failed')->line('...');}

// указать собственный шаблон почтового уведомления
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->view('mail.invoice.paid', ['invoice' => $this->invoice]);}
// либо с текстовым содержимым
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->view(
    ['mail.invoice.paid', 'mail.invoice.paid-text'],
    ['invoice' => $this->invoice]);}

// в сообщении только текст
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->text('mail.invoice.paid-text', ['invoice' => $this->invoice]);}

// адрес отправителя в config/mail.php, указать вручную для отдельного уведомления
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->from('barrett@example.com', 'Barrett Blair')->line('...');}

// указать адрес электронной почты получателя (по умолчанию свойство email объекта получателя) 
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Notifications\Notification;
class User extends Authenticatable {
  use Notifiable;
  public function routeNotificationForMail(Notification $notification): array|string {

    // вернуть только адрес электронной почты
    return $this->email_address;

    // вернуть адрес электронной почты и имя
    return [$this->email_address => $this->name];
  }}

// по умолчанию для класса InvoicePaid тема сообщения будет Invoice Paid, указать тему вручную
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->subject('Notification Subject')->line('...');}

// почтовый драйвер по умолчанию в config/mail.php, указать вручную
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->mailer('postmark')->line('...');}

// опубликовать шаблоны почтовых уведомлений в resources/views/vendor/notifications для изменения
php artisan vendor:publish --tag=laravel-notifications

// глубокая настройка сообщения перед его доставкой
use Symfony\Component\Mime\Email;
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->withSymfonyMessage(function (Email $message) {
    $message->getHeaders()->addTextHeader('Custom-Header', 'Header Value');});}

// указать получателя сообщения с помощью метода to объекта почтового отправления
use App\Mail\InvoicePaid as InvoicePaidMailable;
use Illuminate\Mail\Mailable;
public function toMail(object $notifiable): Mailable {return (new InvoicePaidMailable($this->invoice))->to($notifiable->email);}

// отправка уведомления по запросу
use App\Mail\InvoicePaid as InvoicePaidMailable;
use Illuminate\Notifications\AnonymousNotifiable;
use Illuminate\Mail\Mailable;
public function toMail(object $notifiable): Mailable {
  $address = $notifiable instanceof AnonymousNotifiable ? $notifiable->routeNotificationFor('mail') : $notifiable->email;
  return (new InvoicePaidMailable($this->invoice)) ->to($address);}

// предварительный просмотр почтовых уведомлений
use App\Models\Invoice;
use App\Notifications\InvoicePaid;
Route::get('/notification', function () {$invoice = Invoice::find(1);
  return (new InvoicePaid($invoice))->toMail($invoice->user);});
</code></pre>
        <p>почтовые вложения</p>
        <pre><code>// метод attach принимает абсолютный путь к файлу
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Hello!')->attach('/path/to/file');}

// либо
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Hello!')->attach('/path/to/file', [
    'as' => 'name.pdf', 'mime' => 'application/pdf']);}

// либо
use App\Mail\InvoicePaid as InvoicePaidMailable;
public function toMail(object $notifiable): Mailable {
  return (new InvoicePaidMailable($this->invoice))
  ->to($notifiable->email)
  ->attachFromStorage('/path/to/file');}

// прикрепить несколько файлов
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Hello!')->attachMany([
    '/path/to/forge.svg',
    '/path/to/vapor.svg' => [
      'as' => 'Logo.svg',
      'mime' => 'image/svg+xml']]);}

// присоединения необработанной строки в качестве вложения, указать имя файла вложения
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)
  ->greeting('Hello!')
  ->attachData($this->pdf, 'name.pdf', ['mime' => 'application/pdf']);}

// добавить теги и метаданные к сообщению
public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)->greeting('Comment Upvoted!')
  ->tag('upvote')->metadata('comment_id', $this->comment->id);}
</code></pre>
        <p>почтовые уведомления с разметкой Markdown</p>
        <pre><code>// сгенерировать уведомление с шаблоном Markdown
php artisan make:notification InvoicePaid --markdown=mail.invoice.paid

// уведомление с шаблоном Markdown
public function toMail(object $notifiable): MailMessage {
  $url = url('/invoice/'.$this->invoice->id);
  return (new MailMessage)
  ->subject('Invoice Paid')
  ->markdown('mail.invoice.paid', ['url' => $url]);}
</code></pre>
        <p>написать сообщение</p>
        <pre><code>// Invoice Paid
< x-mail::message>
  Your invoice has been paid!
  < x-mail::button :url="$url">View Invoice</ x-mail::button>
  Thanks, {{ config('app.name') }}
</ x-mail::message>

// создать кнопку
< x-mail::button :url="$url" color="green">View Invoice</ x-mail::button>

// указанный блок текста на панели
< x-mail::panel>This is the panel content.</ x-mail::panel>

// создать таблицу
< x-mail::table>
  |    Laravel    |     Table     |    Example    |
  | -------------:| -------------:| -------------:|
  | Col 2 is      | Centered      |      $10      |
  | Col 3 is      | Right-Aligned |      $20      |
</ x-mail::table>
</code></pre>
        <p>опубликовать все почтовые компоненты Markdown для настройки в resources/views/vendor/mail</p>
        <pre><code>php artisan vendor:publish --tag=laravel-mail
</code></pre>
        <p>отредактировать CSS в resources/views/vendor/mail/html/themes/default.css и создать новую тему для компонентов Laravel Markdown</p>
        <ul>
          <li>поместить файл CSS в каталог html/themes и указать его имя в парметре theme в config/mail.php</li>
          <li>указать тему для отдельного уведомления</li>
        </ul>
        <pre><code>public function toMail(object $notifiable): MailMessage {
  return (new MailMessage)
  ->theme('invoice')
  ->subject('Invoice Paid')
  ->markdown('mail.invoice.paid', ['url' => $url]);}
</code></pre>
        <p>канал database хранит информацию уведомления в таблице БД</p>
        <pre><code>// для первичных ключей UUID или ULID заменить метод morphs на uuidMorphs или ulidMorphs в миграции таблицы уведомлений
// создать таблицу базы данных для хранения уведомлений
php artisan make:notifications-table
php artisan migrate
</code></pre>
        <p>сохранить уведомление в таблице БД</p>
        <pre><code>// если использовать метод toArray, то можно создать один массив данных для каналов database и broadcast
public function toDatabase(object $notifiable): array {
  return ['invoice_id' => $this->invoice->id, 'amount' => $this->invoice->amount];}

// указать тип уведомления для сохранения в таблице БД, по умолчанию в столбец type будет записано имя класса уведомления
public function databaseType(object $notifiable): string {return 'invoice-paid';}
</code></pre>
        <p>доступ к сохранённым в БД уведомлениям</p>
        <pre><code>$user = App\Models\User::find(1);
foreach ($user->notifications as $notification) {echo $notification->type;}

// получение только непрочитанных уведомлений
$user = App\Models\User::find(1);
foreach ($user->unreadNotifications as $notification) {echo $notification->type;}

// отметить уведомление в БД как прочитанное
$user = App\Models\User::find(1);
foreach ($user->unreadNotifications as $notification) {$notification->markAsRead();}
// либо для коллекции
$user->unreadNotifications->markAsRead();

// пометить все уведомления как прочитанные
$user = App\Models\User::find(1);
$user->unreadNotifications()->update(['read_at' => now()]);

// полностью удалить уведомления из таблицы
$user->notifications()->delete();
</code></pre>
        <p>трансляция уведомлений - метод toBroadcast в классе уведомления либо метод toArray переведёт уведомление в JSON и отправит в JS</p>
        <pre><code>use Illuminate\Notifications\Messages\BroadcastMessage;
public function toBroadcast(object $notifiable): BroadcastMessage {
  return new BroadcastMessage([
    'invoice_id' => $this->invoice->id,
    'amount' => $this->invoice->amount]);}
</code></pre>
        <p>все транслируемые уведомления ставятся в очередь для трансляции</p>
        <pre><code>// изменить соединение очереди и имя очереди
return (new BroadcastMessage($data))->onConnection('sqs')->onQueue('broadcasts');

// поле type содержит полное имя класса уведомления, изменить type уведомления
public function broadcastType(): string {return 'broadcast.message';}
</code></pre>
        <p>прослушивание транслируемых уведомлений</p>
        <ul>
          <li>уведомления транслируются по частному каналу в формате {notifiable}.{id}</li>
          <li>уведомление App\Models\User с идентификатором 1 транслируется по частному каналу App.Models.User.1</li>
        </ul>
        <pre><code>// прослушивать уведомления канала
Echo.private('App.Models.User.' + userId).notification(
  (notification) => {console.log(notification.type);});
</code></pre>
        <p>изменить канал транслирования</p>
        <pre><code>namespace App\Models;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
class User extends Authenticatable {
  use Notifiable;
  public function receivesBroadcastNotificationsOn(): string {return 'users.'.$this->id;}}
</code></pre>
        <p>уведомления через SMS</p>
        <pre><code>// установить пакеты
composer require laravel/vonage-notification-channel guzzlehttp/guzzle
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>переменные окружения VONAGE_KEY и VONAGE_SECRET</td>
              <td>публичный и секретный ключи Vonage</td>
            </tr>
            <tr>
              <td>переменную окружения VONAGE_SMS_FROM</td>
              <td>номер телефона для отправки</td>
            </tr>
          </tbody>
        </table>
        <p>создать уведомление через SMS</p>
        <pre><code>use Illuminate\Notifications\Messages\VonageMessage;
public function toVonage(object $notifiable): VonageMessage {
  return (new VonageMessage)
  ->content('Your SMS message content');}

// SMS-сообщение содержит символы Unicode
use Illuminate\Notifications\Messages\VonageMessage;
public function toVonage(object $notifiable): VonageMessage {
  return (new VonageMessage)
  ->content('Your unicode message')->unicode();}

// указать номера отправителя вручную
use Illuminate\Notifications\Messages\VonageMessage;
public function toVonage(object $notifiable): VonageMessage {
  return (new VonageMessage)
  ->content('Your SMS message content')->from('15554443333');}

// ссылка на клиента позволяет создавать отчеты об использовании SMS конкретным клиентом
use Illuminate\Notifications\Messages\VonageMessage;
public function toVonage(object $notifiable): VonageMessage {
  return (new VonageMessage)
  ->clientReference((string) $notifiable->id)->content('Your SMS message content');}

// номер телефона получателя
namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Notifications\Notification;
class User extends Authenticatable {
  use Notifiable;
  public function routeNotificationForVonage(Notification $notification): string {return $this->phone_number;}}
</code></pre>
        <p>уведомления через Slack</p>
        <pre><code>// установить канал уведомлений Slack
composer require laravel/slack-notification-channel
</code></pre>
        <ul>
          <li>разрешения chat:write, chat:write.public и chat:write.customize для отправки уведомления только в рабочее пространство Slack-приложения</li>
          <li>область действия chat:write:bot в Slack-приложении</li>
          <li>Bot User OAuth Token в массив конфигурации slack в config/services.php</li>
        </ul>
        <pre><code>// распространить приложение через Slack отправлять уведомления во внешние рабочие пространства Slack пользователям вашего приложения
'slack' => ['notifications' => [
  'bot_user_oauth_token' => env('SLACK_BOT_USER_OAUTH_TOKEN'),
  'channel' => env('SLACK_BOT_USER_DEFAULT_CHANNEL')]]
</code></pre>
        <p>создать уведомление через Slack</p>
        <pre><code>use Illuminate\Notifications\Slack\BlockKit\Blocks\ContextBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\SectionBlock;
use Illuminate\Notifications\Slack\BlockKit\Composites\ConfirmObject;
use Illuminate\Notifications\Slack\SlackMessage;
public function toSlack(object $notifiable): SlackMessage {
  return (new SlackMessage)->text('One of your invoices has been paid!')->headerBlock('Invoice Paid')
    ->contextBlock(function (ContextBlock $block) {$block->text('Customer #1234');})
    ->sectionBlock(function (SectionBlock $block) {
      $block->text('An invoice has been paid.');
      $block->field("*Invoice No:*\n1000")->markdown();
      $block->field("*Invoice Recipient:*\ntaylor@laravel.com")->markdown();})
    ->dividerBlock()
    ->sectionBlock(function (SectionBlock $block) {
      $block->text('Congratulations!');});}
</code></pre>
        <p>использование шаблона Block Kit Builder Slack</p>
        <pre><code>use Illuminate\Notifications\Slack\SlackMessage;
use Illuminate\Support\Str;
public function toSlack(object $notifiable): SlackMessage {
  $template = <<<JSON {
    "blocks": [
      {
        "type": "header",
        "text": {
          "type": "plain_text",
          "text": "Team Announcement"
        }
      },
      {
        "type": "section",
        "text": {
          "type": "plain_text",
          "text": "We are hiring!"
        }
      }]}
  JSON;
  return (new SlackMessage)->usingBlockKitTemplate($template);}
</code></pre>
        <p>взаимодействие в Slack</p>
        <ul>
          <li>включить функцию “Interactivity” и настроить 'Request URL'</li>
          <li>отправить POST запрос с полезной нагрузкой на 'Request URL'</li>
          <li>пользователь Slack, который нажал на кнопку, идентификатор нажатой кнопки и дополнительная информация</li>
        </ul>
        <pre><code>use Illuminate\Notifications\Slack\BlockKit\Blocks\ActionsBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\ContextBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\SectionBlock;
use Illuminate\Notifications\Slack\SlackMessage;
public function toSlack(object $notifiable): SlackMessage {
  return (new SlackMessage)->text('One of your invoices has been paid!')
    ->headerBlock('Invoice Paid')
    ->contextBlock(function (ContextBlock $block) {$block->text('Customer #1234');})
      ->sectionBlock(function (SectionBlock $block) {$block->text('An invoice has been paid.');})
        ->actionsBlock(function (ActionsBlock $block) {
          $block->button('Acknowledge Invoice')->primary();
          $block->button('Deny')->danger()->id('deny_invoice');
        });}
</code></pre>
        <p>модальное окно подтверждения</p>
        <pre><code>use Illuminate\Notifications\Slack\BlockKit\Blocks\ActionsBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\ContextBlock;
use Illuminate\Notifications\Slack\BlockKit\Blocks\SectionBlock;
use Illuminate\Notifications\Slack\BlockKit\Composites\ConfirmObject;
use Illuminate\Notifications\Slack\SlackMessage;
public function toSlack(object $notifiable): SlackMessage {
  return (new SlackMessage)->text('One of your invoices has been paid!')->headerBlock('Invoice Paid')
    ->contextBlock(function (ContextBlock $block) {$block->text('Customer #1234');})
    ->sectionBlock(function (SectionBlock $block) {$block->text('An invoice has been paid.');})
    ->actionsBlock(function (ActionsBlock $block) {$block->button('Acknowledge Invoice')
    ->primary()->confirm(
      'Acknowledge the payment and send a thank you email?',
      function (ConfirmObject $dialog) {
        $dialog->confirm('Yes');
        $dialog->deny('No');});});}
</code></pre>
        <p>просмотр cтруктуры блоков Slack не отправляя их</p>
        <pre><code>return (new SlackMessage)->text('Один из ваших счетов оплачен!')->headerBlock('Счет Оплачен')->dd();

// либо вывести сырую полезную нагрузку
->dd(true);
</code></pre>
        <p>
          направить уведомления Slack в соответствующую команду Slack и канал</br>
          метод routeNotificationForSlack в модели уведомляющей событиями вернёт:
        </p>
        <ul>
          <li>null – использовать маршрут настроенный в уведомлении</li>
          <li>канал, куда отправить уведомление, например, #support-channel</li>
          <li>экземпляр SlackRoute позволяет указать OAuth токен и имя канала, например, SlackRoute::make($this-&gt;slack_channel, $this-&gt;slack_token) для отправки уведомлений во внешние рабочие пространства</li>
        </ul>
        <p>отправить уведомление в канал #support-channel рабочего пространства с OAuth токеном Bot User из config/services.php</p>
        <pre><code>namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Illuminate\Notifications\Notification;
class User extends Authenticatable {
  use Notifiable;
  public function routeNotificationForSlack(Notification $notification): mixed {return '#support-channel';}}
</code></pre>
        <p>отправлять уведомления в рабочие пространства Slack пользователей</p>
        <ul>
          <li>Laravel Socialite включает драйвер Slack для аутентификации пользователя в Slack и получения токена бота</li>
          <li>получить токен бота, сохранить его в БД и метод SlackRoute::make для направления уведомления в рабочее пространство пользователя</li>
        </ul>
        <pre><code>namespace App\Models;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable, Illuminate\Notifications\Notification, Illuminate\Notifications\Slack\SlackRoute;
class User extends Authenticatable {
  use Notifiable;
  public function routeNotificationForSlack(Notification $notification): mixed {
    return SlackRoute::make($this->slack_channel, $this->slack_token);}}
</code></pre>
        <p>локализация уведомлений - метод locale для установки желаемого языка</p>
        <pre><code>use Illuminate\Notifications\Notification
$user->notify((new InvoicePaid($invoice))->locale('es'));

// локализация нескольких уведомлений
Notification::locale('es')->send($users, new InvoicePaid($invoice));
</code></pre>
        <p>хранить предпочитаемый язык каждого пользователя в модели</p>
        <pre><code>use Illuminate\Contracts\Translation\HasLocalePreference;
class User extends Model implements HasLocalePreference {
  public function preferredLocale(): string {return $this->locale;}}
если язык выбран в модели, то применять без locale()
$user->notify(new InvoicePaid($invoice));
</code></pre>
        <p>тестирование Notification - метод fake фасада Notification, чтобы предотвратить отправку уведомлений</p>
        <pre><code>use App\Notifications\OrderShipped;
use Illuminate\Support\Facades\Notification;
test('orders can be shipped', function () {
  Notification::fake();

  // утверждаем, что уведомления не были отправлены
  Notification::assertNothingSent();

  // утверждаем, что уведомление  отправлено указанным пользователям
  Notification::assertSentTo([$user], OrderShipped::class);

  // утверждаем, что уведомление не было отправлено
  Notification::assertNotSentTo([$user], AnotherNotification::class);

  // утверждаем, что отправлено заданное количество уведомлений
  Notification::assertCount(3);
});

// уведомление отправлено по условию
Notification::assertSentTo($user, function (OrderShipped $notification, array $channels) use ($order) {
  return $notification->order->id === $order->id;});

// уведомление отправлено по требованию
Notification::assertSentOnDemand(OrderShipped::class);

// отправлено ли уведомление по требованию на правильный маршрут
Notification::assertSentOnDemand(
  OrderShipped::class,
  function (OrderShipped $notification, array $channels, object $notifiable) use ($user) {
    return $notifiable->routes['mail'] === $user->email;});
</code></pre>
        <p>события уведомления - прослушивать событие, при отправке уведомления</p>
        <pre><code>// создать прослушиватели событий для этого события
use Illuminate\Notifications\Events\NotificationSending;
class CheckNotificationStatus {public function handle(NotificationSending $event): void { }}

// либо уведомление не отправлено
public function handle(NotificationSending $event): bool {return false;}

// узнать больше о получателе уведомления или самом уведомлении
public function handle(NotificationSending $event): void {
  // $event->channel
  // $event->notifiable
  // $event->notification}
</code></pre>
        <p>прослушивать событие, что уведомление отправлено</p>
        <pre><code>use Illuminate\Notifications\Events\NotificationSent;
class LogNotification {public function handle(NotificationSent $event): void { }}

// узнать больше о получателе уведомления или самом уведомлении
public function handle(NotificationSent $event): void {
  // $event->channel
  // $event->notifiable
  // $event->notification
  // $event->response}
</code></pre>
        <p>написать свои драйверы для доставки уведомлений по другим каналам</p>
        <pre><code>namespace App\Notifications;
use Illuminate\Notifications\Notification;
class VoiceChannel
public function send(object $notifiable, Notification $notification): void {
  $message = $notification->toVoice($notifiable);
  // Отправка уведомления экземпляру `$notifiable`...
}}

// применить
namespace App\Notifications;
use App\Notifications\Messages\VoiceMessage;
use App\Notifications\VoiceChannel;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Notifications\Notification;
class InvoicePaid extends Notification {
  use Queueable;

  // получить канал
  public function via(object $notifiable): string {return VoiceChannel::class;}

  // получить содержимое голосового сообщения
  public function toVoice(object $notifiable): VoiceMessage { }}
</code></pre>
        <p>Каждая почтовая программа, настроенная в config/mail.php, может иметь свою собственную уникальную конфигурацию.</p>
        <p>драйвер Mailgun</p>
        <pre><code>// установить пакет
composer require symfony/mailgun-mailer symfony/http-client

// в config/mail.php параметр default присвоить mailgun и добавить в массив mailers

'mailgun' => [
  'transport' => 'mailgun',
  // 'client' => ['timeout' => 5]]

// добавить в config/services.php
'mailgun' => [
  'domain' => env('MAILGUN_DOMAIN'),
  'secret' => env('MAILGUN_SECRET'),

  // регион США
  'endpoint' => env('MAILGUN_ENDPOINT', 'api.mailgun.net'),
  'scheme' => 'https']

// либо регион Европа
'endpoint' => env('MAILGUN_ENDPOINT', 'api.eu.mailgun.net'),
</code></pre>
        <p>драйвер Postmark</p>
        <pre><code>// установить пакет
composer require symfony/postmark-mailer symfony/http-client

// в config/mail.php параметр default присвоить postmark и добавить в массив mailers
'postmark' => [
  'transport' => 'postmark',

  // необязательно указать поток сообщений Postmark
  'message_stream_id' => env('POSTMARK_MESSAGE_STREAM_ID'),
  // 'client' => ['timeout' => 5]]

// добавить в config/services.php
'postmark' => ['token' => env('POSTMARK_TOKEN')]
</code></pre>
        <p>драйвер Resend</p>
        <pre><code>// установить пакет
composer require resend/resend-php

// в config/mail.php параметр default присвоить resend и добавить в config/services.php
'resend' => ['key' => env('RESEND_KEY')]
</code></pre>
        <p>драйвер SES</p>
        <pre><code>// установить пакет
composer require aws/aws-sdk-php

// в config/mail.php параметр default присвоить ses и добавить в config/services.php
'ses' => [
  'key' => env('AWS_ACCESS_KEY_ID'),
  'secret' => env('AWS_SECRET_ACCESS_KEY'),
  'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),

  // необязательно AWS временные учетные данные через токен сеанса
  'token' => env('AWS_SESSION_TOKEN')]

//  дополнительные параметры для метода SendEmail AWS SDK при отправке электронной почты
'ses' => [
  'key' => env('AWS_ACCESS_KEY_ID'),
  'secret' => env('AWS_SECRET_ACCESS_KEY'),
  'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
  'options' => [
    'ConfigurationSetName' => 'MyConfigurationSet',
    'EmailTags' => [['Name' => 'foo', 'Value' => 'bar']]]]

// заголовок в массиве из метода headers почтового сообщения для взаимодействия с функциями управления подпиской SES
public function headers(): Headers {
  return new Headers(text: [
    'X-Ses-List-Management-Options' => 'contactListName=MyContactList;topicName=MyTopic']);}
</code></pre>
        <p>драйвер MailerSend: сервис для отправки транзакционных электронных писем и SMS-сообщений, поддерживает драйвер для Laravel</p>
        <pre><code>// установить пакет
composer require mailersend/laravel-driver

// в .env
MAIL_MAILER=mailersend
MAIL_FROM_ADDRESS=app@yourdomain.com
MAIL_FROM_NAME="Имя приложения"
MAILERSEND_API_KEY=ваш-ключ-api

// в массив mailers в config/mail.php
'mailersend' => ['transport' => 'mailersend']
</code></pre>
        <p>резервная конфигурация доставки почты</p>
        <pre><code>// массив failover содержит массив mailers, который определяет очередность выбора почтовой программы
'mailers' => ['failover' => [
  'transport' => 'failover', 'mailers' => ['postmark', 'mailgun', 'sendmail']]]

// в config/mail.php
'default' => env('MAIL_MAILER', 'failover')
</code></pre>
        <p>транспорт roundrobin позволяет распределить почтовую нагрузку между несколькими почтовыми клиентами</p>
        <pre><code>'mailers' => ['roundrobin' => [
  'transport' => 'roundrobin', 'mailers' => ['ses', 'postmark']]]

// в config/mail.php
'default' => env('MAIL_MAILER', 'roundrobin')
</code></pre>
        <p>транспорт failover обеспечивает доступность, транспорт roundrobin обеспечивает балансировку нагрузки</p>
        <p>письмо электронной почты</p>
        <pre><code>// создать почтовый класс в app/Mail
php artisan make:mail OrderShipped
</code></pre>
        <p>метод envelope</p>
        <pre><code>// отправитель и тема электронной почты
use Illuminate\Mail\Mailables\Address;
use Illuminate\Mail\Mailables\Envelope;
public function envelope(): Envelope {
  return new Envelope(
    from: new Address('jeffrey@example.com', 'Jeffrey Way'),
    subject: 'Order Shipped');}

// указать адрес ответа
return new Envelope(
  from: new Address('jeffrey@example.com', 'Jeffrey Way'),
  replyTo: [new Address('taylor@example.com', 'Taylor Otwell')],
  subject: 'Заказ отправлен');

// указать глобальный адрес отправителя и reply_to в config/mail.php
'from' => [
  'address' => env('MAIL_FROM_ADDRESS', 'hello@example.com'),
  'name' => env('MAIL_FROM_NAME', 'Example')],
'reply_to' => ['address' => 'example@example.com', 'name' => 'App Name']
</code></pre>
        <p>метод content</p>
        <pre><code>// указать какой шаблон Blade используется для электронного письма
public function content(): Content {
  return new Content(view: 'mail.orders.shipped');}

// определить версию письма в HTML и обычный текст
public function content(): Content {
  return new Content(view: 'mail.orders.shipped', text: 'mail.orders.shipped-text');}
  
// либо
return new Content(html: 'mail.orders.shipped', text: 'mail.orders.shipped-text');

// передать данные шаблону
namespace App\Mail;
use App\Models\Order;
use Illuminate\Bus\Queueable;
use Illuminate\Mail\Mailable;
use Illuminate\Mail\Mailables\Content;
use Illuminate\Queue\SerializesModels;
class OrderShipped extends Mailable {
  use Queueable, SerializesModels;

  // автоматический доступ к свойствам $order
  public function __construct(public Order $order) {}
  public function content(): Content {return new Content(view: 'mail.orders.shipped');}}

// доступ в шаблоне Blade
< div>Price: {{ $order->price }}< /div>
// либо
class OrderShipped extends Mailable {
  use Queueable, SerializesModels;

  // нет автоматического доступа к свойствам $order
  public function __construct(protected Order $order) {}
  public function content(): Content {
    return new Content(
      view: 'mail.orders.shipped',

      // даёт доступ
      with: ['orderName' => $this->order->name, 'orderPrice' => $this->order->price]);}}

// доступ в шаблоне Blade
< div>Price: {{ $orderPrice }}< /div>
</code></pre>
        <p>метод attachments</p>
        <pre><code>use Illuminate\Mail\Mailables\Attachment;
public function attachments(): array {
  return [Attachment::fromPath('/path/to/file')];}

// либо
public function attachments(): array {
  return [Attachment::fromPath('/path/to/file')
    ->as('name.pdf')->withMime('application/pdf')];}

// прикрепить файл с диска
public function attachments(): array {
  return [Attachment::fromStorage('/path/to/file')];}

// либо
public function attachments(): array {return [Attachment::fromStorage('/path/to/file')
  ->as('name.pdf')->withMime('application/pdf')];}

// указать диск не по умолчанию
public function attachments(): array {
  return [Attachment::fromStorageDisk('s3', '/path/to/file')
    ->as('name.pdf')->withMime('application/pdf')];}

// присоединить сырую строку байтов (сгенерированный в памяти PDF-файл без записи на диск)
public function attachments(): array {
  return [Attachment::fromData(fn () => $this->pdf, 'Report.pdf')
    ->withMime('application/pdf')];}

// вставить изображение в шаблон
< body>Here is an image: < img src="{{ $message->embed($pathToImage) }}">< /body>
// переменная $message автоматически доступна для всех шаблонов с встроенными вложениями

// вставить строку необработанных данных изображения
< body>Here is an image from raw data: < img src="{{ $message->embedData($data, 'example-image.jpg') }}">< /body>
</code></pre>
        <p>прикрепить объект</p>
        <pre><code>// в модели прикрепляемого объекта
namespace App\Models;
use Illuminate\Contracts\Mail\Attachable;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Mail\Attachment;
class Photo extends Model implements Attachable {
  public function toMailAttachment(): Attachment {return Attachment::fromPath('/path/to/file');}}

// в классе письма
public function attachments(): array {return [$this->photo];}

// либо создать вложение из файла на основном диске
return Attachment::fromStorage($this->path);

// создать вложение из файла на указанном диске
return Attachment::fromStorageDisk('backblaze', $this->path);

// создать вложение из данных, хранящихся в памяти
return Attachment::fromData(fn () => $this->content, 'Имя фотографии');

// задать имя файла и MIME-тип
return Attachment::fromPath('/путь/к/файлу')->as('Имя фотографии')->withMime('image/jpeg');
</code></pre>
        <p>прикрепить дополнительные заголовки в классе письма</p>
        <pre><code>use Illuminate\Mail\Mailables\Headers;
public function headers(): Headers {
  return new Headers(
    messageId: 'custom-message-id@example.com',
    references: ['previous-message@example.com'],
    text: ['X-Custom-Header' => 'Custom Value']);}
</code></pre>
        <p>добавить теги и метаданные к письму</p>
        <pre><code>use Illuminate\Mail\Mailables\Envelope;
public function envelope(): Envelope {
  return new Envelope(
    subject: 'Заказ отправлен',
    tags: ['shipment'],
    metadata: ['order_id' => $this->order->id]);}
</code></pre>
        <p>глубокая настройка письма через Symfony Message</p>
        <pre><code>use Illuminate\Mail\Mailables\Envelope;
use Symfony\Component\Mime\Email;
public function envelope(): Envelope {
  return new Envelope(
    subject: 'Заказ отправлен',
    using: [function (Email $message) { }]);}
</code></pre>
        <p>письма с разметкой Markdown</p>
        <pre><code>// сгенерировать почтовый класс с шаблоном Markdown
php artisan make:mail OrderShipped --markdown=mail.orders.shipped
</code></pre>
        <p>в методе content</p>
        <pre><code>use Illuminate\Mail\Mailables\Content;
public function content(): Content {
  return new Content(
    markdown: 'mail.orders.shipped',
    with: ['url' => $this->orderUrl]);}
</code></pre>
        <p>письма с Markdown используют комбинацию компонентов Blade и синтаксиса Markdown</p>
        <pre><code>// Order Shipped
< x-mail::message>
  Your order has been shipped!
  < x-mail::button :url="$url">View Order</ x-mail::button>
  Thanks, {{ config('app.name') }}
< /x-mail::message>

// компонент кнопки
< x-mail::button :url="$url" color="success">View Order< /x-mail::button>

// компонент панели
< x-mail::panel>This is the panel content.< /x-mail::panel>

// компонент таблицы
< x-mail::table>
| Laravel       | Table         | Example       |
| ------------- | :-----------: | ------------: |
| Col 2 is      | Centered      | $10           |
| Col 3 is      | Right-Aligned | $20           |
< /x-mail::table>

// опубликует почтовые компоненты Markdown в каталоге resources/views/vendor/mail для внесения изменений
php artisan vendor:publish --tag=laravel-mail
</code></pre>
        <ul>
          <li>редактировать CSS в resources/views/vendor/mail/html/themes/default.css</li>
          <li>создать файл CSS в html/themes, чтобы создать новую тему для компонентов Markdown</li>
          <li>имя файла темы указать в параметре theme из config/mail.php</li>
          <li>установить тему для отдельного письма: указать имя файла темы в свойстве $theme почтового класса</li>
        </ul>
        <p>отправка почты</p>
        <pre><code>namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use App\Mail\OrderShipped;
use App\Models\Order;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Mail;
class OrderShipmentController extends Controller {
  public function store(Request $request): RedirectResponse {
    $order = Order::findOrFail($request->order_id);
    Mail::to($request->user())->send(new OrderShipped($order));
    return redirect('/orders');}}

// либо
Mail::to($request->user())->cc($moreUsers)->bcc($evenMoreUsers)->send(new OrderShipped($order));

// отправить почтовое сообщение списку получателей
foreach (['taylor@example.com', 'dries@example.com'] as $recipient) {
  Mail::to($recipient)->send(new OrderShipped($order));}

// указать драйвер при отправке почты вручную
Mail::mailer('postmark')->to($request->user())->send(new OrderShipped($order));

// поставить почтовое сообщение в очередь
Mail::to($request->user())->cc($moreUsers)->bcc($evenMoreUsers)->queue(new OrderShipped($order));

// отложить доставку электронного письма в очереди
Mail::to($request->user())->cc($moreUsers)->bcc($evenMoreUsers)
->later(now()->addMinutes(10), new OrderShipped($order));

// указать соединение и имя очереди для письма
$message = (new OrderShipped($order))->onConnection('sqs')->onQueue('emails');
Mail::to($request->user())->cc($moreUsers)->bcc($evenMoreUsers)->queue($message);

// письмо при отправке всегда будет ставиться в очередь
use Illuminate\Contracts\Queue\ShouldQueue;
class OrderShipped extends Mailable implements ShouldQueue { }
</code></pre>
        <p>письма в очереди и транзакции в БД</p>
        <pre><code>// указать, что это письмо в очереди будет отправлено после фиксации всех открытых транзакций БД
Mail::to($request->user())->send((new OrderShipped($order))->afterCommit());
либо из конструктора письма
namespace App\Mail;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Mail\Mailable;
use Illuminate\Queue\SerializesModels;
class OrderShipped extends Mailable implements ShouldQueue {
  use Queueable, SerializesModels;
  public function __construct() {$this->afterCommit();}}
</code></pre>
        <p>получить HTML-содержимое письма, не отправляя его</p>
        <pre><code>use App\Mail\InvoicePaid;
use App\Models\Invoice;
$invoice = Invoice::find(1);
return (new InvoicePaid($invoice))->render();
</code></pre>
        <p>предварительный просмотр письма в</p>
        <pre><code>Route::get('/mailable', function () {
  $invoice = App\Models\Invoice::find(1);
  return new App\Mail\InvoicePaid($invoice);});
</code></pre>
        <p>локализация письма</p>
        <pre><code>Mail::to($request->user())->locale('es')->send(new OrderShipped($order));

// использовать сохраненный предпочитаемый язык каждого пользователя при отправке почты
use Illuminate\Contracts\Translation\HasLocalePreference;
class User extends Model implements HasLocalePreference {
  public function preferredLocale(): string {return $this->locale;}}

// тогда без locale()
Mail::to($request->user())->send(new OrderShipped($order));
</code></pre>
        <p>тестирование почтовой программы - проверка наличия ожидаемого содержимого в почтовом классе</p>
        <pre><code>use App\Mail\InvoicePaid;
use App\Models\User;
test('mailable content', function () {
  $user = User::factory()->create();
  $mailable = new InvoicePaid($user);
  $mailable->assertFrom('jeffrey@example.com');
  $mailable->assertTo('taylor@example.com');
  $mailable->assertHasCc('abigail@example.com');
  $mailable->assertHasBcc('victoria@example.com');
  $mailable->assertHasReplyTo('tyler@example.com');
  $mailable->assertHasSubject('Invoice Paid');
  $mailable->assertHasTag('example-tag');
  $mailable->assertHasMetadata('key', 'value');
  $mailable->assertSeeInHtml($user->email);
  $mailable->assertSeeInHtml('Invoice Paid');
  $mailable->assertSeeInOrderInHtml(['Invoice Paid', 'Thanks']);
  $mailable->assertSeeInText($user->email);
  $mailable->assertSeeInOrderInText(['Invoice Paid', 'Thanks']);
  $mailable->assertHasAttachment('/path/to/file');
  $mailable->assertHasAttachment(Attachment::fromPath('/path/to/file'));
  $mailable->assertHasAttachedData($pdfData, 'name.pdf', ['mime' => 'application/pdf']);
  $mailable->assertHasAttachmentFromStorage('/path/to/file', 'name.pdf', ['mime' => 'application/pdf']);
  $mailable->assertHasAttachmentFromStorageDisk(
    's3',
    '/path/to/file',
    'name.pdf',
    ['mime' => 'application/pdf']);});
</code></pre>
        <p>тестировать отправку письма</p>
        <pre><code>use App\Mail\OrderShipped;
use Illuminate\Support\Facades\Mail;
test('orders can be shipped', function () {
  Mail::fake();

  // ни одно письмо не было отправлено
  Mail::assertNothingSent();

  // было отправлено одно письмо
  Mail::assertSent(OrderShipped::class);

  // было отправлено два письма
  Mail::assertSent(OrderShipped::class, 2);

  // письмо было отправлено на указанный адрес
  Mail::assertSent(OrderShipped::class, 'example@laravel.com');

  // письмо было отправлено на несколько адресов
  Mail::assertSent(OrderShipped::class, ['example@laravel.com', '...']);

  // указанное письмо не было отправлено
  Mail::assertNotSent(AnotherMailable::class);

  // всего было отправлено 3 письма
  Mail::assertSentCount(3);});

// либо если письмо отправлено в очередь
Mail::assertQueued(OrderShipped::class);
Mail::assertNotQueued(OrderShipped::class);
Mail::assertNothingQueued();
Mail::assertQueuedCount(3);

// письмо не было отправлено или поставлено в очередь
Mail::assertNothingOutgoing();
Mail::assertNotOutgoing(function (OrderShipped $mail) use ($order) {
  return $mail->order->id === $order->id;});

  // письмо отправлено по условию
  Mail::assertSent(function (OrderShipped $mail) use ($order) {
    return $mail->order->id === $order->id;});

  // методы для анализа класса отправки электронной почты
  Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) use ($user) {
    return $mail->hasTo($user->email) &&
      $mail->hasCc('...') &&
      $mail->hasBcc('...') &&
      $mail->hasReplyTo('...') &&
      $mail->hasFrom('...') &&
      $mail->hasSubject('...');});

  // методы анализа вложений в классе отправки электронной почты
  use Illuminate\Mail\Mailables\Attachment;
  Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) {
    return $mail->hasAttachment(Attachment::fromPath('/путь/к/файлу')
      ->as('name.pdf')->withMime('application/pdf'));});

  Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) {
    return $mail->hasAttachment(Attachment::fromStorageDisk('s3', '/путь/к/файлу'));});

  Mail::assertSent(OrderShipped::class, function (OrderShipped $mail) use ($pdfData) {
    return $mail->hasAttachment(Attachment::fromData(fn () => $pdfData, 'name.pdf'));});
</code></pre>
        <p>отправка почты при локальной разработке</p>
        <ul>
          <li>почтовый драйвер log будет записывать все письма в файлы журналов для проверки</li>
          <li>когда Sail запущен можно получить доступ к интерфейсу Mailpit по адресу: &lt;http://localhost:8025&gt;</li>
          <li>HELO или Mailtrap и драйвер smtp отправять письма в фиктивный почтовый ящик</li>
          <li>указать глобальный адрес кому в AppProvidersAppServiceProvider</li>
        </ul>
        <pre><code>use Illuminate\Support\Facades\Mail;
public function boot(): void {
  if ($this->app->environment('local')) {Mail::alwaysTo('taylor@example.com');}}
</code></pre>
        <p>события</p>
        <ul>
          <li>событие MessageSending отправляется до отправки сообщения</li>
          <li>событие MessageSent отправляется после отправки сообщения</li>
          <li>события отправляются при отправке почты, а не при ее постановке в очередь</li>
        </ul>
        <p>создать слушателя</p>
        <pre><code>use Illuminate\Mail\Events\MessageSending;

// use Illuminate\Mail\Events\MessageSent;
class LogMessage {public function handle(MessageSending $event): void { }}
</code></pre>
        <p>написать свои транспорты для доставки электронной почты</p>
        <pre><code>use MailchimpTransactional\ApiClient;
use Symfony\Component\Mailer\SentMessage;
use Symfony\Component\Mailer\Transport\AbstractTransport;
use Symfony\Component\Mime\Address;
use Symfony\Component\Mime\MessageConverter;
class MailchimpTransport extends AbstractTransport {
  public function __construct(protected ApiClient $client) {parent::__construct();}
  protected function doSend(SentMessage $message): void {
    $email = MessageConverter::toEmail($message->getOriginalMessage());
    $this->client->messages->send(['message' => [
      'from_email' => $email->getFrom(),
      'to' => collect($email->getTo())->map(function (Address $email) {
        return ['email' => $email->getAddress(), 'type' => 'to'];})->all(),
      'subject' => $email->getSubject(),
      'text' => $email->getTextBody()]]);}
  
  // строковое представление транспорта
  public function __toString(): string {return 'mailchimp';}}

// зарегистрировать транспорт в App\Providers\AppServiceProvider
use App\Mail\MailchimpTransport;
use Illuminate\Support\Facades\Mail;
public function boot(): void {
  Mail::extend('mailchimp', function (array $config = []) {
    return new MailchimpTransport(/* ... */);});}

// в config/mail.php
'mailchimp' => ['transport' => 'mailchimp']
</code></pre>
        <p>использовать другие транспорты Symfony</p>
        <pre><code>// установить Symfony mailer “Brevo”
composer require symfony/brevo-mailer symfony/http-client

// добавить запись с учетными данными API Brevo в config/services.php
'brevo' => ['key' => 'ваш-ключ-api']

// зарегистрировать Symfony mailer “Brevo” в App\Providers\AppServiceProvider
use Illuminate\Support\Facades\Mail;
use Symfony\Component\Mailer\Bridge\Brevo\Transport\BrevoTransportFactory;
use Symfony\Component\Mailer\Transport\Dsn;
public function boot(): void {
  Mail::extend('brevo', function () {
    return (new BrevoTransportFactory)
    ->create(new Dsn('brevo+api', 'default', config('services.brevo.key')));});}

// в config/mail.php
'brevo' => ['transport' => 'brevo']</code></pre>
        <h2>Views</h2>
        <p>Templates (шаблоны) - это HTML и директивы Blade в файле с расширением .blade.php</p>
        <p>Blade</p>
        <ul>
          <li>шаблоны Blade - это HTML и директивы Blade в файле с расширением .blade.php, компилируются в обычные PHP-файлы и кэшируются</li>
          <li>могут содержать: обычный PHP-код, другие шаблоны Blade, директивы Blade, секции, компоновщики и компоненты</li>
        </ul>
        <p>создать Blade-шаблон</p>
        <pre><code>php artisan make:view greeting

// для шаблонов blade вызов глобального помощника view
Route::get('/', function () {return view('greeting', ['name' => 'James']);});

// либо вызов фасада View
use Illuminate\Support\Facades\View;

// greeting - имя файла шаблона, name - вывести в шаблоне значение, либо в шаблон массив данных
return View::make('greeting', ['name' => 'James']);

// вызвать первый шаблон из массива
return View::first(['custom.admin', 'admin'], $data);

// существует ли шаблон
if (View::exists('admin.profile')) { }

// передать в шаблон отдельные данные
return view('greeting')->with('name', 'Victoria')->with('occupation', 'Astronaut');

// вызвать resources/views/admin/profile.blade.php
return view('admin.profile', $data);

// в App\Providers\AppServiceProvider сделать данные доступными для всех шаблонов
public function boot(): void {View::share('key', 'value');}
</code></pre>
        <p>Templates composers - это классы или анонимные функции для создания многоразовых шаблонов, чтобы привязывать к шаблону данные перед его отрисовкой.</p>
        <p>Привязываемые данные:</p>
        <ul>
          <li>не зависят от контроллеров</li>
          <li>зависят от других данных</li>
          <li>зависят от других шаблонов</li>
          <li>зависят от других компонентов</li>
          <li>данные к шаблону, которые вызываются при его каждой отрисовке</li>
        </ul>
        <pre><code>// в App\Providers\AppServiceProvider
public function boot(): void
{
  // компоновщик на основе класса
  Facades\View::composer('profile', ProfileComposer::class);

  // компоновщик на основе анонимной функции
  Facades\View::composer('welcome', function (View $view) { });
}

// создать нового компоновщика профиля
namespace App\View\Composers;
use App\Repositories\UserRepository;
use Illuminate\View\View;
class ProfileComposer
{
  public function __construct(protected UserRepository $users) { }
  public function compose(View $view): void {

    // привязать данные к шаблону
    $view->with('count', $this->users->count());}
}

// прикрепить компоновщик к нескольким шаблонам
use App\Views\Composers\MultiComposer;
use Illuminate\Support\Facades\View;
View::composer(['profile', 'dashboard'], MultiComposer::class);

// прикрепить компоновщик ко всем шаблонам
use Illuminate\Support\Facades;
use Illuminate\View\View;
Facades\View::composer('*', function (View $view) { });

// создатели шаблонов выполняются сразу после создания экземпляра, не дожидаясь отрисовки шаблона
use App\View\Creators\ProfileCreator;
use Illuminate\Support\Facades\View;
View::creator('profile', ProfileCreator::class);
</code></pre>
        <table>
          <caption>оптимизация шаблонов</caption>
          <tbody>
            <tr>
              <td>php artisan view:cache</td>
              <td>предварительная компиляция всех шаблонов при развёртывании</td>
            </tr>
            <tr>
              <td>php artisan view:clear</td>
              <td>очистка кеша шаблонов</td>
            </tr>
            <tr>
              <td>php artisan view:clear</td>
              <td>удалить кешированные шаблоны</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// поместить РНР код в шаблон Blade
{{ }}

//текущее UNIX-время
{{ time() }}

// отключить экранирование данных (экранирование нужно для предотвращения XSS-атак)
Привет, {!! $name !!}

// передать в HTML без обработки
Привет, @{{ name }} либо @@if()

// передать в HTML без обработки несколько строк
@verbatim
  < div class="container">
    Hello, {{ name }}.
  < /div>
@endverbatim

// передать массив шаблону в виде JSON
< script> var app = {{ Js::from($array) }}; </ script>
</code></pre>
        <p>Blade directives</p>
        <ul>
          <li>директивы Blade - это команды для выполнения действий в шаблонах Blade</li>
          <li>начинаются с символа @</li>
          <li>могут быть вложенными друг в друга и содержать параметры, другие директивы Blade, код (PHP, HTML, JavaScript, CSS)</li>
        </ul>
        <pre><code>// условие
@if (count($records) === 1) у меня есть одна запись!
@elseif (count($records) > 1) у меня есть несколько записей!
@else у меня нет записей!
@endif
@unless (Auth::check()) вы не вошли в систему @endunless
@isset($records) переменная $records определена и не равна null @endisset
@empty($records) переменная $records считается «пустой» @endempty

// аутентификация
@auth пользователь аутентифицирован @endauth
@guest пользователь не аутентифицирован @endguest

// аутентификация с правилом guard
@auth('admin') пользователь аутентифицирован @endauth
@guest('admin') пользователь не аутентифицирован @endguest

// ошибки валидации
< input id="title" type="text" class="@error('title') is-invalid @enderror"/>
@error('title')< div class="alert alert-danger">{{ $message }}</ div>@enderror

// либо
< input id="email" type="email" class="@error('email') is-invalid @else is-valid @enderror"/>

// стэки
// для отображения в других шаблонах
@push('scripts')< script src="/example.js"></ script>@endpush

// добавить при условии
@pushIf($shouldPush, 'scripts')< script src="/example.js"></ script>@endPushIf

// добавить в начало стэка
@prepend('scripts') это будет первое @endprepend

// отобразить весь стэк
< head>@stack('scripts')</ head>

// среда окружения
@production содержимое, отображаемое только в эксплуатационном окружении @endproduction
@env('staging') приложение запущено в «переходном» окружении @endenv
@env(['staging', 'production']) приложение запущено в «переходном» или «рабочем» окружении @endenv


// есть ли в секции наследуемого шаблона содержимое
@hasSection('navigation')
  < div class="pull-right">
    @yield('navigation')
  < /div>
  < div class="clearfix">< /div>
@endif

// нет ли в секции содержимого
@sectionMissing('navigation')
  < div class="pull-right">
    @include('default-navigation')
  < /div>
@endif

// есть ли сессия
@session('status')
  < div class="p-4">{{ $value }}< /div>
@endsession

// передать данные от родителя к ребенку @aware
// родитель
@props(['color' => 'gray'])
< ul {{ $attributes->merge(['class' => 'bg-'.$color.'-200']) }}>{{ $slot }}< /ul>
// ребенок
@aware(['color' => 'gray'])
< li {{ $attributes->merge(['class' => 'text-'.$color.'-800']) }}>{{ $slot }}< /li>

// подключить службу
@inject('metrics', 'App\Services\MetricsService')
< div>Ежемесячный доход: {{ $metrics->monthlyRevenue() }}< /div>

// отдать в исходящий HTTP-ответ фрагмент шаблона
// в шаблоне
@fragment('user-list')
  < ul>
    @foreach ($users as $user)
      < li>{{ $user->name }}< /li>
    @endforeach
  < /ul>
@endfragment

// в роуте или контроллере
return view('dashboard', ['users' => $users])->fragment('user-list');

// отдать в исходящий HTTP-ответ фрагмент шаблона при условии (true - фрагмент, false - всё)
return view('dashboard', ['users' => $users])->fragmentIf($request->hasHeader('HX-Request'), 'user-list');

// отдать в исходящий HTTP-ответ фрагмент шаблона несколько фрагментов
view('dashboard', ['users' => $users])->fragments(['user-list', 'comment-list']);
view('dashboard', ['users' => $users])->fragmentsIf($request->hasHeader('HX-Request'),['user-list', 'comment-list']);

// свитч
@switch($i)
  @case(1)
    первый case...
    @break

  @case(2)
    второй case...
    @break

  @default
    case по умолчанию...
@endswitch

// циклы
@for ($i = 0; $i < 10; $i++) Текущее значение {{ $i }} @endfor
@foreach ($users as $user) < p>Это пользователь {{ $user->id }}< /p> @endforeach
@forelse ($users as $user) < li>{{ $user->name }}< /li>
  @empty < p>Нет пользователей< /p>
@endforelse

@while (true) < p>Я зацикливаюсь навсегда.< /p> @endwhile

// пропуск текущей итерации @continue или завершение @break
@foreach ($users as $user)
  @if ($user->type == 1)
    @continue
  @endif
  < li>{{ $user->name }}< /li>
  @if ($user->number == 5)
    @break
  @endif
@endforeach

// пропуск и завершение при условии
@foreach ($users as $user)
  @continue($user->type == 1)
  < li>{{ $user->name }}< /li>
  @break($user->number == 5)
@endforeach

// информация о цикле в переменной $loop
@foreach ($users as $user)
  @if ($loop->first) это первая итерация @endif
  @if ($loop->last) это последняя итерация @endif
  < p>это пользователь {{ $user->id }}< /p>
@endforeach

// $loop родительского цикла
@foreach ($users as $user)
  @foreach ($user->posts as $post)
    @if ($loop->parent->first) это первая итерация родительского цикла @endif
  @endforeach
@endforeach</code></pre>
        <table>
          <tbody>
            <tr>
              <td>$loop->index</td>
              <td>Индекс текущей итерации цикла (начинается с 0).</td>
            </tr>
            <tr>
              <td>$loop->iteration</td>
              <td>Текущая итерация цикла (начинается с 1).</td>
            </tr>
            <tr>
              <td>$loop->remaining</td>
              <td>Итерации, оставшиеся в цикле.</td>
            </tr>
            <tr>
              <td>$loop->count</td>
              <td>Общее количество элементов в итерируемом массиве.</td>
            </tr>
            <tr>
              <td>$loop->first</td>
              <td>Первая ли это итерация цикла.</td>
            </tr>
            <tr>
              <td>$loop->last</td>
              <td>Последняя ли это итерация цикла.</td>
            </tr>
            <tr>
              <td>$loop->even</td>
              <td>Четная ли это итерация цикла.</td>
            </tr>
            <tr>
              <td>$loop->odd</td>
              <td>Нечетная ли это итерация цикла.</td>
            </tr>
            <tr>
              <td>$loop->depth</td>
              <td>Уровень вложенности текущего цикла.</td>
            </tr>
            <tr>
              <td>$loop->parent</td>
              <td>Переменная родительского цикла во вложенном цикле.</td>
            </tr>
          </tbody>
        </table>
        <p>создать свою директиву datetime форматирует переданный $var (экземпляр DateTime)</p>
        <pre><code>App\Providers\AppServiceProvider
public function boot(): void
{
  Blade::directive('datetime', function (string $expression) {
    return "< ?php echo ($expression)->format('m/d/Y H:i'); ?>";
  });
}

// вызвать
@datetime($var)
</code></pre>
        <p>классы и стили по условию</p>
        <pre><code>// класс
@php
  $isActive = false;
  $hasError = true;
@endphp

< span @class([
  // числовой ключ отрисовывается всегда
  'p-4',
  'font-bold' => $isActive,
  'text-gray-500' => ! $isActive,
  'bg-red' => $hasError,
])>< /span>
< span class="p-4 text-gray-500 bg-red">< /span>

// стиль
@php
    $isActive = true;
@endphp
< span @style([
  'background-color: red',
  'font-weight: bold' => $isActive,
])></ span>
< span style="background-color: red; font-weight: bold;">< /span>
</code></pre>
        <p>атрибуты</p>
        <pre><code>@checked
< input
  type="checkbox"
  name="active"
  value="active"
  @checked(old('active', $user->active))
/>

@selected
< select name="version">
  @foreach ($product->versions as $version)
    < option value="{{ $version }}" @selected(old('version') == $version)>{{ $version }}< /option>
  @endforeach
< /select>

@disabled
< button type="submit" @disabled($errors->isNotEmpty())>Отправить< /button>

@readonly
< input
  type="email"
  name="email"
  value="email@laravel.com"
  @readonly($user->isNotAdmin())
/>

@required
< input
  type="text"
  name="title"
  value="title"
  @required($user->isAdmin())
/></code></pre>
        <table>
          <caption>@include подключение дочерних шаблонов (компоненты лучше)</caption>
          <tbody>
            <tr>
              <td>@include('shared.errors')</td>
              <td>включить шаблон</td>
            </tr>
            <tr>
              <td>@include('view.name', ['status' => 'complete'])</td>
              <td>включенный шаблон имеет доступ к родительским данным, добавить данные массивом</td>
            </tr>
            <tr>
              <td>@includeIf('view.name', ['status' => 'complete'])</td>
              <td>включить шаблон, который может отсутствовать</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// включить шаблон по логическому условию
@includeWhen($boolean, 'view.name', ['status' => 'complete'])
@includeUnless($boolean, 'view.name', ['status' => 'complete'])

// включить первый шаблон из массива
@includeFirst(['custom.admin', 'admin'], ['status' => 'complete'])
</code></pre>
        <p>
          __DIR__ и __FILE__ ссылаются на расположение кешированного, скомпилированного шаблона.<br/>
          @each отрисовка шаблона с коллекцией
        </p>
        <pre><code>// шаблон отрисовывается для каждого элемента в массиве
@each('view.name', $jobs, 'job' 'view.empty')
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>view.name</td>
              <td>шаблон, $jobs - массив</td>
            </tr>
            <tr>
              <td>job</td>
              <td>текущий элемент массива</td>
            </tr>
            <tr>
              <td>view.empty</td>
              <td>шаблон если массив пустой</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// @once сработает только раз
@once
  @push('scripts')< script>JavaScript< /script>@endpush
@endonce

// либо
@pushOnce('scripts')< script>JavaScript< /script>@endPushOnce

// либо
@prependOnce('scripts')< script>JavaScript< /script>@endPrependOnce

// @php код РНР в шаблоне
@php$counter = 1;@endphp

// @use импорт класса
// без псевдонима
@use('App\Models\Flight')

// с псевдонимом
@use('App\Models\Flight', 'FlightModel')
</code></pre>
        <p>отобразить часть страницы только, если пользователь авторизован</p>
        <pre><code>@can('update', $post)
  // текущий пользователь может обновить пост
@elsecan('create', App\Models\Post::class)
  // текущий пользователь может создавать новые посты
@else
  // показать часть страницы по умолчанию
@endcan

@cannot('update', $post)
  // текущий пользователь не может обновить пост
@elsecannot('create', App\Models\Post::class)
  // текущий пользователь не может создавать новые посты
@endcannot

@canany(['update', 'view', 'delete'], $post)
  // текущий пользователь может обновить, просмотреть или удалить пост
@elsecanany(['create'], \App\Models\Post::class)
  // текущий пользователь может создать пост
@endcanany

// тоже самое 
@if (Auth::user()->can('update', $post)) текущий пользователь может обновить пост @endif
@unless (Auth::user()->can('update', $post)) текущий пользователь не может обновить пост @endunless

// если для действия не требуется экземпляр модели, то можно указать политику авторизации через класс
@can('create', App\Models\Post::class) текущий пользователь может создавать посты @endcan
@cannot('create', App\Models\Post::class) текущий пользователь не может создавать посты @endcannot

// комментарии Blade не включаются в итоговый HTML
{{-- --}}
</code></pre>
        <p>Components (компоненты) - это многоразовые элементы интерфейса, созданные с помощью команды artisan или вручную на основе классов или анонимных функций и могут содержать:</p>
        <ul>
          <li>другие компоненты, шаблоны и директивы Blade</li>
          <li>методы и события, которые могут быть вызваны из шаблона</li>
          <li>атрибуты, которые могут быть переданы в шаблон</li>
          <li>свойства, которые могут быть доступны из шаблона</li>
          <li>слоты, которые могут быть заполнены другими компонентами или шаблонами</li>
          <li>компоненты автоматически обнаруживаются в каталогах app/View/Components и resources/views/components</li>
        </ul>
        <table>
          <caption>создать компонент
            <tbody>
              <tr>
                <td>php artisan make:component Alert</td>
                <td>на основе класса</td>
              </tr>
              <tr>
                <td>php artisan make:component Alert --inline</td>
                <td>на основе встроенного шаблона</td>
              </tr>
              <tr>
                <td>php artisan make:component forms.input --view</td>
                <td>анонимный компонент</td>
              </tr>
            </tbody>
          </caption>
        </table>
        <pre><code>// отобразить компонент
< x-forms.input />

// отобразить компонент на основе полученного значения или переменной ($componentName = "secondary-button";)   
< x-dynamic-component :component="$componentName" class="mt-4" />

// если shouldRender() вернёт true - компонент отражается, false - нет
use Illuminate\Support\Str;
public function shouldRender(): bool
{return Str::length($this->message) > 0;}

// выражения и переменные PHP передавать компоненту через атрибуты c символом : впереди
< x-alert type="error" :message="$message"/>
</code></pre>
        <p>общедоступные данные в конструкторе класса компонента доступны в шаблоне компонента</p>
        <pre><code>namespace App\View\Components;
use Illuminate\View\Component;
use Illuminate\View\View;
class Alert extends Component
{
  public function __construct(public string $type, public string $message) { }
  public function render(): View {return view('components.alert');}
}
< div class="alert alert-{{ $type }}">{{ $message }}< /div>

// аргументы конструктора в camelCase, а аргументы в атрибутах HTML в kebab-case
public function __construct(public string $alertType) { }
< x-alert alert-type="danger"/>

// при одинаковых именах атрибута и переменной можно сократить
// сокращенный синтаксис атрибутов
< x-profile :$userId :$name />

// эквивалентно
< x-profile :user-id="$userId" :name="$name" />

// так как Alpine.js тоже использует префикс :, то добавить ещё : для РНР
// шаблон Blade
< x-button ::class="{ danger: isDeleting }"> отправить< /x-button>

// HTML
< button :class="{ danger: isDeleting }">отправить< /button>

// в классе компонента можно задать метод
// в классе
public function isSelected(string $option): bool {return $option === $this->selected;}

// в шаблоне
< option {{ $isSelected($value) ? 'selected' : '' }} value="{{ $value }}">{{ $label }}< /option>

// все атрибуты не из конструктора компонента автоматически добавляются в $attributes
// HTML
< div {{ $attributes }}>содержание компонента< /div>

// слияние атрибутов
// компонент
< div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>{{ $message }}< /div>

// шаблон
< x-alert type="error" :message="$message" class="mb-4"/>

// HTML
< div class="alert alert-error mb-4">содержимое переменной $message< /div>

// либо
< button {{ $attributes->merge(['type' => 'button']) }}>{{ $slot }}< /button>

// фильтрация атрибутов
// оставит атрибут если true, остальные удалит
{{ $attributes->filter(fn (string $value, string $key) => $key == 'foo') }}

// начинается с
{{ $attributes->whereStartsWith('wire:model') }}

// не начинается с
{{ $attributes->whereDoesntStartWith('wire:model') }}

// проверить есть ли атрибут
@if ($attributes->has('class'))
  < div> атрибут class присутствует < /div>
@endif

@if ($attributes->has(['name', 'class']))
  < div> все указанные атрибуты присутствуют < /div>
@endif

@if ($attributes->hasAny(['href', ':href', 'v-bind:href']))
  < div> один из указанных атрибутов присутствует < /div>
@endif

// получить атрибут
{{ $attributes->get('class') }}         // получить значение атрибута
{{ $attributes->only(['class']) }}      // только по ключу
{{ $attributes->except(['class']) }}    // кроме тех кто с ключом

// вынести классы в одну переменную
@php
  $classes = 'className1 className2';
@endphp
< div {{ $attributes(['class' => $classes]) }}>{{ $slot }}< /div>

// менять вид компонента, изменяя свойства компонента в вёрстке
@props(['size' => 'base'])
@php
  $classes = "className1 className2";
  if ($size === 'base') {$classes .= " className3";}
  if ($size === 'small') {$classes .= " className4";}
@endphp
< a href="#" class="{{ $classes }}">{{ $slot }}< /a>
</code></pre>
        <p>Anonymous Components - компоненты, которые не имеют класса и создаются с помощью встроенного шаблона в resources/views/components</p>
        <pre><code>// resources/views/components/alert.blade.php
// в шаблоне
< x-alert/>

// либо resources/views/components/inputs/button.blade.php
// в шаблоне
< x-inputs.button/>

// компонент из нескольких компонентов
// /resources/views/components/accordion/accordion.blade.php
// /resources/views/components/accordion/item.blade.php
< x-accordion>
  < x-accordion.item>
    ...
  < /x-accordion.item>
< /x-accordion>

// переменные и атрибуты
// в компоненте
// info - значение по умолчанию
@props(['type' => 'info', 'message'])
< div {{ $attributes->merge(['class' => 'alert alert-'.$type]) }}>{{ $message }}< /div>

// в шаблоне
< x-alert type="error" :message="$message" class="mb-4"/>

// задать свой путь к анонимному компоненту
// для panel.blade.php
App\Providers\AppServiceProvider
public function boot(): void {Blade::anonymousComponentPath(__DIR__.'/../components');}

// в шаблоне
< x-panel />

// либо с пространством имен
Blade::anonymousComponentPath(__DIR__.'/../components', 'dashboard');
// в шаблоне
< x-dashboard::panel />
</code></pre>
        <p>Slots - это области в шаблоне компонента для заполнения другими компонентами или шаблонами, могут быть именованными или анонимными и содержать:</p>
        <ul>
          <li>другие слоты</li>
          <li>атрибуты и данные, которые могут быть переданы в шаблон</li>
          <li>методы и события, которые могут быть вызваны из шаблона</li>
          <li>свойства, которые могут быть доступны из шаблона</li>
        </ul>
        <pre><code>// компонент
< span class="alert-title">{{ $title }}>< /span>
< div class="alert alert-danger">{{ $slot }}>< /div>

// шаблон
< x-alert>
  < x-slot:title>
    // Ошибка сервера
  < /x-slot>
  // Упс! Что-то пошло не так!
< /x-alert>

// существует ли контент
// комментарий считается контентом
< span class="alert-title">{{ $title }}>< /span>
< div class="alert alert-danger">
  @if ($slot->isEmpty()) Это содержимое по умолчанию, если слот пуст.
  @else{{ $slot }}
  @endif
< /span>

// без комментария
@if ($slot->hasActualContent()) В области нет комментариев. @endif

// доступ к данным и методам класса компонента из слота
< x-alert>
  < x-slot:title>{{ $component->formatAlert('Ошибка сервера') }}< /x-slot>
  Упс! Что-то пошло не так!
< /x-alert>

// доступ к атрибутам слота из компонента
@props(['heading','footer'])
< div {{ $attributes->class(['border']) }}>
  < h1 {{ $heading->attributes->class(['text-lg']) }}>{{ $heading }}< /h1>
  {{ $slot }}
  < footer {{ $footer->attributes->class(['text-gray-700']) }}>{{ $footer }}< /footer>
< /div>

// разметка в классе компонента
public function render(): string
{
  return <<<blade
    < div class="alert alert-danger">{{ $slot }}< /div>
  blade;
}
</code></pre>
        <p>Layouts - шаблоны, которые могут содержать:</p>
        <ul>
          <li>другие макеты, шаблоны и компоненты</li>
          <li>атрибуты, которые могут быть переданы в шаблон</li>
          <li>методы и события, которые могут быть вызваны из шаблона</li>
          <li>свойства, которые могут быть доступны из шаблона</li>
          <li>слоты, которые могут быть заполнены другими компонентами или шаблонами</li>
        </ul>
        <pre><code>// resources/views/components/layout.blade.php
< html>
  < head>
    < title>{{ $title ?? 'Менеджер задач' }}< /title>
  < /head>
  < body>
    < h1>Задачи< /h1>
    < hr/>
    {{ $slot }}
  < /body >
< /html>

// resources/views/tasks.blade.php
< x-layout>
  < x-slot:title>пользовательский заголовок< /x-slot>
  @foreach ($tasks as $task)
    < div>{{ $task }}< /div>
  @endforeach
< /x-layout>

// app/routes/web.php
use App\Models\Task;
Route::get('/tasks', function () {return view('tasks', ['tasks' => Task::all()]);});

// наследование
// resources/views/layouts/app.blade.php
< html>
  < head>< title>Имя приложения - @yield('title')< /title>< /head>
  < body>
    // определяет и дополняет секцию
    @section('sidebar') Это главная боковая панель. @show

    // @yield('content', 'Содержимое по умолчанию')
    < div class="container">@yield('content')< /div>
  < /body>
< /html>

// resources/views/child.blade.php
@extends('layouts.app')
@section('title', 'Название страницы')
@section('sidebar')
  // для добавления (а не перезаписи) содержимого к боковой панели макета
  @@parent
  < p>Это добавляется к главной боковой панели.< /p>
@endsection
@section('content')< p>Это содержимое моей страницы.< /p>@endsection
</code></pre>
        <table>
          <caption>URL - используется для генерации URL-адресов приложения
            <tr>
              <td>url("/posts/{$post->id}");</td>
              <td>http://example.com/posts/1</td>
            </tr>
            <tr>
              <td>// URL-адрес с запросом</td>
              <td></td>
            </tr>
            <tr>
              <td>echo url()->query('/posts', ['search' => 'Laravel']);</td>
              <td>https://example.com/posts?search=Laravel</td>
            </tr>
            <tr>
              <td>echo url()->query('/posts?sort=latest', ['search' => 'Laravel']);</td>
              <td>http://example.com/posts?sort=latest&search=Laravel</td>
            </tr>
            <tr>
              <td>echo url()->query('/posts?sort=latest', ['sort' => 'oldest']);</td>
              <td>http://example.com/posts?sort=oldest</td>
            </tr>
            <tr>
              <td>echo $url = url()->query('/posts', ['columns' => ['title', 'body']]);</td>
              <td>http://example.com/posts?columns%5B0%5D=title&columns%5B1%5D=body</td>
            </tr>
            <tr>
              <td>echo urldecode($url);</td>
              <td>http://example.com/posts?columns[0]=title&columns[1]=body</td>
            </tr>
            <tr>
              <td>// получить URL</td>
              <td></td>
            </tr>
            <tr>
              <td>echo url()->current();</td>
              <td>получить текущий URL без строки запроса</td>
            </tr>
            <tr>
              <td>echo url()->full();</td>
              <td>получить текущий URL, включая строку запроса</td>
            </tr>
            <tr>
              <td>echo url()->previous();</td>
              <td>получить полный URL-адрес предыдущего запроса</td>
            </tr>
          </caption>
        </table>
        <pre><code>// через фасад
use Illuminate\Support\Facades\URL;
echo URL::current();

// route помощник генерации URL-адресов для именованных маршрутов
Route::get('/post/{post}', function (Post $post) {})->name('post.show');

// http://example.com/post/1
echo route('post.show', ['post' => 1]);

// либо
Route::get(
  '/post/{post}/comment/{comment}',
  function (Post $post, Comment $comment) {})
->name('comment.show');

// http://example.com/post/1/comment/3
echo route('comment.show', ['post' => 1, 'comment' => 3]);

// что не является параметром машрута, то является запросом
// http://example.com/post/1?search=rocket
echo route('post.show', ['post' => 1, 'search' => 'rocket']);

// автоматически извлечь ключ маршрута из модели
route('post.show', ['post' => $post]);

// подписанные URL: URL-адрес с хешом «подписи», добавленный к строке запроса, чтобы защитить URL
// отказаться от подписки
use Illuminate\Support\Facades\URL;
return URL::signedRoute('unsubscribe', ['user' => 1]);

// исключить домен из хеша подписанного URL
return URL::signedRoute('unsubscribe', ['user' => 1], absolute: false);

// временный подписанный URL-адрес
return URL::temporarySignedRoute('unsubscribe', now()->addMinutes(30), ['user' => 1]);

// проверка подлиности подписанного URL
use Illuminate\Http\Request;
Route::get('/unsubscribe/{user}', function (Request $request) {
  if (! $request->hasValidSignature()) {abort(401);}
})->name('unsubscribe');

// игнорировать page и order при проверке подлиности подписанного URL
if (! $request->hasValidSignatureWhileIgnoring(['page', 'order'])) {abort(401);}

// signed из Illuminate\Routing\Middleware\ValidateSignature - это middleware для проверки подлинности подписанного URL
Route::post(
  '/unsubscribe/{user}',
  function (Request $request) {})
->name('unsubscribe')->middleware('signed');

// без включения домена в хеш подписи
Route::post(
  '/unsubscribe/{user}',
  function (Request $request) {})
->name('unsubscribe')->middleware('signed:relative');

// настроить в bootstrap/app.php свой ответ на недействительную подпись URL
use Illuminate\Routing\Exceptions\InvalidSignatureException;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->render(function (InvalidSignatureException $e) {
    return response()->view('errors.link-expired', status: 403);
  });
})

// URL для методов контроллера
use App\Http\Controllers\HomeController;
$url = action([HomeController::class, 'index']);

// с параметрами для метода контроллера
$url = action([UserController::class, 'profile'], ['id' => 1]);
</code></pre>
        <p>URL::defaults определяет значение по умолчанию для параметра запроса</p>
        <pre><code>// создать middleware
namespace App\Http\Middleware;
use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\URL;
use Symfony\Component\HttpFoundation\Response;
class SetDefaultLocaleForUrls {

  // \Closure(\Illuminate\Http\Request): (\Symfony\Component\HttpFoundation\Response)  $next
  @param
  public function handle(Request $request, Closure $next): Response {
    URL::defaults(['locale' => $request->user()->locale]);
    return $next($request);
}}

// дать в bootstrap/app.php приоритет выполнения middleware
->withMiddleware(function (Middleware $middleware) {$middleware->prependToPriorityList(
  before: \Illuminate\Routing\Middleware\SubstituteBindings::class,
  prepend: \App\Http\Middleware\SetDefaultLocaleForUrls::class,
);})
Route::get('/{locale}/posts', function () { })->name('post.index');
</code></pre>
        <p>Form, подмена метода формы</p>
        <pre><code>< form action="/example" method="POST">
  @method('PUT')
  @csrf
< /form>

// либо
< form action="/example" method="POST">
  < input type="hidden" name="_method" value="PUT">
  < input type="hidden" name="_token" value="{{ csrf_token() }}">
< /form>
</code></pre>
        <p>Alpinejs - к событию JS нужно добавить @. Например @click.</p>
        <table>
          <thead>
            <tr>
              <th>Directive</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[x-data](https://alpinejs.dev/directives/data)</td>
              <td>определяет часть HTML как компонент Alpinejs и предоставляет ему данные</td>
            </tr>
            <tr>
              <td>[x-init](https://alpinejs.dev/directives/init)</td>
              <td>позволяет выполнить действие в момент когда Alpinejs инициализирует элемент</td>
            </tr>
            <tr>
              <td>[x-show](https://alpinejs.dev/directives/show)</td>
              <td>показывает или прячет DOM элемент</td>
            </tr>
            <tr>
              <td>[x-bind](https://alpinejs.dev/directives/bind)</td>
              <td>устанавливает атрибуты HTML элемента на основании вычислений</td>
            </tr>
            <tr>
              <td>[x-on](https://alpinejs.dev/directives/on)</td>
              <td>выполняет код при получении события</td>
            </tr>
            <tr>
              <td>[x-text](href="https://alpinejs.dev/directives/text")</td>
              <td>вставляет текст в элемент</td>
            </tr>
            <tr>
              <td>[x-html](https://alpinejs.dev/directives/html)</td>
              <td>вставляет html разметку в элемент</td>
            </tr>
            <tr>
              <td>[x-model](https://alpinejs.dev/directives/model)</td>
              <td>связавыет значение с данными</td>
            </tr>
            <tr>
              <td>[x-modelable](https://alpinejs.dev/directives/modelable)</td>
              <td>указывает значение, которое нужно связать со значением x-model</td>
            </tr>
            <tr>
              <td>[x-for](https://alpinejs.dev/directives/for)</td>
              <td>создаёт DOM элементы перебирая массивы и объекты</td>
            </tr>
            <tr>
              <td>[x-transition](https://alpinejs.dev/directives/transition)</td>
              <td>плавное появление и исчезновение элемента</td>
            </tr>
            <tr>
              <td>[x-effect](https://alpinejs.dev/directives/effect)</td>
              <td>меняет элемент когда меняются его зависимости</td>
            </tr>
            <tr>
              <td>[x-ignore](https://alpinejs.dev/directives/ignore)</td>
              <td>Alpine пропускает этот элемент во время инициализации</td>
            </tr>
            <tr>
              <td>[x-ref](https://alpinejs.dev/directives/ref)</td>
              <td>обозначает элемент для $refs</td>
            </tr>
            <tr>
              <td>[x-cloak](https://alpinejs.dev/directives/cloak)</td>
              <td>скрывает элемент пока не загрузится Alpine - add to CSS [x-cloak] { display: none !important; }</td>
            </tr>
            <tr>
              <td>[x-teleport](https://alpinejs.dev/directives/teleport)</td>
              <td>переносит часть шаблона < template > в другую часть страницы</td>
            </tr>
            <tr>
              <td>[x-if](https://alpinejs.dev/directives/if)</td>
              <td>добавляет и удаляет элементы по словию</td>
            </tr>
            <tr>
              <td>[x-id](https://alpinejs.dev/directives/id)</td>
              <td>собирает в массив id сгенерированные с помощью $id, создаёт им scope и добавляет к ним суффикс</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>Magics</caption>
          <thead>
            <tr>
              <th>Magic</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[$el](https://alpinejs.dev/magics/el)</td>
              <td>выбирает текущий элемент</td>
            </tr>
            <tr>
              <td>[$refs](https://alpinejs.dev/magics/refs)</td>
              <td>выбирает элемент c x-ref</td>
            </tr>
            <tr>
              <td>[$store](https://alpinejs.dev/magics/store)</td>
              <td>доступ к глобальному хранилищу, созданного через Alpine.store()</td>
            </tr>
            <tr>
              <td>[$watch](https://alpinejs.dev/magics/watch)</td>
              <td>наблюдает за указанным элементом</td>
            </tr>
            <tr>
              <td>[$dispatch](https://alpinejs.dev/magics/dispatch)</td>
              <td>создает события браузера</td>
            </tr>
            <tr>
              <td>[$nextTick](https://alpinejs.dev/magics/nextTick)</td>
              <td>выполняет действие после после выполнения первого</td>
            </tr>
            <tr>
              <td>[$root](https://alpinejs.dev/magics/root)</td>
              <td>выбирает ближайший родительский элемент с x-data</td>
            </tr>
            <tr>
              <td>[$data](https://alpinejs.dev/magics/data)</td>
              <td>содежит значения всех x-data, через которых всплывает событие</td>
            </tr>
            <tr>
              <td>[$id](https://alpinejs.dev/magics/id)</td>
              <td>создаёт id для элементов избегая конфликтов одинаковых имён</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>Globals</caption>
          <thead>
            <tr>
              <th>Global</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[Alpine.data()](https://alpinejs.dev/globals/alpine-data)</td>
              <td>вынести контекст x-data в отдельную функцию и переиспользовать</td>
            </tr>
            <tr>
              <td>[Alpine.bind()](https://alpinejs.dev/globals/alpine-bind)</td>
              <td>вынести контекст x-data в отдельную функцию и переиспользовать</td>
            </tr>
            <tr>
              <td>[Alpine.store()](https://alpinejs.dev/globals/alpine-store)</td>
              <td>управление глобальным хранилищем</td>
            </tr>
          </tbody>
        </table>
        <p>Component Livewire - в livewire можно указывать роут на класс компонента</p>
        <pre><code>Route::get('/posts', ShowPosts::class);
Route::get('/posts/create', CreatePost::class);
</code></pre>
        <p>для этого необходимо создать шаблон для всех компонентов: components.layouts.app.blade.php</p>
        <pre><code>./sail artisan livewire:layout

// компонент имеет доступ к публичным свойствам и методам своего класса
php artisan make:livewire ComponentName

// либо
php artisan make:livewire component-name
    
// компонент в папке
php artisan make:livewire FolderName\\ComponentName

// либо
php artisan make:livewire folder-name.component-name

// компонент с тестом
./sail artisan make:livewire create-post --pest

// шаблон для компонентов livewire
./sail artisan livewire:layout

// разные шаблоны на весь класс
# [Layout('layouts.app')] 
class CreatePost extends Component { }

// разные шаблоны на методе
# [Layout('layouts.app')] 
public function render()
{
  return view('livewire.create-post');
}

// разные шаблоны динамически
public function render()
{
  return view('livewire.create-post')->layout('layouts.app'); 
}

// через @yield('content') указываю файл шаблона
< body>
  @yield('content')
< /body>
</code></pre>
        <p>Метод render() можно не указывать, Livewire будет автоматически выводить view с названием как у класса.  </p>
        <pre><code>// В класс User.php добавить подстановку title в шаблон
use Livewire\Attributes\Title;
# [Title('title')]

// подстановка title динамически
public function render()
{
  return view('livewire.create-post')->title('Create Post'); 
}

// задаю свойства livewire компонента в классе
public $title = 'Post title...';

// задаю свойства livewire компонента в виде
< h1>Title: "{{ $title }}"< /h1>

// дополнительные свойства при рендере в классе
return view('livewire.create-post')->with([
  'author' => Auth::user()->name,
]);

// дополнительные свойства при рендере в виде
Author: {{ $author }}

// при выводе в любом цикле всегда указывать ключ
@foreach ($posts as $post)
  < livewire:post-item :$post :key="$post->id">
  @livewire(PostItem::class, ['post' => $post], key($post->id))
@endforeach

// привязка ввода к свойству класса
< input type="text" id="title" wire:model="title">

// привязка ввода к методу класса
< form wire:submit="save">
  < button type="submit">Save</ button>
< /form>

// получить значения и очистить поля ввода
class ManageTodos extends Component
{
  public $todos = [];
  public $todo = '';
  public function addTodo()
  {
    $this->todos[] = $this->todo;
    $this->reset('todo'); 
  }
}

// получить значения и очистить поля ввода
class ManageTodos extends Component
{
  public $todos = [];

  public $todo = '';

  public function addTodo()
  {
    $this->todos[] = $this->pull('todo');
  }
}

// The same as $this->all() and $this->reset();
$this->pull();

// The same as $this->only(...) and $this->reset(...);
$this->pull(['title', 'content']);

// только авторизированный пользователь может изменить данные
public function update()
{
  $post = Post::findOrFail($this->id);
  $this->authorize('update', $post); 
  $post->update(...);
}

// изменение свойства возможно только внутри класса
class UpdatePost extends Component
{
  # [Locked] 
  public $id;
}

// свойства Eloquent моделей по умолчанию изменять возможно только внутри класса
class UpdatePost extends Component
{
  public Post $post; 
  public $title;
  public $content;
  
  public function update()
  {
    $this->post->update([
      'title' => $this->title,
      'content' => $this->content,
    ]);
    session()->flash('message', 'Post updated successfully!');
  }
}
</code></pre>
        <p>
          Cвойство # [Computed] кеширует запрошенные данные, чтобы не отправлять каждый раз новый запрос.<br/>
          Обращаться к свойству через объект $this->todos
        </p>
        <pre><code>use Livewire\Attributes\Computed;

# [Computed]
public function todos()
{
  return Auth::user()
    ->todos()
    ->select(['title', 'content'])
    ->get();
}

public function markAllComplete() 
{
  $this->todos->each->complete();
}
</code></pre>
        <p>Вывод компонента в Blade view</p>
        <pre><code>< livewire:create-post />

// вывод компонента в Blade view со значением
< livewire:create-post title="Initial Title" />

// вывод компонента в Blade view с динамическим значением переменной
< livewire:create-post :title="$initialTitle" />
</code></pre>
        <p>Инициализация переменной в классе при подключении компонента</p>
        <pre><code>class CreatePost extends Component
{
  public $title;
  public function mount($title = null)
  {
    $this->title = $title;
  }
}

// livewire инициализирует переменную автоматически
class CreatePost extends Component
{
  public $title;
}
</code></pre>
        <p>Инлайн компонент - это один файл где разметка внутри метода render()</p>
        <pre><code>./sail artisan make:livewire CreatePost --inline

// в routes/web.php добавить
use App\Livewire\User\User;
Route::get('user', User::class);

// в классе UserCreate.php добавить переход на страницу uri без перезагрузки страницы с сервера
$this->redirect('/user', navigate: true);
</code></pre>
        <p>Подключить assets в layout/app.blade.php</p>
        <pre><code>@assets
  < script src="https://cdn.jsdelivr.net/npm/pikaday/pikaday.js" defer>< /script>
  < link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css">
@endassets

@vite(['resources/css/app.css', 'resources/js/app.js'])
</code></pre>
        <p>При выполнении метода с # [Renderless] метод render() этого же класса не выполняется, либо skipRender() внутри метода</p>
        <pre><code># [Renderless] 
public function incrementViewCount()
{
  $this->post->incrementViewCount();
}

public function incrementViewCount()
{
  $this->post->incrementViewCount();
  $this->skipRender(); 
}
</code></pre>
        <p>Можно выносить части Livewire компонентов в Blade компоненты</p>
        <pre><code>< form wire:submit="save">
  < x-input-text name="title" wire:model="title" />
  < x-input-text name="content" wire:model="content" />
  < button type="submit">Save</ button>
< /form>

// blade компонент
@props(['name'])
< input type="text" name="{{ $name }}" {{ $attributes }}>
< div>
    @error($name) < span class="error">{{ $message }}< /span> @enderror
< /div>
</code></pre>
        <p>Events livewire</p>
        <pre><code>// породить событие post-created
$this->dispatch('post-created', title: $post->title);

// по событию выполнить метод в любом компоненте
# [On('post-created')] 
public function updatePostList($title) { }

// породить событие post-created с динамическим аттрибутом
$this->dispatch("post-updated.{$post->id}");

# [On('post-updated.{post.id}')]

// презагрузить родительский компонент, если в дочернем компоненте будет событие saved
< livewire:edit-post @saved="$refresh">

вызвать метод close() родительского компонента, если в дочернем компоненте будет saved конткретного postId
< livewire:edit-post @saved="close($event.detail.postId)">
</code></pre>
        <p>Actions</p>
        <pre><code>// $refresh - проверяет БД и отображает на странице
< button type="button" wire:click="$refresh">...< /button>

// $commit - отслеживает изменения компонета на сервере
< button type="button" wire:click="$commit">...< /button>
</code></pre>
        <p>Event listeners - Livewire поддерживает любые событыя браузера, например wire:transitionend  </p>
        <ul>
          <li>wire:click</li>
          <li>wire:submit</li>
          <li>wire:keydown</li>
          <li>wire:keyup</li>
          <li>wire:mouseenter</li>
        </ul>
        <table>
          <tbody>
            <tr>
              <td>wire:*</td>
              <td>любой текст после wire: может быть названием события</td>
            </tr>
            <tr>
              <td>wire:loading</td>
              <td>загрузчик</td>
            </tr>
            <tr>
              <td>wire:click="delete({{ $post->id }})"</td>
              <td>передать в класс параметр</td>
            </tr>
            <tr>
              <td>wire:click="$parent.removePost({{ $post->id }})"</td>
              <td>обращаюсь к методу родительского компонента</td>
            </tr>
            <tr>
              <td>wire:click="$set('query', '')"</td>
              <td>заменил значение свойства query на пустую строку</td>
            </tr>
            <tr>
              <td>wire:click="$toggle('sortAsc')"</td>
              <td>при каждом нажатии меняет true/false</td>
            </tr>
          </tbody>
        </table>
        <pre><code>< button wire:click="$toggle('sortAsc')">
  Sort {{ $sortAsc ? 'Descending' : 'Ascending' }}
< /button>

// $event - даёт доступ к событиям JS, например при нажатии enter
wire:click="$dispatch('post-deleted')" - срабатывает событие

// передать значение ввода в search() - метод класса компонента
< input type="text" wire:keydown.enter="search($event.target.value)">

// wire:dirty.class="border-yellow" - позволяет менять класс, если значение поля отличается от значения этого поля в БД
< input type="text" wire:model.blur="title" wire:dirty.class="border-yellow">
</code></pre>
        <p>Пока поле ввода title будет в фокусе, будет Unsaved..., когда фокус уйдёт, значение будет записано в БД и Unsaved... исчезнет</p>
        <pre><code>< input type="text" wire:model.blur="title">
< div wire:dirty wire:target="title">Unsaved...< /div>
</code></pre>
        <p>Validation livewire -  в основном такая же как в ларавел, но метод validate() применяется на объекте компонента. Метод validate() возвращает массив отвалидированных данных либо массив ошибок.</p>
        <pre><code>public function save()
{
  $validated = $this->validate([ 
    'title' => 'required|min:3',
    'content' => 'required|min:3',
  ]);
  Post::create($validated);
  return redirect()->to('/posts');
}
</code></pre>
        <p>В форме ввода не фронте отобразить ошибку валидации с помощью, директивы @error(), по ключу title выводиться значение $message.</p>
        <pre><code>< input type="text" wire:model="title">
< div>@error('title') {{ $message }} @enderror< /div>
</code></pre>
        <p>Задать правила валидации можно разными способами</p>
        <pre><code>// методом validate()
$validated = $this->validate([
  // массивом
  'name' => ['required', 'min:2', 'max:30'],

  // строкой через разделитель
  'email' => 'required|email|max:30',
  'password' => 'required|min:6',
]);

// параметром # [Validate()], отслеживает изменение значений и использует стандартные валидаторы ларавел

// свой текст сообщения
# [Validate('required', message: 'Имя обязательно')]

// своё имя поля в сообщении
# [Validate('min:2', as: 'Name')]
# [Validate('max:30')]
public string $name;

// написать свои правила валидации
protected function rules(): array
{
  return [
    'name' => ['required', 'min:2', 'max:30'],
    'email' => 'required|email|max:30',
    'password' => 'required|min:6',
  ];
}

// написать свои тексты сообщений об ошибке
protected function messages(): array
{
  return [
    // название поля.валидатор => текст ошибки
    'name.required' => 'Имя обязательно!',
    'name.min' => 'Имя должно быть длиннее!',
    'email.required' => 'Введите почту!',
    'password.required' => 'Пароль обязателен!',
  ];
}
</code></pre>
        <p>Если правила валидации заданы параметром # [Validate()] или методом rules(), то метод validate() вызываем без параметров</p>
        <pre><code>$validated = $this->validate();

// cоздаю пользователя в БД
code User::create($validated);
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>wire:model.blur="name"</td>
              <td>real-time validation работает по событию .live либо .blur при использовании параметра валидирования # [Validate()]</td>
            </tr>
            <tr>
              <td>wire:model.live="name"</td>
              <td>отправляет на сервер введенный знак сразу</td>
            </tr>
            <tr>
              <td>wire:model.live.debounce="name"</td>
              <td>отправляет на сервер введенное значение через 200мс после последнего нажатия</td>
            </tr>
            <tr>
              <td>wire:model.live.debounce.5ms="name"</td>
              <td>отправляет на сервер введенное значение через 5мс после нажатия</td>
            </tr>
          </tbody>
        </table>
        <p>Form livewire</p>
        <ul>
          <li>Свойства и методы формы вынесены в отдельный класс UserForm</li>
          <li>В компоненте User объект класса UserForm определён как form</li>
          <li>Обращения к свойствам класса UserForm через form</li>
          <li>B компоненте создаю форму и меняю действие по умолчанию на вызов метода save из класса</li>
          <li>Форма вызывает метод обработки при нажатии на enter или на кнопку Save</li>
          <li>B полях ввода данных привязываю данные к свойствам компонента</li>
          <li>Свойство компонента wire:model привязывает к полю ввода свойство класса wire:model='name'</li>
        </ul>
        <pre><code>< form wire:submit.prevent="save">
  < input type="text" wire:model="name">
  < input type="email" wire:model="email">
  < button type="submit">Save< /button>
< /form>
</code></pre>
        <ul>
          <li>B методе сохранения данных вызываю метод валидации данных</li>
          <li>Если данные валидны, то сохраняю данные в БД</li>
          <li>Если данные не валидны, то вывожу ошибку</li>
        </ul>
        <pre><code>public function save()
{
  $validated = $this->validate([
    'name' => 'required|min:3',
    'email' => 'required|email',
  ]);
  User::create($validated);
}

// вывести ошибку валидации можно c помощью директивы @error(), по ключу name выводится значение $message
< input type="text" wire:model="name">
< div>@error('name') {{ $message }} @enderror< /div>

// вывести ошибку валидации можно c помощью директивы @error(), по ключу name выводится значение $message
< input type="text" wire:model="name">
< div>@error('name') {{ $message }} @enderror< /div>

// вывести ошибку валидации можно c помощью директивы @error()б по ключу name выводится значение $message
< input type="text" wire:model="name">
</code></pre>
        <p>Данные формы</p>
        <pre><code>// получить все данные формы
$this->all();

// получить данные выборочных полей
$this->only(['name', 'email'])

// метод pull() - это метод only() + reset(), заберёт из формы данные полей name и email и очистит поля формы name и email
$this->pull(['name', 'email'])

// заберёт из формы все данные и очистит форму
$this->pull();

// Создать класс формы в app/Livewire/Forms/FormName.php
php artisan livewire:form FormName

// в классе компонента
public UserForm $form;
public function save()
{$this->form->saveUser();}

// в шаблоне компонента
wire:model="form.name"
</code></pre>
        <p>Tailwindcss</p>
        <table>
          <tbody>
            <tr>
              <td>npx tailwindcss init</td>
              <td>создать файл tailwind.config.js</td>
            </tr>
            <tr>
              <td>npm init -y</td>
              <td>создать файл package.json</td>
            </tr>
          </tbody>
        </table>
        <p>
          для компиляции tailwindcss в обычный css и следить за изменениями<br/>
          записать "tailwind": "npx tailwindcss -i ./src/input.css -o ./build/css/style.css --watch",<br/>
          в script файла package.json для запуска по команде npm run tailwind
        </p>
        <p>
          установить плагин prettier для tailwindcss в зависимости для разработки<br/>
          добавить "prettier": "npx prettier --write ./build/*.html" в script файла package.json<br/>
          для форматирования html и упорядочивания классов tailwindcss
        </p>
        <pre><code>npm i -D prettier-plugin-tailwindcss

// tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {

  // указать где искать классы tailwindcss
  content: ['./build/*.html'],
  theme: {
    extend: {},
  },
  plugins: [],
}

// input.css - импортировать библиотеки tailwind: base, components, utilities
@tailwind base;
@tailwind components;
@tailwind utilities;

// создать свой класс
.radial-blue {
  background: radial-gradient(lightyellow, skyblue)
}

// index.html
< !DOCTYPE html>
< html lang="en">
  < head>
    < meta charset="UTF-8" />
    < meta http-equiv="X-UA-Compatible" content="IE=edge" />
    < meta name="viewport" content="width=device-width, initial-scale=1.0" />
    < title>Document< /title>
    < link rel="stylesheet" href="css/style.css" />
  < /head>

  < body class="min-h-screen grid place-content-center radial-blue">
    < div class="bg-emerald-500 w-52 h-52 rounded-full shadow-2xl grid place-content-center">
      < div class="bg-teal-200 w-32 h-32 rounded-full grid place-content-center">
        < div class="bg-red-500 w-16 h-16 rounded-full">< /div>
      < /div>
    < /div>
  < /body>
< /html>
</code></pre>
        <p>Vite - это инструмент сборки на JavaScript и CSS, использует ES-модули и поддерживает:</p>
        <ul>
          <li>HMR (горячая перезагрузка модулей) для быстрой разработки</li>
          <li>TypeScript, JSX, CSS и другие языки</li>
          <li>плагины для расширения функциональности</li>
          <li>SSR (серверный рендеринг) для создания приложений с серверным рендерингом</li>
          <li>предварительную выборку, предзагрузку и кеширование ресурсов для оптимизации загрузки: vite компелирует, кеширует и отслеживает изменения в папке resources</li>
        </ul>
        <pre><code>// resources/views/components/layout.blade.php создаю компонент layout, вставляю компонент на страницу
< x-layout>< /x-layout>

// в файле .env указать место хранения загружаемых файлов, варианты значений в файле config/filesystems.php
FILESYSTEM_DISK=public

// при загрузке изображения оно будет сохранено в storage/app/public, чтобы оно отображалось сделать ссылку:
php artisan storage:link

// встроенные шаблоны для писем
./sail artisan vendor:publish --tag=laravel-mail

</code></pre>
        <p>Blade</p>
        <pre><code>// vite.config.ts
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
export default defineConfig({
  plugins: [
    laravel({
      input: ['resources/css/app.css', 'resources/js/app.js'],
      refresh: true,
    }),
  ],
});

// в корневом шаблоне
< head>@vite(['resources/css/app.css', 'resources/js/app.js'])< /head>
</code></pre>
        <p>SPA</p>
        <pre><code>// vite.config.ts
laravel({

  // точка входа vite в приложение
  input: 'resources/js/app.tsx',

  // точка входа ssr в приложение
  ssr: 'resources/js/ssr.tsx',

  // обновит браузер при сохранении файла
  refresh: true,
}),

// resources/js/app.tsx - точка входа в SPA-приложение
// импорт CSS в resources/js/app.tsx
import '../css/app.css';

// в корневом шаблоне
< head>
  @viteReactRefresh
  @vite(['resources/js/app.jsx'])
< /head>

// подключить ресурсы в resources/js/app.js для обработки 
import.meta.glob([
  '../images/**',
  '../fonts/**',
]);

// в шаблоне
< img src="{{ Vite::asset('resources/images/logo.png') }}">
</code></pre>
        <p>в App\Providers\AppServiceProvider</p>
        <pre><code>public function boot(): void

// создать макрос
{Vite::macro('image', fn (string $asset) => $this->asset("resources/images/{$asset}"));}

// в шаблоне
< img src="{{ Vite::image('logo.png') }}" alt="Laravel Logo">

// предварительная выборка рессурсов при загрузке приложения
public function boot(): void

// максимум три параллельные загрузки вместе с загрузкой страницы
{Vite::prefetch(concurrency: 3);}

// загрузить всё параллельно с загрузкой страницы
{Vite::prefetch();}

// предзагрузка в ручную по событию
{Vite::prefetch(event: 'vite:prefetch');}

// в шаблоне отправить событие для загрузки русурсов через три секунды после загрузки страницы
< script>
  addEventListener('load', () => setTimeout(() => {dispatchEvent(new Event('vite:prefetch'))}, 3000))
< /script>
</code></pre>
        <p>отключить vite для всех тестов</p>
        <pre><code>namespace Tests;
use Illuminate\Foundation\Testing\TestCase as BaseTestCase;
abstract class TestCase extends BaseTestCase
{
  protected function setUp(): void {parent::setUp();}
}

// отключить vite в одном тесте
test('without vite example', function () {$this->withoutVite();});
</code></pre>
        <p>Vue: Nuxt.js & Gridsome - SSR & SSG frameworks on Vue (fullstack & генератор статических сайтов)</p>
        <pre><code>npm i json-server
npm i vue-spinner

//options Api
< script>...< /script>

// composition Api
< script setup>...< /script>

< script>< /script>         
< template>< /template>
< style>< /style>

//глобальные стили
< style>

// локальные стили
< style scoped>

// локальные стили с препроцессором
< style scoped lang="sass">
  .block {
    color: $text-red;
  }
< /style>
</code></pre>
        <p>Counter</p>
        <pre><code>// App.vue
< script>
  import Counter from './Counter.vue';

  // описать доступные компоненты
  export default {
    components: {
      Counter
    }
  }
< /script>

< template>
  < Counter />
< /template>


// Counter.vue
< script>
  export default {
    data() {
      return { count: 0 }
    },
    methods: {
      inc() { this.count++ }
    }
  }
< /script>

// composition api
< script setup>
  import { ref } from 'vue';

  const count = ref(0);

  const inc = () => count.value++;
< /script>

< template>
  < h1>{{ count }}< /h1>
  < button @click="inc">+1< /button>
< /template>
</code></pre>
        <p>Реактивность: мгновенное отображение изменения данных приложения</p>
        <pre><code>// в Сomposition Api
ref() - для строк, чисел, булевых и т.д.
reactive() - для объектов и массивов
</code></pre>
        <p>Жизненный цикл компонента:</p>
        <ul>
          <li>создание</li>
          <li>отображение</li>
          <li>обновление</li>
          <li>удаление</li>
        </ul>
        <table>
          <caption>Lifecycle Hooks:</caption>
          <tbody>
            <tr>
              <td>onBeforeMount()</td>
              <td>перед монтированием</td>
            </tr>
            <tr>
              <td>onMounted()</td>
              <td>компонент монтирован</td>
            </tr>
            <tr>
              <td>onBeforeUpdate()</td>
              <td>при изменении реактивных данных и перед повторным рендерингом</td>
            </tr>
            <tr>
              <td>onUpdated()</td>
              <td>после перерендеринга</td>
            </tr>
            <tr>
              <td>onBeforeUnmount()</td>
              <td>перед размонтированием</td>
            </tr>
            <tr>
              <td>onUnmounted()</td>
              <td>после размонтирования</td>
            </tr>
            <tr>
              <td>onActivated()</td>
              <td>поддерживаемый компонент активный</td>
            </tr>
            <tr>
              <td>onDeactivated()</td>
              <td>поддерживаемый компонент неактивный</td>
            </tr>
            <tr>
              <td>onErrorCaptured()</td>
              <td>получена ошибка от потомка</td>
            </tr>
          </tbody>
        </table>
        <pre><code>import { onMounted } from 'vue';
onMounted(() => { console.log('Компонент отрендерен'); })

import { onUnmounted } from 'vue';
onUnmounted(() => { console.log('Компонент удалён'); })
</code></pre>
        <table>
          <caption>Директивы:</caption>
          <tbody>
            <tr>
              <td>v-text</td>
              <td>вставить текст</td>
            </tr>
            <tr>
              <td>v-html</td>
              <td>вставить html, {{ }}</td>
            </tr>
            <tr>
              <td>v-show</td>
              <td>отобразить/скрыть элемент (display: none)</td>
            </tr>
            <tr>
              <td>v-if, v-else, v-else-if</td>
              <td>отрисовать элемент по условию</td>
            </tr>
            <tr>
              <td>v-for</td>
              <td>цикл для массива, отрисовка списка html-элементов</td>
            </tr>
            <tr>
              <td>v-model</td>
              <td>двухсторонняя привязка к элементу ввода формы (input, textarea, checkbox, etc.)</td>
            </tr>
            <tr>
              <td>v-bind</td>
              <td>привязать к элементу html-атрибуты или передать данные в компонент, :</td>
            </tr>
            <tr>
              <td>v-on</td>
              <td>прикрепить обработчик событий, @</td>
            </tr>
          </tbody>
        </table>
        <pre><code>< script setup>
  const msg = "some text";
< /script>

< template>
  < h1>{{ msg }}< /h1>
< /template>

// либо
< template>
  < h1 v-text="msg">< /h1>
< /template>

< script setup>
  const isAdded = ref(true);
< /script>

< template>
  < div v-if="!isAdded">
    < button>Добавить товар< /button>
    < h3>Цена: 1500< /h3>
  < /div>

  < div v-else>
    < button>Удалить товар< /button>
  < /div>
< /template>

< script lang="ts" setup>< /script>
< template lang="pug">< /template>
< style lang="scss" scoped>< /style>
</code></pre>
        <p>
          Shadcn<br/>
          Точка входа - root, в разметке index.html создать div с id=root, к которому будем цеплять jsx - точка входа
        </p>
        <pre><code>< div id=root>< /div>

// прикрепить файл с кодом jsx
< script src="/index.jsx" type="module">< /script>

// в jsx файле создать корень react-приложения
import { createRoot } from "react-dom/client"
const root = createRoot(document.getElementById("root"))
root.render(< h1>Hello world!< /h1>)

// либо
import { createRoot } from "react-dom/client"
const root = createRoot(document.querySelector("#root"))
root.render(< h1>Hello world!< /h1>)

// либо
import ReactDom from "react-dom/client"
ReactDom.createRoot(document.querySelector("#root")).render(< h1>Hello world!< /h1>)
</code></pre>
        <p>Создать элемент: createElement(elemen, props, children in element) - возвращает JSON</p>
        <pre><code>import { createElement } from "react"
import { createRoot } from "react-dom/client"

const root = createRoot(document.querySelector("#root"))
root.render(
  createElement("h1", null, "Hello world!")
)

// reactElement содержит JSON
import { createElement } from "react"
import { createRoot } from "react-dom/client"

const root = createRoot(document.querySelector("#root"))
const reactElement = createElement("h1", null, "Hello world!")
root.render(reactElement)

// вернёт тот же JSON
import { createRoot } from "react-dom/client"
const root = createRoot(document.querySelector("#root"))
const reactElement = < h1>Hello world!")</ h1>
root.render(reactElement)
</code></pre>
        <p>Создать компонент</p>
        <pre><code>import { createRoot } from "react-dom/client"

const root = createRoot(document.querySelector("#root"))

function MyFirstComponent() {

  // return (нужны скобки если несколько строк)
  return < h1>Hello world!< /h1>
}

root.render(
  < div>
    < MyFirstComponent />
  < /div>
)

// императивный код ванила JS
const h1 = document.createElement("h1")
h1.textContent = "Hello world!"
h1.className = "header"
document.getElementById("root").appendChild(h1)

// декларативный код react
import { createRoot } from "react-dom/client"
createRoot(document.getElementById("root")).render(< h1 className="header">Hello world!< /h1>)</code></pre>
        <h2>Data</h2>
        <p>Encryption</p>
        <ul>
          <li>шифрование - это процесс преобразования данных в неразборчивый вид с помощью алгоритма шифрования</li>
          <li>дешифрование - это процесс преобразования зашифрованных данных в исходный вид с помощью алгоритма дешифрования</li>
          <li>Laravel использует библиотеку OpenSSL и Sodium для шифрования и дешифрования данных</li>
          <li>ключ шифрования хранится в переменной окружения APP_KEY в .env файле</li>
          <li>параметр key в config/app.php устанавливается через APP_KEY в .env</li>
          <li>ключ шифрования должен быть уникальным для каждого приложения случайным набором символов длинной 32 байта или 256 бит и защищёным от доступа посторонних</li>
          <li>драйверы шифрования: bcrypt, argon, argon2id, scrypt, md5, sha1, sha256, sha512, whirlpool, ripemd160, tiger1600, haval1600, gost, gost-crypto</li>
          <li>при изменении ключа все сеансы аутентификации пользователей будут завершены</li>
        </ul>
        <pre><code>// сгенерировать ключ
php artisan key:generate

// для плавной смены ключа предыдущие ключи шифрования указать в переменной окружения APP_PREVIOUS_KEYS
APP_KEY="base64:J63qRTDLub5NuZvP+kb8YIorGS6qFYHKVo6u7179stY="
APP_PREVIOUS_KEYS="base64:2nLsGFGzyoae2ax3EF2Lyq/hH6QghBGLIq5uL+Gp8/w="

// зашифровать значение
namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Crypt;
class DigitalOceanTokenController extends Controller {
  public function store(Request $request): RedirectResponse {
    $request->user()->fill(['token' => Crypt::encryptString($request->token)])->save();
    return redirect('/secrets');
}}

// расшифровать значения
use Illuminate\Contracts\Encryption\DecryptException;
use Illuminate\Support\Facades\Crypt;
try {$decrypted = Crypt::decryptString($encryptedValue);}
catch (DecryptException $e) { }
</code></pre>
        <p>Hashing (хеширование) - это необратимый процесс преобразования данных в неразборчивый вид с помощью алгоритма хеширования, используется для хранения паролей и проверки целостности, подлинности, идентичности, уникальности, безопасности, доступности, конфиденциальности данных.</p>
        <ul>
          <li>Laravel использует библиотеку Hash, Argon2, Bcrypt, Argon2id для хеширования данных</li>
          <li>драйвер хеширования bcrypt, argon и argon2id указан в переменной HASH_DRIVER в .env</li>
          <li>HASH_VERIFY в .env: true - сверять алгоритм хеширования пароля с установленным, false - любой алгоритм хеширования</li>
        </ul>
        <pre><code>// опубликовать файл конфигурации хеширования для настройки параметров драйвера хеширования
php artisan config:publish hashing

namespace App\Http\Controllers;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
class PasswordController extends Controller {

  // Обновить пароль пользователя
  public function update(Request $request): RedirectResponse
  {
    $request->user()->fill(['password' => Hash::make($request->newPassword)])->save();
    return redirect('/profile');
}}
// коэффициент работы Bcrypt
$hashed = Hash::make('password', ['rounds' => 12]);

// коэффициент работы Argon2
$hashed = Hash::make('password', ['memory' => 1024, 'time' => 2, 'threads' => 2]);

// сверить хеш
if (Hash::check('plain-text', $hashedPassword)) { }

// нужно ли повторно хешировать
if (Hash::needsRehash($hashed)) {$hashed = Hash::make('plain-text');}
</code></pre>
        <p>Password Reset - для сброса пароля нужно:</p>
        <ul>
          <li>в AppModelsUser: IlluminateNotificationsNotifiable, IlluminateContractsAuthCanResetPassword</li>
          <li>в 0001_01_01_000000_create_users_table.php токен сброса пароля</li>
          <li>в bootstrap/app.php указать trustHosts - отвечать только на запросы указанных хостов</li>
          <li>форма запроса ссылки сброса пароля с полем для email</li>
        </ul>
        <pre><code>Route::get('/forgot-password', function () {return view('auth.forgot-password');
})->middleware('guest')->name('password.request');

// сверить почту и отправить на неё ссылку
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Password;
Route::post('/forgot-password', function (Request $request) {
  $request->validate(['email' => 'required|email']);
  $status = Password::sendResetLink($request->only('email'));
  return $status === Password::ResetLinkSent
    ? back()->with(['status' => __($status)])
    : back()->withErrors(['email' => __($status)]);
})->middleware('guest')->name('password.email');

// форма ввода нового пароля, после перехода по ссылке сброса пароля
Route::get('/reset-password/{token}', function (string $token) {
  return view('auth.reset-password', ['token' => $token]);
})->middleware('guest')->name('password.reset');

// проверка входящего запроса и обновление пароля пользователя в базе данных
use App\Models\User;
use Illuminate\Auth\Events\PasswordReset;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Facades\Password;
use Illuminate\Support\Str;
Route::post('/reset-password', function (Request $request) {
  $request->validate([
    'token' => 'required',
    'email' => 'required|email',
    'password' => 'required|min:8|confirmed',
  ]);
  $status = Password::reset(
    $request->only('email', 'password', 'password_confirmation', 'token'),
    function (User $user, string $password) {$user->forceFill(['password' => Hash::make($password)
      ])->setRememberToken(Str::random(60));
      $user->save();
      event(new PasswordReset($user));
  });
  return $status === Password::PasswordReset
    ? redirect()->route('login')->with('status', __($status))
    : back()->withErrors(['email' => [__($status)]]);
})->middleware('guest')->name('password.update');

// удалить просроченные токены
php artisan auth:clear-resets

// для автоматизации добавить в планировщик
use Illuminate\Support\Facades\Schedule;
Schedule::command('auth:clear-resets')->everyFifteenMinutes();

// в App\Providers\AppServiceProvider изменить URL-адрес ссылки для сброса пароля
use App\Models\User;
use Illuminate\Auth\Notifications\ResetPassword;
public function boot(): void
{
  ResetPassword::createUrlUsing(function (User $user, string $token) {
    return 'https://example.com/reset-password?token='.$token;
  });
}

// свой вариант уведомления для отправки пользователю ссылки для сброса пароля
use App\Notifications\ResetPasswordNotification;
public function sendPasswordResetNotification($token): void
{
  $url = 'https://example.com/reset-password?token='.$token;
  $this->notify(new ResetPasswordNotification($url));
}
</code></pre>
        <p>SQL-request creation: либо построитель SQL-запросов, либо Eloquent ORM</p>
        <ul>
          <li>Конфигурация баз данных в config/database.php</li>
          <li>Параметры конфигурации определяются значениями переменных окружения в .env</li>
          <li>Фасад DB содержит методы для каждого типа запроса: select, update, insert, delete, и statement</li>
        </ul>
        <table>
          <tbody>
            <tr>
              <td>php artisan db</td>
              <td>подключиться к базе данных</td>
            </tr>
            <tr>
              <td>php artisan db mysql</td>
              <td>подключиться к базе данных и указать имя соединения</td>
            </tr>
            <tr>
              <td>php artisan db:show</td>
              <td>просмотр БД</td>
            </tr>
            <tr>
              <td>php artisan db:show --database=pgsql</td>
              <td>просмотр БД с именем соединения</td>
            </tr>
            <tr>
              <td>php artisan db:show --counts --views</td>
              <td>количество строк и представления для просмотра</td>
            </tr>
            <tr>
              <td>php artisan db:table users</td>
              <td>обзор отдельной таблицы</td>
            </tr>
            <tr>
              <td>php artisan db:monitor --databases=mysql,pgsql --max=100</td>
              <td>мониторить соединения mysql и pgsql каждую минуту и отправить событие</td>
            </tr>
          </tbody>
        </table>
        <p>Illuminate\Database\Events\DatabaseBusy при количестве открытых соединений больше 100, в App\Providers\AppServiceProvider</p>
        <pre><code>// слушатель SQL-запроса
namespace App\Providers;
use Illuminate\Database\Events\QueryExecuted;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void
  {
    DB::listen(function (QueryExecuted $query) {
      // $query->sql;
      // $query->bindings;
      // $query->time;
      // $query->toRawSql();
    });
}}

// вызвать функцию когда время выполнения запроса дольше указанного
namespace App\Providers;
use Illuminate\Database\Connection;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\ServiceProvider;
use Illuminate\Database\Events\QueryExecuted;
class AppServiceProvider extends ServiceProvider {
  public function register(): void { }
  public function boot(): void
  {DB::whenQueryingForLongerThan(500, function (Connection $connection, QueryExecuted $event) { });}
}

// слушать событие Illuminate\Database\Events\DatabaseBusy 
use App\Notifications\DatabaseApproachingMaxConnections;
use Illuminate\Database\Events\DatabaseBusy;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Notification;
public function boot(): void {
  Event::listen(function (DatabaseBusy $event) {
    Notification::route('mail', 'dev@example.com')->notify(new DatabaseApproachingMaxConnections(
      $event->connectionName,
      $event->connections
    ));
});}
</code></pre>
        <p>Illuminate\Support\Facades\Schema;</p>
        <pre><code>// проверка БД
use Illuminate\Support\Facades\Schema;
$tables = Schema::getTables();
$views = Schema::getViews();
$columns = Schema::getColumns('users');
$indexes = Schema::getIndexes('users');
$foreignKeys = Schema::getForeignKeys('users');

// проверить соединение с БД
$columns = Schema::connection('sqlite')->getColumns('users');
</code></pre>
        <p>Illuminate\Support\Facades\DB</p>
        <pre><code>// показать список всех пользователей приложения
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
use Illuminate\View\View;
class UserController extends Controller {
  public function index(): View {
    $users = DB::select('select * from users where active = ?', [1]);
    return view('user.index', ['users' => $users]);
}}

// select всегда возвращает массив
$users = DB::select('select * from users');
foreach ($users as $user) {echo $user->name;}

// чтобы получить значение в виде числа
$burgers = DB::scalar("select count(case when food = 'burger' then 1 end) as burgers from menu");

// получить все наборы результатов, возвращенных хранимой процедурой
[$options, $notifications] = DB::selectResultSets(
  "CALL get_user_options_and_notifications(?)", $request->user()->id
);

// связывания параметров, используя именованные привязки
$results = DB::select('select * from users where id = :id', ['id' => 1]);

// insert
DB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);

// update
$affected = DB::update('update users set votes = 100 where name = ?',['Anita']);

// delete 
$deleted = DB::delete('delete from users');

// запрос общего типа
DB::statement('drop table users');

// запрос SQL без привязки каких-либо значений
DB::unprepared('update users set votes = 100 where name = "Dries"');

// Если в config/database.php несколько соединений, то получить доступ к соединению с помощью метода connection
$users = DB::connection('sqlite')->select(/* ... */);

// получить доступ к базовому экземпляру PDO текущего соединения
$pdo = DB::connection()->getPdo();

// выполнение набора операций в транзакции
DB::transaction(function () {
    DB::update('update users set votes = 1');
    DB::delete('delete from posts');
});
// либо с количеством попыток при взаимоблокировке
DB::transaction(function () {
    DB::update('update users set votes = 1');
    DB::delete('delete from posts');
}, 5);

// транзакция вручную
DB::beginTransaction();   // начать транзакцию
DB::rollBack();           // откатить транзакцию
DB::commit();             // зафиксировать транзакцию

// получить все строки таблицы
$users = DB::table('users')->get();

// получить доступ к значению каждого столбца
$users = DB::table('users')->get();
foreach ($users as $user) {echo $user->name;}

// получить одну строку или один столбец
$user = DB::table('users')->where('name', 'John')->first();
return $user->email;
// либо если строки может не быть
$user = DB::table('users')->where('name', 'John')->firstOrFail();

// получить одно значение из строки
$email = DB::table('users')->where('name', 'John')->value('email');

// получить одну строку по значению столбца id
$user = DB::table('users')->find(3);

// получить значения одного столбца в виде коллекции
use Illuminate\Support\Facades\DB;
$titles = DB::table('users')->pluck('title');
foreach ($titles as $title) {echo $title;}

// получить значения одного столбца в виде коллекции с ключами из столбца name
$titles = DB::table('users')->pluck('title', 'name');
foreach ($titles as $name => $title) {echo $title;}

// извлекать данные частями
DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
  foreach ($users as $user) { }
});

// остановить обработку после получения части данных
DB::table('users')->orderBy('id')->chunk(100, function (Collection $users) {
    return false;
});

// при изменении данных одновременно с получением по частям
DB::table('users')->where('active', false)->chunkById(100, function (Collection $users) {
  foreach ($users as $user) {DB::table('users')->where('id', $user->id)->update(['active' => true]);}
});

// сгруппировать логически условия запроса
DB::table('users')->where(function ($query) {$query->where('credits', 1)->orWhere('credits', 2);
})->chunkById(100, function (Collection $users) {
  foreach ($users as $user) {DB::table('users')->where('id', $user->id)->update(['credits' => 3]);}
});

// метод lazy() возвращает данные по частям в виде экземпляра LazyCollection
DB::table('users')->orderBy('id')->lazy()->each(function (object $user) { });

// при изменении данных одновременно с получением по частям использовать методы lazyById или lazyByIdDesc
DB::table('users')->where('active', false)->lazyById()->each(function (object $user) {
  DB::table('users')->where('id', $user->id)->update(['active' => true]);
});

// построитель запросов также содержит методы count, max, min, avg, и sum
$users = DB::table('users')->count();
$price = DB::table('orders')->max('price');
// либо
$price = DB::table('orders')->where('finalized', 1)->avg('price');

// проверить существование записей
if (DB::table('orders')->where('finalized', 1)->exists()) { }
if (DB::table('orders')->where('finalized', 1)->doesntExist()) { }

// указать собственное выражение SELECT для запроса
$users = DB::table('users')->select('name', 'email as user_email')->get();

// вернуть уникальные результаты
$users = DB::table('users')->distinct()->get();

// добавить столбец к существующему выражению SELECT
$query = DB::table('users')->select('name');
$users = $query->addSelect('age')->get();

// cырые sql-выражения
$users = DB::table('users')->select(DB::raw('count(*) as user_count, status'))
  ->where('status', '<>', 1)->groupBy('status')->get();
$orders = DB::table('orders')->selectRaw('price * ? as price_with_tax', [1.0825])->get();
$orders = DB::table('orders')->whereRaw('price > IF(state = "TX", ?, 100)', [200])->get();
$orders = DB::table('orders')->select('department', DB::raw('SUM(price) as total_sales'))
  ->groupBy('department')->havingRaw('SUM(price) > ?', [2500])->get();
$orders = DB::table('orders')->orderByRaw('updated_at - created_at DESC')->get();
$orders = DB::table('orders')->select('city', 'state')->groupByRaw('city, state')->get();
$users = DB::table('users')->join('contacts', 'users.id', '=', 'contacts.user_id')
  ->join('orders', 'users.id', '=', 'orders.user_id')
  ->select('users.*', 'contacts.phone', 'orders.price')->get();
$users = DB::table('users')->leftJoin('posts', 'users.id', '=', 'posts.user_id')->get();
$users = DB::table('users')->rightJoin('posts', 'users.id', '=', 'posts.user_id')->get();
$sizes = DB::table('sizes')->crossJoin('colors')->get();
DB::table('users')->join('contacts', function (JoinClause $join) {
  $join->on('users.id', '=', 'contacts.user_id')->orOn(/* ... */);
})->get();
DB::table('users')->join('contacts', function (JoinClause $join) {
  $join->on('users.id', '=', 'contacts.user_id')->where('contacts.user_id', '>', 5);
})->get();

// присоединить запрос к подзапросу
$latestPosts = DB::table('posts')->select('user_id', DB::raw('MAX(created_at) as last_post_created_at'))
  ->where('is_published', true)->groupBy('user_id');
$users = DB::table('users')->joinSub($latestPosts, 'latest_posts', function (JoinClause $join) {
  $join->on('users.id', '=', 'latest_posts.user_id');
})->get();

// боковые соединения с подзапросом
// получить коллекцию пользователей, а также три последних блог-поста пользователя
$latestPosts = DB::table('posts')
  ->select('id as post_id', 'title as post_title', 'created_at as post_created_at')
  ->whereColumn('user_id', 'users.id')->orderBy('created_at', 'desc')->limit(3);
$users = DB::table('users')->joinLateral($latestPosts, 'latest_posts')->get();

// объединение двух или более запросов Unions
$first = DB::table('users')->whereNull('first_name');
$users = DB::table('users')->whereNull('last_name')->union($first)->get();
// запросы, объединенные с использованием метода unionAll, не будут удалять повторяющиеся результаты
$users = DB::table('users')->where('votes', '=', 100)->where('age', '>', 35)->get();
// либо
$users = DB::table('users')->where('votes', 100)->get();
// либо
$users = DB::table('users')->where('votes', '>=', 100)->get();
$users = DB::table('users')->where('votes', '<>', 100)->get();
$users = DB::table('users')->where('name', 'like', 'T%')->get();
// либо
$users = DB::table('users')->where([
  ['status', '=', '1'],
  ['subscribed', '<>', '1'],
])->get();

// метод orWhere для добавления к запросу с помощью оператора OR
$users = DB::table('users')->where('votes', '>', 100)->orWhere('name', 'John')->get();
// либо
$users = DB::table('users')->where('votes', '>', 100)->orWhere(function (Builder $query) {
  $query->where('name', 'Abigail')->where('votes', '>', 50);})->get();
// сформирует запрос: select * from users where votes > 100 or (name = 'Abigail' and votes > 50)

// методы whereNot и orWhereNot могут использоваться для отрицания заданной группы ограничений запроса
$products = DB::table('products')->whereNot(function (Builder $query) {
  $query->where('clearance', true)->orWhere('price', '<', 10);})->get();

// выбрать все записи, где хотя бы один столбец из списка соответствует определенному значению
$users = DB::table('users')->where('active', true)
  ->whereAny(['name', 'email', 'phone'],'like', 'Example%')->get();
// сформирует запрос: 
SELECT * FROM users
WHERE active = true AND (name LIKE 'Example%' OR email LIKE 'Example%' OR phone LIKE 'Example%')

// извлечение записей, где все указанные столбцы соответствуют заданному условию
$posts = DB::table('posts')->where('published', true)
  ->whereAll(['title', 'content'], 'like', '%Laravel%')->get();
// сформирует запрос:
SELECT * FROM posts
WHERE published = true AND (title LIKE '%Laravel%' AND content LIKE '%Laravel%')

// извлечения записей, в которых ни один из заданных столбцов не соответствует заданному ограничению
$posts = DB::table('albums')->where('published', true)
  ->whereNone(['title', 'lyrics', 'tags'], 'like', '%explicit%')->get();
// сформирует запрос:
SELECT * FROM albums
WHERE published = true
AND NOT ( title LIKE '%explicit%' OR lyrics LIKE '%explicit%' OR tags LIKE '%explicit%')

// запрос к столбцу типа JSON
$users = DB::table('users')->where('preferences->dining->meal', 'salad')->get();

// запрос массивов JSON
$users = DB::table('users')->whereJsonContains('options->languages', 'en')->get();
// либо
$users = DB::table('users')->whereJsonContains('options->languages', ['en', 'de'])->get();

// длина массива JSON
$users = DB::table('users')->whereJsonLength('options->languages', 0)->get();
$users = DB::table('users')->whereJsonLength('options->languages', '>', 1)->get();

// сопоставления с образцом
$users = DB::table('users')->whereLike('name', '%John%')->get();

// включить поиск с учетом регистра
$users = DB::table('users')->whereLike('name', '%John%', caseSensitive: true)->get();
// либо с условием LIKE
$users = DB::table('users')->where('votes', '>', 100)->orWhereLike('name', '%John%')->get();
// не такой как образец
$users = DB::table('users')->whereNotLike('name', '%John%')->get();
// либо с условием NOT LIKE
$users = DB::table('users')->where('votes', '>', 100)->orWhereNotLike('name', '%John%')->get();

// значение переданного столбца содержится в указанном массиве
$users = DB::table('users')->whereIn('id', [1, 2, 3])->get();

// значение переданного столбца не содержится в указанном массиве
$users = DB::table('users')->whereNotIn('id', [1, 2, 3])->get();

// объект запроса как аргумент
$activeUsers = DB::table('users')->select('id')->where('is_active', 1);
$users = DB::table('comments')->whereIn('user_id', $activeUsers)->get();
// сформирует запрос
select * from comments where user_id in (select id from users where is_active = 1)

// проверяет, что значение столбца находится между двумя значениями
$users = DB::table('users')->whereBetween('votes', [1, 100])->get();

// проверяет, что значение столбца находится за пределами двух значений
$users = DB::table('users')->whereNotBetween('votes', [1, 100])->get();

// проверяет, что значение столбца находится между двумя значениями двух столбцов в одной строке таблицы
$patients = DB::table('patients')
  ->whereBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])->get();

// проверяет, что значение столбца находится за пределами двух значений двух столбцов в одной строке таблицы
$patients = DB::table('patients')
  ->whereNotBetweenColumns('weight', ['minimum_allowed_weight', 'maximum_allowed_weight'])->get();

// проверяет, что значение переданного столбца равно NULL
$users = DB::table('users')->whereNull('updated_at')->get();

// проверяет, что значение переданного столбца не равно NULL
$users = DB::table('users')->whereNotNull('updated_at')->get();

// сравнение значения столбца с датой
$users = DB::table('users')->whereDate('created_at', '2016-12-31')->get();

// сравнение значения столбца с конкретным месяцем
$users = DB::table('users')->whereMonth('created_at', '12')->get();

// сравнение значения столбца с определенным днем месяца
$users = DB::table('users')->whereDay('created_at', '31')->get();

// сравнение значения столбца с конкретным годом
$users = DB::table('users')->whereYear('created_at', '2016')->get();

// сравнение значения столбца с определенным временем
$users = DB::table('users')->whereTime('created_at', '=', '11:20:45')->get();

// проверка равенства двух столбцов
$users = DB::table('users')->whereColumn('first_name', 'last_name')->get();
// либо
$users = DB::table('users')->whereColumn('updated_at', '>', 'created_at')->get();
// либо
$users = DB::table('users')->whereColumn([
  ['first_name', '=', 'last_name'], ['updated_at', '>', 'created_at']])->get();

// всегда группировать вызовы метода orWhere в круглых скобках
$users = DB::table('users')->where('name', '=', 'John')->where(function (Builder $query) {
  $query->where('votes', '>', 100)->orWhere('title', '=', 'Admin');})->get();
// сформирует запрос
select * from users where name = 'John' and (votes > 100 or title = 'Admin')

// WHERE EXISTS
$users = DB::table('users')->whereExists(function (Builder $query) {
  $query->select(DB::raw(1))->from('orders')->whereColumn('orders.user_id', 'users.id');
})->get();
// либо
$orders = DB::table('orders')->select(DB::raw(1))->whereColumn('orders.user_id', 'users.id');
$users = DB::table('users')->whereExists($orders)->get();
// в обоих случаях получим
select * from users where exists (select 1 from orders where orders.user_id = users.id)

// сравнивает результаты подзапроса с переданным значением
$users = User::where(function (Builder $query) {
  $query->select('type')->from('membership')->whereColumn('membership.user_id', 'users.id')
    ->orderByDesc('membership.start_date')->limit(1);}, 'Pro')->get();

// сравнивает столбец с результатами подзапроса
$incomes = Income::where('amount', '<', function (Builder $query) {
  $query->selectRaw('avg(i.amount)')->from('incomes as i');})->get();

// whereFullText и orWhereFullText добавят полнотекстовые “условия” в запрос для столбцов, имеющих полнотекстовые индексы
$users = DB::table('users')->whereFullText('bio', 'web developer')->get();

// сортировать результаты запроса по конкретному столбцу
$users = DB::table('users')->orderBy('name', 'desc')->get();
// либо
$users = DB::table('users')->orderBy('name', 'desc')->orderBy('email', 'asc')->get();

// latest и oldest: упорядочить результаты по дате, по умолчанию по столбцу created_at, либо указать столбец сортировки
$user = DB::table('users')->latest()->first();

// сортировка результатов запроса в случайном порядке
$randomUser = DB::table('users')->inRandomOrder()->first();

// Метод reorder удаляет все примененные выражения ORDER BY
$query = DB::table('users')->orderBy('name');
$unorderedUsers = $query->reorder()->get();

// удалить все существующие выражения ORDER BY и применить к запросу совершенно новый порядок
$query = DB::table('users')->orderBy('name');
$usersOrderedByEmail = $query->reorder('email', 'desc')->get();

// группировка результатов запроса
$users = DB::table('users')->groupBy('account_id')->having('account_id', '>', 100)->get();

// фильтрация результатов в заданном диапазоне
$report = DB::table('orders')->selectRaw('count(id) as number_of_orders, customer_id')
  ->groupBy('customer_id')->havingBetween('number_of_orders', [5, 15])->get();

// группировка по нескольким столбцам
$users = DB::table('users')->groupBy('first_name', 'status')->having('account_id', '>', 100)->get();
// take: ограничить количество результатов, возвращаемых запросом
// skip: пропустить указанное количество результатов из запроса
$users = DB::table('users')->skip(10)->take(5)->get();
// либо limit и offset
$users = DB::table('users')->offset(10)->limit(5)->get();

// применить выражение при условии: when выполняет переданную функцию если первый аргумент равен true
$role = $request->input('role');
$users = DB::table('users')->when($role, function (Builder $query, string $role) {
  $query->where('role_id', $role);})->get();

// второя переданная when функция будет выполнена если первый аргумент равен false
$sortByVotes = $request->boolean('sort_by_votes');
$users = DB::table('users')->when($sortByVotes, function (Builder $query, bool $sortByVotes) {
  $query->orderBy('votes');}, function (Builder $query) {$query->orderBy('name');})->get();

// вставка записей в таблицу БД
DB::table('users')->insert(['email' => 'kayla@example.com', 'votes' => 0]);

// каждый из массивов это запись, которую нужно вставить в таблицу
DB::table('users')->insert([
  ['email' => 'picard@example.com', 'votes' => 0],
  ['email' => 'janeway@example.com', 'votes' => 0],
]);

// игнорировать ошибки при вставке записей в базу данных
DB::table('users')->insertOrIgnore([
  ['id' => 1, 'email' => 'sisko@example.com'],
  ['id' => 2, 'email' => 'archer@example.com'],
]);

// вставляет новые записи в таблицу, используя подзапрос
DB::table('pruned_users')->insertUsing(['id', 'name', 'email', 'email_verified_at'],
DB::table('users')->select('id', 'name', 'email', 'email_verified_at')
->where('updated_at', '<=', now()->subMonth()));

// вставить запись и затем получить идентификатор этой записи
$id = DB::table('users')->insertGetId(['email' => 'john@example.com', 'votes' => 0]);

// вставляет записи, которые не существуют, и обновляет записи, которые уже существуют, новыми значениями
// попытается вставить две записи. Если запись уже существует с такими же значениями столбцов departure и destination, то обновит столбец price этой записи
DB::table('flights')->upsert([
  ['departure' => 'Oakland', 'destination' => 'San Diego', 'price' => 99],
  ['departure' => 'Chicago', 'destination' => 'New York', 'price' => 150]
], ['departure', 'destination'], ['price']);

// обновить существующие записи
$affected = DB::table('users')->where('id', 1)->update(['votes' => 1]);

// Если запись существует, она будет обновлена значениями второго аргумента.
// Если запись не может быть найдена, будет вставлена новая запись с объединенными атрибутами обоих аргументов
DB::table('users')->updateOrInsert(['email' => 'john@example.com', 'name' => 'John'], ['votes' => '2']);
// либо через условие
DB::table('users')->updateOrInsert(['user_id' => $user_id],fn ($exists) => $exists 
  ? ['name' => $data['name'],'email' => $data['email']]
  : ['name' => $data['name'], 'email' => $data['email'], 'marketable' => true]);

// обновление столбца JSON
$affected = DB::table('users')->where('id', 1)->update(['options->enabled' => true]);

// методы увеличения или уменьшения значения конкретного столбца
DB::table('users')->increment('votes', 5);
DB::table('users')->decrement('votes', 5);
// либо
DB::table('users')->increment('votes', 1, ['name' => 'John']);

// увеличивать или уменьшать значения нескольких столбцов с помощью методов incrementEach и decrementEach
DB::table('users')->incrementEach(['votes' => 5, 'balance' => 100]);

// удалить записи из таблицы
$deleted = DB::table('users')->delete();
$deleted = DB::table('users')->where('votes', '>', 100)->delete();

// удаление всех записей из таблицы и сброс автоинкрементного идентификатора на ноль
DB::table('users')->truncate();

// предотвратить изменение выбранных строк до тех пор, пока транзакция не будет зафиксирована
DB::table('users')->where('votes', '>', 100)->sharedLock()->get();

// предотвращает изменение выбранных записей
DB::table('users')->where('votes', '>', 100)->lockForUpdate()->get();

// отобразить связанные параметры запроса и сам SQL-запрос
DB::table('users')->where('votes', '>', 100)->dd();
DB::table('users')->where('votes', '>', 100)->dump();
// либо
DB::table('users')->where('votes', '>', 100)->dumpRawSql();
DB::table('users')->where('votes', '>', 100)->ddRawSql();
</code></pre>
        <p>Collections (коллекции) - это итераторы, которые можно перебирать как массив</p>
        <pre><code>use App\Models\User;
$users = User::where('active', 1)->get();
foreach ($users as $user) {echo $user->name;}

// коллекции поддерживают map и reduce
$names = User::all()->reject(function (User $user) {return $user->active === false;})
  ->map(function (User $user) {return $user->name;});</code></pre>
        <ul>
          <li>все коллекции Eloquent расширяют базовый класс коллекций Laravel</li>
          <li>методы collapse, flatten, flip, keys, pluck, и zip возвращают экземпляр базовой коллекции</li>
          <li>коллекции Eloquent наследуют все методы класса базовой коллекции и содержит расширенный набор методов</li>
        </ul>
        <pre><code>// указать, что атрибут должен быть добавлен к каждой записи в коллекции
$users->append('team');

// либо
$users->append(['team', 'is_admin']);

// содержится ли запись в коллекции
$users->contains(1);

// либо
$users->contains(User::find(1));
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>$users = $users->diff(User::whereIn('id', [1, 2, 3])->get());</td>
              <td>возвращает все записи, которых нет в переданной коллекции</td>
            </tr>
            <tr>
              <td>$users = $users->except([1, 2, 3]);</td>
              <td>озвращает все записи, у которых нет указанных первичных ключей</td>
            </tr>
            <tr>
              <td>
                $users = User::all();
                $user = $users->find(1);
              </td>
              <td>возвращает запись по указанному ключу</td>
            </tr>
            <tr>
              <td>
                $users = User::all();
                $user = $users->findOrFail(1);
              </td>
              <td>возвращает запись по указанному ключу или исключение</td>
            </tr>
            <tr>
              <td>$users = $users->fresh();</td>
              <td>возвращает обновлённые записи</td>
            </tr>
            <tr>
              <td>$users = $users->fresh('comments');</td>
              <td>возвращает обновлённые записи с отношением</td>
            </tr>
            <tr>
              <td>$users = $users->intersect(User::whereIn('id', [1, 2, 3])->get());</td>
              <td>возвращает записи, которые присутствуют в указанной коллекции</td>
            </tr>
            <tr>
              <td>
                $users->load(['comments', 'posts']);
                $users->load('comments.author');
                $users->load(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);
              </td>
              <td>загружает указанные отношения для всех записей в коллекции</td>
            </tr>
            <tr>
              <td>
                $users->loadMissing(['comments', 'posts']);
                $users->loadMissing('comments.author');
                $users->loadMissing(['comments', 'posts' => fn ($query) => $query->where('active', 1)]);
              </td>
              <td>загружает ещё незагруженные отношения для всех записей в коллекции</td>
            </tr>
            <tr>
              <td>$users->modelKeys();</td>
              <td>возвращает первичные ключи для всех записей в коллекции [1, 2, 3, 4, 5]</td>
            </tr>
            <tr>
              <td>$users = $users->makeVisible(['address', 'phone_number']);</td>
              <td>делает видимыми скрытые атрибуты записей из коллекции</td>
            </tr>
            <tr>
              <td>$users = $users->makeHidden(['address', 'phone_number']);</td>
              <td>делает скрытыми атрибуты записей из коллекции</td>
            </tr>
            <tr>
              <td>$users = $users->only([1, 2, 3]);</td>
              <td>возвращает все записи с указанными первичными ключами</td>
            </tr>
            <tr>
              <td>$users = $users->setVisible(['id', 'name']);</td>
              <td>временно переопределяет видимые атрибуты для каждой записи в коллекции</td>
            </tr>
          </tbody>
        </table>
        <pre><code>// временно переопределяет скрытые атрибуты для каждой записи в коллекции
$users = $users->setHidden(['email', 'password', 'remember_token']);

// возвращает экземпляр построителя запросов
use App\Models\User;
$users = User::where('status', 'VIP')->get();
$users->toQuery()->update(['status' => 'Administrator']);

// возвращает уникальные записи в коллекции
$users = $users->unique();

// удаления записей из полученной коллекции
$flights = Flight::where('destination', 'Paris')->get();
$flights = $flights->reject(function (Flight $flight) {return $flight->cancelled;});

// перебирать коллекции
foreach ($flights as $flight) {echo $flight->name;}

// получать коллекцию записей частями
use App\Models\Flight;

use Illuminate\Database\Eloquent\Collection;
// 200 - количество записей за «порцию» к каждой порции применяется function (Collection $flights) {}
Flight::chunk(200, function (Collection $flights) {foreach ($flights as $flight) { }});

// извлекать записи со столбцом id, большим, чем у последней записи в предыдущей «порции»
Flight::where('departed', true)->chunkById(200, function (Collection $flights) {
  $flights->each->update(['departed' => false]);}, column: 'id');

// логическая группировка в запросе
Flight::where(function ($query) {$query->where('delayed', true)->orWhere('cancelled', true);})
  ->chunkById(200, function (Collection $flights) {
  $flights->each->update(['departed' => false, 'cancelled' => true]);}, column: 'id');

// lazy() возвращает каждую порцию записей как отдельную коллекцию
foreach (Flight::lazy() as $flight) { }

// lazyById извлекает записи со столбцом id, большим, чем у последней записи в предыдущей «порции»
Flight::where('departed', true)->lazyById(200, column: 'id')->each->update(['departed' => false]);
// lazyByIdDesc - отфильтровать результаты по убыванию id

// при использовании cursor будет только один запрос к БД и только одна модель хранится в памяти в любой момент времени при итерации
foreach (Flight::where('destination', 'Zurich')->cursor() as $flight) { }
// либо
$users = User::cursor()->filter(function (User $user) {return $user->id > 500;});
foreach ($users as $user) {echo $user->id;}

// извлечь информацию из связанных таблиц в одном запросе
// выбрал все пункты назначения и рейсы, которые прибыли последними в этот пункт назначения
use App\Models\Destination;
use App\Models\Flight;
return Destination::addSelect(['last_flight' => Flight::select('name')->whereColumn('destination_id', 'destinations.id')
  ->orderByDesc('arrived_at')->limit(1)])->get();
// отсортировал пункты назначения по последнему рейсу
return Destination::orderByDesc(Flight::select('arrived_at')->whereColumn('destination_id', 'destinations.id')
  ->orderByDesc('arrived_at')->limit(1))->get();

// использовать собственный объект Collection
namespace App\Models;
use App\Support\UserCollection;
use Illuminate\Database\Eloquent\Attributes\CollectedBy;
use Illuminate\Database\Eloquent\Model;
# [CollectedBy(UserCollection::class)]
class User extends Model { }
// либо
namespace App\Models;
use App\Support\UserCollection;
use Illuminate\Database\Eloquent\Collection;
use Illuminate\Database\Eloquent\Model;
class User extends Model {
  public function newCollection(array $models = []): Collection
  {return new UserCollection($models);}}

// в App\Providers\AppServiceProvider
// определить макрос
use Illuminate\Support\Collection;
use Illuminate\Support\Str;
public function boot(): void {
  Collection::macro('toUpper', function () {
    return $this->map(function (string $value) {return Str::upper($value);});});

// вызвать макрос в любом месте приложения
$collection = collect(['first', 'second']);
$upper = $collection->toUpper();
либо с дополнительными аргументами
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Lang;
Collection::macro('toLocale', function (string $locale) {
  return $this->map(function (string $value) use ($locale) {
    return Lang::get($value, [], $locale);});});

// вызвать макрос в любом месте приложения
$collection = collect(['first', 'second']);
$translated = $collection->toLocale('es');
</code></pre>
        <p>Класс Illuminate\Support\Collection обеспечивает гибкую и удобную обертку для работы с массивами данных</p>
        <pre><code>// создать новый экземпляр коллекции из массива
$collection = collect(['taylor', 'abigail', null])->map(function (?string $name) {
  return strtoupper($name);})->reject(function (string $name) {return empty($name);});

// создать коллекцию
$collection = collect([1, 2, 3]);
</code></pre>
        <p>Сообщения высшего порядка - сокращения для выполнения действий с коллекциями</p>
        <ul>
          <li>average</li>
          <li>avg</li>
          <li>contains</li>
          <li>each</li>
          <li>every</li>
          <li>filter</li>
          <li>first</li>
          <li>flatMap</li>
          <li>groupBy</li>
          <li>keyBy</li>
          <li>map</li>
          <li>max</li>
          <li>min</li>
          <li>partition</li>
          <li>reject</li>
          <li>skipUntil</li>
          <li>skipWhile</li>
          <li>some</li>
          <li>sortBy</li>
          <li>sortByDesc</li>
          <li>sum</li>
          <li>takeUntil</li>
          <li>takeWhile</li>
          <li>unique</li>
        </ul>
        <pre><code>// вызывать метод для каждого объекта коллекции
use App\Models\User;
$users = User::where('votes', '>', 500)->get();
$users->each->markAsVip();

// собрать общее количество «голосов» для коллекции пользователей
$users = User::where('group', 'Development')->get();
return $users->sum->votes;
</code></pre>
        <p>Отложенные коллекции использует генераторы PHP, чтобы работать с очень большим набором данных при низком потреблении памяти</p>
        <pre><code>// отложенные коллекции сохраняют в памяти только небольшую часть файла в текущий момент
use App\Models\LogEntry;
use Illuminate\Support\LazyCollection;
LazyCollection::make(function () {
  $handle = fopen('log.txt', 'r');
  while (($line = fgets($handle)) !== false) {yield $line;}
})->chunk(4)->map(function (array $lines) {return LogEntry::fromLines($lines);
})->each(function (LogEntry $logEntry) { Обработка записи журнала...});

// cursor возвращает LazyCollection: в течении одиного запроса к БД, модели Eloquent загружать в память и обрабатывать по одной
use App\Models\User;
$users = User::cursor()->filter(function (User $user) {return $user->id > 500;});
foreach ($users as $user) {echo $user->id;}

// создать экземпляр отложенной коллекции
use Illuminate\Support\LazyCollection;
LazyCollection::make(function () {
  $handle = fopen('log.txt', 'r');
  while (($line = fgets($handle)) !== false) {yield $line;}});
</code></pre>
        <p>Класс Collection и класс LazyCollection реализуют контракт Illuminate\Support\Enumerable, который определяет методы.</p>
        <pre><code>// дополнительно класс LazyCollection содержит методы:
// takeUntilTimeout - коллекция перечисляет значения до указанного времени
$lazyCollection = LazyCollection::times(INF)->takeUntilTimeout(now()->addMinute());
$lazyCollection->each(function (int $number) {
  dump($number);
  sleep(1);});
// либо запланировать отправку счетов из БД, которая запускается каждые 15 минут и обрабатывает счета максимум 14 минут
use App\Models\Invoice;
use Illuminate\Support\Carbon;
Invoice::pending()->cursor()->takeUntilTimeout(
  Carbon::createFromTimestamp(LARAVEL_START)->add(14, 'minutes'))->each(fn (Invoice $invoice) => $invoice->submit());

// tapEach вызывает переданное замыкание только тогда, когда элементы извлекаются из списка один за другим

// ничего не выведено
$lazyCollection = LazyCollection::times(INF)->tapEach(function (int $value) {dump($value);});

// три элемента выведено
$array = $lazyCollection->take(3)->all();

// throttle: каждое значение возвращается через указанное количество секунд
use App\Models\User;
User::where('vip', true)->cursor()->throttle(seconds: 1)
->each(function (User $user) { Вызов внешнего API... });

// remember запоминает любые значения, которые уже были перечислены, и не будет извлекать их снова

// запрос еще не выполнен
$users = User::cursor()->remember();

// первые 5 пользователей из БД включены в результирующую коллекцию
$users->take(5)->all();

// первые 5 пользователей из кеша коллекции, а стальные из БД включены в результирующую коллекцию
$users->take(20)->all();
</code></pre>
        <p>Pagination: paginate автоматически устанавливает «предел» и «смещение» в запросе на основе текущей страницы</p>
        <pre><code>// в tailwind.config.js
content: [
  './resources/**/*.blade.php',
  './resources/**/*.js',
  './resources/**/*.vue',
  './vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php']

// отобразить 15 элементов на странице
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
use Illuminate\Support\Facades\DB;
use Illuminate\View\View;
class UserController extends Controller {
  public function index(): View
  {return view('user.index', ['users' => DB::table('users')->paginate(15)]);}}

// отображать только простые ссылки «Далее» и «Назад» без общего количества страниц
$users = DB::table('users')->simplePaginate(15);

// разбить запросы Eloquent на страницы
use App\Models\User;
$users = User::paginate(15);

// либо
$users = User::where('votes', '>', 100)->paginate(15);

// либо
$users = User::where('votes', '>', 100)->simplePaginate(15);

// либо
$users = User::where('votes', '>', 100)->cursorPaginate(15);

// отобразить два отдельных модуля пагинации на одном экране:
// в третьем параметре указать имя страницы отдельно для каждого модуля пагинации
use App\Models\User;
$users = User::where('votes', '>', 100)->paginate($perPage = 15, $columns = ['*'], $pageName = 'users');
</code></pre>
        <ul>
          <li>paginate и simplePaginate создают запросы с использованием SQL-оператора “offset”</li>
          <li>Cursor-пагинация работает путем создания конструкции “where”</li>
          <li>пагинация на основе смещения включает номер страницы в строке запроса URL-адресов</li>
          <li>Курсор представляет собой закодированную строку, содержащую место, с которого следующий запрос с пагинацией должен начать постраничную навигацию, и направление, в котором он должен разбиваться на страницы</li>
        </ul>
        <table>
          <caption>$users = DB::table('users')->orderBy('id')->cursorPaginate(15);</caption>
          <thead>
            <tr>
              <th colspan="2">отобразить “вторую страницу” результатов для таблицы users, упорядоченных по id</th>
              <th></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>select * from users order by id asc limit 15 offset 15;</td>
              <td>offset пагинация</td>
            </tr>
            <tr>
              <td>select * from users where id > 15 order by id asc limit 15;</td>
              <td>cursor пагинация</td>
            </tr>
          </tbody>
        </table>
        <p>Преимущества Cursor-пагинация перед Offset-пагинацией:</p>
        <ul>
          <li>Для больших наборов данных Cursor-пагинация обеспечивать лучшую производительность, если столбцы “order by” проиндексированы. Это связано с тем, что предложение “offset” сканирует все ранее сопоставленные данные.</li>
          <li>Для наборов данных с частыми записями Offset-пагинация может пропускать записи или отображать дубликаты, если результаты были недавно добавлены или удалены со страницы, которую пользователь просматривает в данный момент.</li>
        </ul>
        <p>Ограничения Cursor-пагинации:</p>
        <ul>
          <li>Как и simplePaginate, Cursor-пагинация может использоваться только для отображения ссылок “Далее” и “Назад” и не поддерживает создание ссылок с номерами страниц.</li>
          <li>Требуется, чтобы порядок был основан как минимум на одном уникальном столбце или на комбинации уникальных столбцов. - Столбцы с null – значениями не поддерживаются.</li>
          <li>Выражения запросов c “order by” поддерживаются только в том случае, если они имеют псевдоним и также добавлены в “select”.</li>
          <li>Выражения запросов с параметрами не поддерживаются.</li>
          <li>чтобы пагинатор генерировал ссылки типа &lt;http://example.com/admin/users?page=N&gt;</li>
        </ul>
        <pre><code>use App\Models\User;
Route::get('/users', function () {
  $users = User::paginate(15);
  $users->withPath('/admin/users');});

// добавить sort=votes к каждой ссылке пагинации
use App\Models\User;
Route::get('/users', function () {
  $users = User::paginate(15);
  $users->appends(['sort' => 'votes']);});

// добавить все значения строки текущего запроса к ссылкам постраничной навигации
$users = User::paginate(15)->withQueryString();

// добавить «хеш-фрагмент» к URL-адресам
$users = User::paginate(15)->fragment('users');
</code></pre>
        <ul>
          <li>вызов метода paginate возвращает экземпляр IlluminatePaginationLengthAwarePaginator</li>
          <li>вызов метода simplePaginate возвращает экземпляр IlluminatePaginationPaginator</li>
          <li>вызов метода cursorPaginate возвращает экземпляр IlluminatePaginationCursorPaginator</li>
          <li>экземпляры являются итераторами и могут быть перебраны как массив</li>
        </ul>
        <pre><code>< div class="container">@foreach ($users as $user){{ $user->name }}@endforeach</ div>

// links отрисует ссылки с переменной запроса page на остальные страницы
{{ $users->links() }}
</code></pre>
        <ul>
          <li>HTML, сгенерированный методом links, совместим с фреймворком Tailwind CSS</li>
          <li>пагинатор отображает навигационные ссылки, включающие номер текущей страницы, а также ссылки для трех страниц до и после текущей</li>
          <li>контролировать, сколько дополнительных ссылок отображается с каждой стороны от текущей страницы</li>
        </ul>
        <pre><code>{{ $users->onEachSide(5)->links() }}

// преобразовать экземпляр пагинатора в JSON, вернув его из маршрута или действия контроллера
use App\Models\User;
Route::get('/users', function () {return User::paginate();});

// передать свой шаблон отображения навигационных ссылок пагинации
{{ $paginator->links('view.name') }}

// передача дополнительных данных в шаблон
{{ $paginator->links('view.name', ['foo' => 'bar']) }}
</code></pre>
        <ul>
          <li>отредактировать встроенные шаблоны постраничной навигации</li>
          <li>файл tailwind.blade.php в resources/views/vendor/pagination - шаблон постраничной навигации по умолчанию</li>
        </ul>
        <pre><code>php artisan vendor:publish --tag=laravel-pagination

// назначить другой файл шаблоном постраничной навигации по умолчанию

namespace App\Providers;
use Illuminate\Pagination\Paginator;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider {
  public function boot(): void {
    Paginator::defaultView('view-name');
    Paginator::defaultSimpleView('view-name');}}
</code></pre>
        <p>
          Cache<br/>
          Данные, извлечение и обработка которых требуют больших ресурсов ЦП или занимает много времени, кешируют на некоторое время.<br/>
          Указать хранилище по умолчанию в config/cache.php.<br/>
          Драйверы array и null предоставляют удобные механизмы кеширования для автоматических тестов.<br/>
          По умолчанию драйвера кэша database с таблицей БД для кеша 0001_01_01_000001_create_cache_table.php
        </p>
        <pre><code>// создать таблицу БД для кеша
php artisan make:cache-table
php artisan migrate
</code></pre>
        <p>Memcached: перечислить серверы в config/cache.php</p>
        <pre><code>'memcached' => ['servers' => [[
  'host' => env('MEMCACHED_HOST', '127.0.0.1'),
  'port' => env('MEMCACHED_PORT', 11211),
  'weight' => 100]]]

// либо задать параметр host сокета UNIX
'memcached' => ['servers' => [[
  'host' => '/var/run/memcached/memcached.sock',
  'port' => 0,
  'weight' => 100]]]
</code></pre>
        <p>Redis: пакет Sail уже включает расширение PHP PhpRedis.</p>
        <ul>
          <li>Redis используется в качестве кэша и драйвера очереди</li>
          <li>драйвер Redis по умолчанию использует расширение phpredis</li>
          <li>расширение predis не поддерживается</li>
          <li>расширение phpredis поддерживает Redis 3.0 и выше</li>
          <li>кеширование данных в Redis</li>
          <li>кеширование представлений в Redis</li>
          <li>кеширование маршрутов в Redis</li>
          <li>кеширование конфигурации в Redis</li>
        </ul>
        <pre><code>php artisan config:cache
php artisan route:cache
php artisan view:cache
</code></pre>
        <p>методы</p>
        <pre><code>use Illuminate\Support\Facades\Redis;
Redis::set('key', 'value');
Redis::get('key');
Redis::del('key');
Redis::exists('key');
Redis::expire('key', 60);
Redis::ttl('key');
Redis::keys('*');
Redis::flushAll();
</code></pre>
        <p>DynamoDB:</p>
        <ul>
          <li>создать таблицу DynamoDB (обычно называется cache)</li>
          <li>указать название таблицы в параметре DYNAMODB_CACHE_TABLE в .env - запишется в параметр stores.dynamodb.table в config/cache.php</li>
          <li>строковый ключ раздела в config/cache.php (по умолчанию key).</li>
          <li>в поле таблицы expires_at имя атрибута TTL</li>
        </ul>
        <pre><code>// установить AWS SDK
composer require aws/aws-sdk-php

// в .env
'dynamodb' => [
  'driver' => 'dynamodb',
  'key' => env('AWS_ACCESS_KEY_ID'),
  'secret' => env('AWS_SECRET_ACCESS_KEY'),
  'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
  'table' => env('DYNAMODB_CACHE_TABLE', 'cache'),
  'endpoint' => env('DYNAMODB_ENDPOINT')]
</code></pre>
        <p>MongoDB: официальный пакет mongodb/laravel-mongodb</p>
        <ul>
          <li>используется в качестве драйвера кэша, очереди, сессий, БД</li>
          <li>драйвер MongoDB по умолчанию использует расширение mongodb</li>
          <li>расширение mongodb поддерживает MongoDB 2.6 и выше</li>
        </ul>
        <pre><code>php artisan vendor:publish --provider="Jenssegers\Mongodb\MongodbServiceProvider"</code></pre>
        <p>Управление кешем приложения</p>
        <pre><code>// получить экземпляр кеша
namespace App\Http\Controllers;
use Illuminate\Support\Facades\Cache;
class UserController extends Controller {
  public function index(): array {$value = Cache::get('key');
  return [ ... ];}}

// доступ к кеш-хранилищу
// 'file' - одно из хранилищ в массиве stores файла config/cache.php
$value = Cache::store('file')->get('foo');

// 10 Минут
Cache::store('redis')->put('bar', 'baz', 600);

// получить элемент из кеша
$value = Cache::get('key');
$value = Cache::get('key', 'default');

// либо со значением по умолчанию из функции, если 'key' не найден
$value = Cache::get('key', function () {return DB::table(/* ... */)->get();});

// проверить наличие элемента
if (Cache::has('key')) { ... }

// увеличить или уменьшить целочисленные значения элементов в кеше
// необязательный второй аргумент: на сколько инициализировать значение, если оно не существует
Cache::add('key', 0, now()->addHours(4));
Cache::increment('key');
Cache::increment('key', $amount);
Cache::decrement('key');
Cache::decrement('key', $amount);

// сохранить значение по умолчанию, если запрошенный элемент не существует
$value = Cache::remember('users', $seconds, function () {return DB::table('users')->get();});

// либо сохранить элемент навсегда, если он не существует
$value = Cache::rememberForever('users', function () {return DB::table('users')->get();});
</code></pre>
        <p>паттерн “stale-while-revalidate”: «устаревшего при повторной проверке»</p>
        <ul>
          <li>разрешить обслуживание частично устаревших данных во время пересчета кэшированного значения в фоновом режиме</li>
          <li>первое значение в массиве - количество секунд кеш свежий, второе - как долго он может использоваться как устаревшие данные</li>
          <li>запрос до первого значения - кэш возвращается сразу</li>
          <li>запрос между первым и вторым значениями - обновить кэш после отправки ответа пользователю</li>
          <li>запрос после второго значения - кеш просрочен, значение пересчитывается, занимает время</li>
        </ul>
        <pre><code>$value = Cache::flexible('users', [5, 10], function () {return DB::table('users')->get();});

// получить элемент из кеша, а затем удалить этот элемент
$value = Cache::pull('key');
$value = Cache::pull('key', 'default');

// сохранить элементы в кеше
Cache::put('key', 'value', $seconds = 10);
// либо через DateTime
Cache::put('key', 'value', now()->addMinutes(10));
// либо элемент будет храниться бесконечно
Cache::put('key', 'value');

// постоянное хранение элемента в кеше
Cache::forever('key', 'value');\

// добавить элемент в кеш, только если его там нет
Cache::add('key', 'value', $seconds);

// удалить элемент из кеша
Cache::forget('key');
// либо указав нулевой или отрицательной срок хранения
Cache::put('key', 'value', 0);
Cache::put('key', 'value', -5);

// очистить весь кеш: удаляет все записи из кеша не учитывая префиксы разных приложений в кеше
Cache::flush();
</code></pre>
        <p>глобальный помощник кеша</p>
        <pre><code>// получить значение из кеша по ключу
$value = cache('key');

// хранить значения в кеше в течение указанного времени
cache(['key' => 'value'], $seconds);
cache(['key' => 'value'], now()->addMinutes(10));

// получить экземпляр Illuminate\Contracts\Cache\Factory со всеми методами кеширования
// сохранить значение по умолчанию, если запрошенный элемент не существует
cache()->remember('users', $seconds, function () {return DB::table('users')->get();});
</code></pre>
        <p>Атомарные блокировки: все серверы должны взаимодействовать с одним и тем же центральным сервером кеширования.</p>
        <pre><code>// блокировка получена на 10 секунд
use Illuminate\Support\Facades\Cache;
$lock = Cache::lock('foo', 10);
if ($lock->get()) {$lock->release();}

// получить блокировку и снять через 10 секунд
Cache::lock('foo', 10)->get(function () { });

// если блокировка недоступна, то попробывать через 5 секунд, если снова нет - выбросить исключение
use Illuminate\Contracts\Cache\LockTimeoutException;
$lock = Cache::lock('foo', 10);
try {$lock->block(5);} catch (LockTimeoutException $e) { } finally {$lock->release();}

// либо если блокировка недоступна подождёт 5 секунд, если доступна - выполнит функцию и снимет блокировку
Cache::lock('foo', 10)->block(5, function () { });

// установить блокировку в одном процессе и снять ее в другом процессе

// отправим задание в очередь с токеном инициатора блокировки если блокировка получена
$podcast = Podcast::find($id);
$lock = Cache::lock('processing', 120);
if ($lock->get()) {ProcessPodcast::dispatch($podcast, $lock->owner());}

// восстановить и снять блокировку с помощью токена инициатора
Cache::restoreLock('processing', $this->owner)->release();

// принудительно снять блокировку без учета текущего инициатора
Cache::lock('processing')->forceRelease();
</code></pre>
        <p>Собственные драйвера кеша</p>
        <pre><code>// создать собственный драйвер кеша для MongoDB
namespace App\Extensions;
use Illuminate\Contracts\Cache\Store;
class MongoStore implements Store {
  public function get($key) {}
  public function many(array $keys) {}
  public function put($key, $value, $seconds) {}
  public function putMany(array $values, $seconds) {}
  public function increment($key, $value = 1) {}
  public function decrement($key, $value = 1) {}
  public function forever($key, $value) {}
  public function forget($key) {}
  public function flush() {}
  public function getPrefix() {}}
// далее реализовать каждый из этих методов, используя соединение MongoDB

// регистрация драйвера
Cache::extend('mongo', function (Application $app) {return Cache::repository(new MongoStore);});

// зарегистрировать свой драйвер кеша перед тем, как поставщики служб прочитают кешированные значения
namespace App\Providers;
use App\Extensions\MongoStore;
use Illuminate\Contracts\Foundation\Application;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\ServiceProvider;
class AppServiceProvider extends ServiceProvider {
  {$this->app->booting(function () {
    Cache::extend('mongo', function (Application $app) {
      return Cache::repository(new MongoStore);});});}
    public function boot(): void { }}</code></pre>
        <p>
          extend: первый аргумент - имя драйвера = параметру driver в config/cache.php<br/>
          второй аргумент – возвращает экземпляр Illuminate\Cache\Repository, который будет передан экземпляру контейнера служб $app<br/>
          далее обновить переменную среды CACHE_STORE в .env или default в config/cache.php
          
        </p>
        <p>События</p>
        <pre><code>// события, запускаемые кэшем:
Illuminate\Cache\Events\CacheHit
Illuminate\Cache\Events\CacheMissed
Illuminate\Cache\Events\KeyForgotten
Illuminate\Cache\Events\KeyWritten

// отключить события кэширования в config/cache.php чтобы повысить производительность
'database' => [driver' => 'database', 'events' => false]
</code></pre>
        <p>Rate Limiting: ограничить любое действие в течение указанного периода времени, использует кеш приложения по умолчанию в config/cache.php</p>
        <pre><code>// указать драйвер кеша для ограничителя скорости
'default' => env('CACHE_STORE', 'database'),
'limiter' => 'redis'

// attempt возвращает false если не осталось доступных попыток либо вернет результат функции или true
use Illuminate\Support\Facades\RateLimiter;
$executed = RateLimiter::attempt(
  'send-message:'.$user->id,
  $perMinute = 5,
  function() { Отправляю сообщение...});
if (! $executed) {return 'Отправлено слишком много сообщений!';}
// либо разрешить пять попыток каждые две минуты
$executed = RateLimiter::attempt(
  'send-message:'.$user->id,
  $perTwoMinutes = 5,
  function() { Отправляем сообщение...},
  $decayRate = 120);

// определить не превышено ли максимальное количество разрешенных попыток в минуту
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {return 'Слишком много попыток!';}
RateLimiter::increment('send-message:'.$user->id);

// получение оставшегося количества попыток
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::remaining('send-message:'.$user->id, $perMinute = 5)) {
  RateLimiter::increment('send-message:'.$user->id);}

// увеличить количество попыток для указанного ключа более чем на единицу
RateLimiter::increment('send-message:'.$user->id, amount: 5);

// availableIn возвращает количество секунд появления новых попыток
use Illuminate\Support\Facades\RateLimiter;
if (RateLimiter::tooManyAttempts('send-message:'.$user->id, $perMinute = 5)) {
  $seconds = RateLimiter::availableIn('send-message:'.$user->id);
  return 'Вы можете повторить попытку через '.$seconds.' секунд.';}
  RateLimiter::increment('send-message:'.$user->id);

// сбросить количество попыток
use App\Models\Message;
use Illuminate\Support\Facades\RateLimiter;
public function read(Message $message): Message {
  $message->markAsRead();
  RateLimiter::clear('send-message:'.$message->user_id);
  return $message;}</code></pre>
        <h2>Eloquent</h2>
        <h2>How to</h2>
        <p>Api: Установить пакет Sanctum, создать роут, миграцию personal_access_tokens_table и токен аутентификацию для api</p>
        <table>
          <tbody>
            <tr>
              <td>./sail artisan install:api</td>
              <td></td>
            </tr>
            <tr>
              <td>./sail artisan make:model Category -m</td>
              <td>Создать модель с миграцией</td>
            </tr>
            <tr>
              <td>./sail artisan migrate</td>
              <td>Обновить таблицы</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>создать контроллер в отдельной структуре папок (v1 - версия)</caption>
          <tbody>
            <tr>
              <td>model=Category</td>
              <td>привязка к модели</td>
            </tr>
            <tr>
              <td>api</td>
              <td>методы апи контроллера</td>
            </tr>
            <tr>
              <td>requests</td>
              <td>вынос валидации в отдельные классы</td>
            </tr>
          </tbody>
        </table>
        <pre><code>./sail artisan make:controller Api/V1/CategoryController --model=Category --api --requests</code></pre>
        <p>сгруппировать роуты по версиям и создать рессурсный роут</p>
        <pre><code>use App\Http\Controllers\Api\V1\CategoryController;
Route::prefix('v1')->group(function()
{
    Route::apiResource('categories', CategoryController::class);
});
</code></pre>
        <p>просмотреть список роутов</p>
        <pre><code>./sail artisan route:list --except-vendor</code></pre>
        <p>В файле bootstrap/app.php можно добавить свой обработчик ошибок</p>
        <pre><code>use Illuminate\Foundation\Configuration\Exceptions;
->withExceptions(function (Exceptions $exceptions) {
  $exceptions->render(function (NotFoundHttpException $e, Request $request) {
    if ($request->is('api/*')) {
      return response()->json([
        'message' => 'Record not found.'
      ], 404);
    }
  });
})
</code></pre>
        <p>Чтобы задать формат api ответа создать Resources</p>
        <pre><code>./sail artisan make:resource Api/V1/CategoryResource</code></pre>
        <p>в контроллере возврат данных таблицы через рессурс-коллекцию для массива данных</p>
        <pre><code>return CategoryResource::collection(Category::all());

// для возврата одной записи из таблицы данных
new CategoryResource(Category::findOrFail($id));

// либо
public function show(Category $category)
{
  return new CategoryResource($category);
}

// в Api/V1/PostResource задаю условие: поле "content" показывать если роут posts.show
"content"=> $this->when(Route::currentRouteName() == 'posts.show', $this->content)

// в Api/V1/PostResource по связи метода category из модели получаю свойство категории
"categoryName" => $this->category->title

// в Models/Post задаю связь с таблицей category методом category
public function category()
{
  return $this->belongsTo(Category::class);
}

// p в Models/Post задаю список полей, которые не участвуют в работе методов
protected $hidden = [
  "created_at",
];

// в PostController по связи метода category из модели Models/Post получаю всё одним запросом и вывожу частями по 5 постов
return PostResource::collection(Post::with('category')->paginate(5));

// для ограничения количества запросов в App\Providers\AppServiceProvider добавить в метод boot()
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\RateLimiter;
RateLimiter::for('api', function (Request $request) {
  return Limit::perMinute(60)->by($request->user()?->id ?: $request->ip());
});

// ключить ограничение middleware(['throttle:api', 'auth:sanctum']) в роуты
Route::prefix('v1')->middleware(['throttle:api'])->group(function())

// для доступа к данным апи через токен добавить в модель User
use Laravel\Sanctum\HasApiTokens;
use HasApiTokens

// установить срок жизни токена в минутах в config/sanctum.php
'expiration' = 10

// просроченные токены удалять командой sanctum:prune-expired
use Illuminate\Support\Facades\Schedule;
Schedule::command('sanctum:prune-expired --hours=24')->daily();
</code></pre>
        <p>CRUD</p>
        <pre><code>// Create model
php artisan make:model Post -mfcr
</code></pre>
        <ul>
          <li>Add columns in migration</li>
          <li>Define fillable columns and relation in Post model and relation in User model</li>
          <li>Fill database/factories/PostFactory.php and database/seeders/DatabaseSeeder.php</li>
          <li>Fill database fake data</li>
        </ul>
        <pre><code>php artisan migrate:fresh --seed

// In resources/js/types/index.d.ts create interface Post  
// Create link for images  

php artisan storage:link
</code></pre>
        <ul>
          <li>Add navItem in resources/js/components/app-sidebar.tsx to posts.index</li>
          <li>Copy resources/js/pages/dashboard.tsx to resources/js/pages/posts/index.tsx</li>
          <li>In resources/js/pages/posts/index.tsx import table from shadcn and create inertia link for post creating</li>
          <li>Copy resources/js/pages/auth/login.tsx to resources/js/pages/posts/create.tsx</li>
          <li>In resources/js/types/index.d.ts create type PostForm</li>
          <li>Import and past textarea from shadcn into resources/js/pages/posts/create.tsx</li>
          <li>Copy resources/js/pages/posts/create.tsx to resources/js/pages/posts/edit.tsx</li>
        </ul>
        <pre><code>// Create resource for posts
php artisan make:resource PostResource

// Add to boot function AppServiceProvider
JsonResource::withoutWrapping();
</code></pre>
        <ul>
          <li>Register route for posts/ in routes/web.php</li>
          <li>Fill methods in PostController</li>
        </ul>
        <pre><code>// Clear and optimazing data
php artisan optimize
php artisan optimize:clear
</code></pre>
        <ul>
          <li>Add flash messages to app/Http/Middleware/HandleInertia/Requests</li>
          <li>In resources/js/types/index.d.ts create interface Flash</li>
          <li>Import sonner toaster from shadcn component into resources/js/layouts/app-layout.tsx</li>
          <li>Display toaster into resources/js/pages/posts/index.tsx</li>
        </ul>
        <table>
          <caption>Access by SSH to VPS by password</caption>
          <tbody>
            <tr>
              <td>su - user</td>
              <td>Authenticated like user for installed Laravel on VPS</td>
            </tr>
            <tr>
              <td>cd htdocs</td>
              <td>To see domain folder with installed project</td>
            </tr>
            <tr>
              <td>cd domainfolder</td>
              <td>Come into Laravel files</td>
            </tr>
            <tr>
              <td>ssh-keygen -t ed25519 -C "my@email.com"</td>
              <td>In domainfolder generate ssh key for VPS, leave passphrase empty</td>
            </tr>
            <tr>
              <td>cat ~/.ssh/id_ed25519.pub</td>
              <td>Read VPS ssh public key, copy the key</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>In github repository open settings > Deploy keys > Add deploy key, paste VPS ssh public key (Allow write server)</caption>
          <tbody>
            <tr>
              <td>mv domainfolder/ tmp</td>
              <td>Move installed Laravel files into tmp folder</td>
            </tr>
            <tr>
              <td>git clone githubUrl domainfolder</td>
              <td>Clone Laravel files from private repository github by ssh into domainfolder</td>
            </tr>
            <tr>
              <td>cp .env.exemple .env</td>
              <td>In domainfolder copy .env file</td>
            </tr>
            <tr>
              <td>composer install</td>
              <td>In domainfolder</td>
            </tr>
            <tr>
              <td>php artisan migrate</td>
              <td>Create sqlite database</td>
            </tr>
          </tbody>
        </table>
        <table>
          <caption>Create mysql database on VPS server panel and change database setting into .env for mysql</caption>
          <table>
            <tr>
              <td>php artisan migrate</td>
              <td>Apply data into mysql database</td>
            </tr>
            <tr>
              <td>php artisan key:generate --ansi</td>
              <td>Generate app key</td>
            </tr>
          </table>
        </table>
        <p>Install as root nodejs on VPS</p>
        <pre><code>// In htdocs/domainfolder run as user
npm install
npm run build

// Fill database fake data
php artisan migrate:fresh --seed
</code></pre>
        <p>Test app in browser</p>
        <pre><code>// In conf file change command to
artisan inertia:start-ssr

// In .env file
APP-NAME=Appname
APP_ENV=prod
APP_DEBUG=false
APP_URL=Appurl</code></pre>
        <ul>
          <li>Change mail settings</li>
          <li>Create localy .github/workflows/deploy.yml with action for github</li>
          <li>Github repository &gt; settings &gt; Secrets and variables &gt; Actions</li>
          <li>Create new secret - see youtube tutorial 5:41:30</li>
        </ul>
        <p>Rename table: в файле config/queue.php меняю название таблиц по умолчанию, к названию таблицы добавляю слово queue</p>
        <pre><code>'database' => [
  'driver' => 'database',
  'connection' => env('DB_QUEUE_CONNECTION'),
  'table' => env('DB_QUEUE_TABLE', 'queued_jobs'),
  'queue' => env('DB_QUEUE', 'default'),
  'retry_after' => (int) env('DB_QUEUE_RETRY_AFTER', 90),
  'after_commit' => false,
],

'batching' => [
  'database' => env('DB_CONNECTION', 'sqlite'),
  'table' => 'queued_job_batches',
],
'failed' => [
    'driver' => env('QUEUE_FAILED_DRIVER', 'database-uuids'),
    'database' => env('DB_CONNECTION', 'sqlite'),
    'table' => 'queued_failed_jobs',
],
</code></pre>
        <p>в папке database/migrations/ к названию файла по умолчанию добавляю слово queue: 0001_01_01_000002_create_queued_jobs_table.php и в нутри файлa к названиям таблиц добавляю слово queue</p>
        <pre><code>Schema::create('queued_jobs', function (Blueprint $table) { });
Schema::create('queued_job_batches', function (Blueprint $table) { });
Schema::create('queued_failed_jobs', function (Blueprint $table) { });
</code></pre>
        <table>
          <tbody>
            <tr>
              <td>php artisan migrate:fresh</td>
              <td>удаляю старые файлы и создаю новые c учётом изменений</td>
            </tr>
            <tr>
              <td>php artisan migrate</td>
              <td>чтобы внести изменения в базу данных</td>
            </tr>
          </tbody>
        </table>
      </main>
      <menu class="menu">
        <button id="search"><img src="./assets/img/search.svg" alt="search" loading="lazy"/></button>
        <button id="home"><img src="./assets/img/q.svg" alt="home" loading="lazy"/></button>
        <button id="dropup"><img src="./assets/img/menu.svg" alt="menu" loading="lazy"/></button>
      </menu>
    </div>
  </body>
</html>